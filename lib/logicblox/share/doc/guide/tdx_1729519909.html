<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>The lb-workflow Guide</title>

    <link href="lb-favicon.png"    rel="shortcut icon" type="image/x-icon" />
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="lb-workflow.css"   rel="stylesheet">    
  </head>
  <body>
    <div class="container header-container">
      <div class="row header">
        <div class="col-lg-2">
          <a href="http://logicblox.com"><img src="lblogo.png" alt="LogicBlox, Inc."></a>
        </div>
        <div class="col-lg-10">
          <a href="index.html"><h1 class="text-center">The lb-workflow Guide</h1></a>
        </div>
      </div>
    </div>

    <div class="container contents-container">
      <div class="row">
        <div class="col-lg-2 sidebar">
          <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm">
            <ul class="nav">
              <li class="sidebar-group-header">Tasks
                <ul class="nav sidebar-group">
                    <li class="other"><a href="#1646495758" title="lb.tdx.Export">lb.tdx.Export</a></li>
                    <li class="other"><a href="#1542137885" title="lb.tdx.Import">lb.tdx.Import</a></li>
                    <li class="other"><a href="#1283649950" title="lb.tdx.PartRequest">lb.tdx.PartRequest</a></li>
                    <li class="other"><a href="#2055972593" title="lb.tdx.TransactionRequest">lb.tdx.TransactionRequest</a></li>
                </ul>
              </li>
              <li class="sidebar-group-header">Standard Library
                <ul class="nav sidebar-group">
                    <li class="other"><a href="control_1096407654.html" title="control.wf">control.wf</a></li>
                    <li class="other"><a href="jobs_2064022591.html" title="jobs.wf">jobs.wf</a></li>
                    <li class="other"><a href="log_1948900833.html" title="log.wf">log.wf</a></li>
                    <li class="other"><a href="stdlib_623000472.html" title="stdlib.wf">stdlib.wf</a></li>
                    <li class="other"><a href="string_1421446234.html" title="string.wf">string.wf</a></li>
                    <li class="other"><a href="tasks_1083303394.html" title="tasks.wf">tasks.wf</a></li>
                    <li class="current"><a href="tdx_1729519909.html" title="tdx.wf">tdx.wf</a></li>
                    <li class="other"><a href="testing-tasks_1856821761.html" title="testing-tasks.wf">testing-tasks.wf</a></li>
                    <li class="other"><a href="workbooks_290480778.html" title="workbooks.wf">workbooks.wf</a></li>
                </ul>
              </li>
              <li class="sidebar-group-header">Additional Resources
                <ul class="nav sidebar-group">
                    <li class="other"><a href="index.html" title="Index">Index</a></li>
                </ul>
              </li>
            </ul>
          </nav>
        </div>

        <div class="col-lg-10 contents">
          <div class="lb-workflow-block">
<h3>TDX Tasks</h3><p>This module declares tasks that allow to interact with TDX services.</p>          </div>
          <div class="lb-workflow-block" id="1542137885">
<p>Import CSV files with TDX services.</p><p>This task takes a set of TDXInput specifications of files to import using TDX services. It supports several parameters to control whether files should be imported in a single transaction or multiple, whether to use the the asynchronous protocol or not, how to react to failures, etc. For example, this declaration would import sales and returns data in a single transaction using the corresponding services:</p>
<pre><code>lb.tdx.Import(
   txn_service  = &quot;/txn&quot;,
   input = {
     &quot;{ service: &#39;/sales&#39;
        file:    &#39;data/sales.csv.gz&#39;
        error:   &#39;data/out/sales-errors.csv&#39;
      }&quot;,
      &quot;{ service: &#39;/returns&#39;
        file:    &#39;data/returns.csv&#39;
        error:   &#39;data/out/returns-errors.csv.gz&#39;
      }&quot;
   }
 )
</code></pre><p>One important aspect to note is that the task infers the type of the files based on file extension, and it is permitted to import gzipped files while exporting clear text error files, and vice-versa.</p><p>Refer to the documentation below for details on what is controlled by each parameter.</p>
<hr/><p>@param <code>input</code> a set of TDXInput messages that represent files to import, together with the service to be called for  the file and an optional location to store error records. The TDXInput message also allows to override certain  configurations for a single file, such as <code>allow_partial_import</code>, <code>unmatched_import_reaction</code>, <code>full</code> and  <code>error_file_only_on_error</code>. Note that the <code>file</code> attribute of TDXInput works as a pattern that accepts <code>*</code>  and <code>?</code> wildcards. The task will lookup files that match this pattern, and will import all the matching files  using the same service (see comments on TDXInput for details). The type of the file and error file are defined  by the extension: <code>.gz</code> and <code>.gzip</code> are considered gzip files, otherwise they are considered plain CSV files.  Files can be local file paths (e.g. <code>data/returns.csv</code>), file URIs (e.g. <code>file:///data/returns.csv</code>) and cloud  store locations (e.g. <code>s3://project/data/returns.csv</code>). File paths are resolved locally and file URIs are  resolved in the server.</p><p>@param <code>txn_service</code> the URI prefix of the transaction service to use (e.g.: <code>&quot;/txn&quot;</code>). If this is set, then all  TDXInput entries in <code>input</code> will be processed in a single database transaction. Otherwise, each entry will be  processed in its own transaction, and all will be executed in parallel. In this case, the task will only  succeed if every part also succeeds.</p><p>@param <code>transport</code> the URI that describes the service location. Currently only TCP transport is supported, so the URI  must be an HTTP service (e.g. the default is <code>&quot;http://localhost:8080&quot;</code>).</p><p>@param <code>async</code> whether to use the asynchronous transaction protocol. This is only valid if there is a <code>txn_service</code>  configured. It is highly recommended that you use the asynchronous protocol as it has much better performance  characteristics for client and server; the synchronous protocol should only be used for legacy servers that do  not support the asynchronous protocol.</p><p>@param <code>poll_delay</code> when using the asynchronous transaction protocol, the client will send all the specification of  the files to import in a transaction and will then start polling until the transaction is over. This parameter  determines the duration to wait between polls. Note that the client polls immediately after the  commit requests returns, so short transactions may never need to wait.</p><p>@param <code>timeout</code> the maximum duration that the import should take. The meaning of this parameter differs slightly  between asynchronous and synchronous transactions:</p>
<ul>
  <li><p>For <code>asynchronous</code> transactions, this means how long the client should keep polling for the transaction to  terminate (see <code>poll_delay</code>), and the default is to continue indefinitely. Also note that the timeout is only  checked once a polling request returned that the transaction is ongoing, which means that the precision of  <code>timeout</code> is that of <code>poll_delay</code> (e.g. if <em>poll_delay</em> is 5 seconds, the client checks the timeout only every 5  seconds, so a 6 seconds <em>timeout</em> will only expire after 10 seconds). This timeout is also used for individual  part requests and for the commit request.</p></li>
  <li><p>For <code>synchronous</code> transactions and for <code>individual parts</code> (i.e. when no <code>txn_service</code> is set), this timeout is  used as the timeout of the HTTP connection for all requests. This means that the connection is kept at most this  number of seconds and will then be dropped, which will cause the transaction to potentially abort, and the  task to fail. This includes requests for parts as well as commit.</p></li>
</ul><p>@param <code>key</code> alias for the key in the server used to decrypt the files to be imported.</p><p>@param <code>full</code> whether the import should overwrite previous data in the target predicates (i.e. use PUT). This is the  default value that is applied to all input messages, but an input message can override it if needed.</p><p>@param <code>allow_partial_import</code> whether the import request should continue even in the presence of error reconds. If  this is true, the records (CSV rows) that do not contain errors will be imported and the error records will be  discarded (or returned in an error file, if that is configured in the TDXInput). This is the default value  that is applied to all input messages, but an input message can override it if needed.</p><p>@param <code>error_file_only_on_error</code> whether error files should be returned (or exported to s3) only if there&rsquo;s actually  an import error. The default behavior (false) is to always return an error file, even if it contains only the  headers. This is the value applied to every TDXInput entry that has an <code>error</code> attribute specifying the error  file, but can be overridden individually by TDXInput entries.</p><p>@param <code>unmatched_import_reaction</code> how to react when an input message&rsquo;s pattern is unmatched by a real file to  import. This is the default value applied to all input messages, but an input message can override it if  needed. The value must be a string representing a Reaction enum (<code>&quot;FAIL&quot;</code>, <code>&quot;WARN&quot;</code> or <code>&quot;IGNORE&quot;</code>).</p><p>@return <code>import_errors</code> a boolean flag that indicates whether there were import errors in any of the service calls.  This flag is only available if the service allows partial import (otherwise any error will cause the task to  fail). Also, the flag is <strong>only bound if it is true</strong>; it is unbound if there are no import errors. That&rsquo;s  because lb-workflow does not currently have a way to compare values and it is more useful to have a bound  variable to mean true and an unbound to mean false.</p><pre><code class="lb-workflow"><span class="keyword">task</span> <span class="task">lb.tdx.Import</span>(
    input<span class="keyword">*</span><span class="keyword">:</span> <span class="message-type" >TDXInput</span><span class="separator">,</span>
    txn_service<span class="keyword">?</span><span class="separator">,</span>
    transport = <span class="string">"http://localhost:8080"</span><span class="separator">,</span>
    async = <span class="boolean">true</span><span class="separator">,</span>
    poll_delay<span class="keyword">:</span> <span class="message-type" >Duration</span><span class="keyword">?</span><span class="separator">,</span>
    timeout<span class="keyword">:</span> <span class="message-type" >Duration</span><span class="keyword">?</span><span class="separator">,</span>
    key<span class="keyword">?</span><span class="separator">,</span>
    full = <span class="boolean">false</span><span class="separator">,</span>
    allow_partial_import<span class="keyword">?</span><span class="separator">,</span>
    error_file_only_on_error = <span class="boolean">false</span><span class="separator">,</span>
    unmatched_import_reaction<span class="keyword">:</span> <span class="message-type" >Reaction</span> = <span class="string">"FAIL"</span><span class="separator">,</span>
    driver_meta<span class="keyword">?</span>
  ): (import_errors<span class="keyword">?</span>) <span class="keyword">extends</span> <span class="task"><a href="stdlib_623000472.html#296300033">AsyncTask</a></span>(
    driver_meta = <span class="varref">$driver_meta</span><span class="separator">,</span>
    task_implementation_class = <span class="string">"com.logicblox.workflow.task.tdx.Import"</span>
  )
</code></pre>
          </div>
          <div class="lb-workflow-block" id="1646495758">
<p>Export CSV files from TDX services.</p><p>This task takes a set of TDXInput specifications of files to export using TDX services. It supports several parameters to control whether files should be imported in a single transaction or multiple, whether to use the the asynchronous protocol or not, etc. For example, this declaration would export sales and returns data in a single transaction using the corresponding services:</p>
<pre><code>lb.tdx.Export(
   txn_service  = &quot;/txn&quot;,
   input = {
     &quot;{ service: &#39;/sales&#39;
        file:    &#39;data/sales.csv.gz&#39;
      }&quot;,
      &quot;{ service: &#39;/returns&#39;
        file:    &#39;data/returns.csv&#39;
      }&quot;
   }
 )
</code></pre><p>One important aspect to note is that the task infers the type of the files based on file extension.</p><p>Refer to the documentation below for details on what is controlled by each parameter.</p>
<hr/><p>@param <code>input</code> a set of TDXInput messages that represent files to export, together with the service to be called for  the file. The file attribute must not contain patterns (as in <code>lb.tdx.Import</code>) and the other attributes are  ignored. The type of the file is defined by the extension: <code>.gz</code> and <code>.gzip</code> are considered gzip files,  otherwise they are considered plain CSV files. Files can be local file paths (e.g. <code>data/returns.csv</code>), file  URIs (e.g. <code>file:///data/returns.csv</code>) and cloud store locations (e.g. <code>s3://project/data/returns.csv</code>). File  paths are resolved locally and file URIs are resolved in the server.</p><p>@param <code>txn_service</code> the URI prefix of the transaction service to use (e.g.: <code>&quot;/txn&quot;</code>). If this is set, then all  TDXInput entries in <code>input</code> will be processed in a single database transaction. Otherwise, each entry will be  processed in its own transaction, and all will be executed in parallel. In this case, the task will only  succeed if every part also succeeds.</p><p>@param <code>transport</code> the URI that describes the service location. Currently only TCP transport is supported, so the URI  must be an HTTP service (e.g. the default is <code>&quot;http://localhost:8080&quot;</code>).</p><p>@param <code>async</code> whether to use the asynchronous transaction protocol. This is only valid if there is a <code>txn_service</code>  configured. It is highly recommended that you use the asynchronous protocol as it has much better performance  characteristics for client and server; the synchronous protocol should only be used for legacy servers that do  not support the asynchronous protocol.</p><p>@param <code>poll_delay</code> when using the asynchronous transaction protocol, the client will send all the specification of  the files to export in a transaction and will then start polling until the transaction is over. This parameter  determines the number of seconds to wait between polls. Note that the client polls immediately after the  commit requests returns, so short transactions may never need to wait.</p><p>@param <code>timeout</code> the maximum number of seconds that the export should take. The meaning of this parameter differs  slightly between asynchronous and synchronous transactions:</p>
<ul>
  <li><p>For <code>asynchronous</code> transactions, this means how long the client should keep polling for the transaction to  terminate (see <code>poll_delay</code>), and the default is to continue indefinitely. Also note that the timeout is only  checked once a polling request returned that the transaction is ongoing, which means that the precision of  <code>timeout</code> is that of <code>poll_delay</code> (e.g. if <em>poll_delay</em> is 5 seconds, the client checks the timeout only every 5  seconds, so a 6 seconds <em>timeout</em> will only expire after 10 seconds).</p></li>
  <li><p>For <code>synchronous</code> transactions and for <code>individual parts</code> (i.e. when no <code>txn_service</code> is set), this timeout is  used as the timeout of the HTTP connection for all requests. This means that the connection is kept at most this  number of seconds and will then be dropped, which will cause the transaction to potentially abort, and the  task to fail.</p></li>
</ul><p>@param <code>key</code> alias for the key in the server used to encrypt the files when they are exported.</p><pre><code class="lb-workflow"><span class="keyword">task</span> <span class="task">lb.tdx.Export</span>(
    input<span class="keyword">*</span><span class="keyword">:</span> <span class="message-type" >TDXInput</span><span class="separator">,</span>
    txn_service<span class="keyword">?</span><span class="separator">,</span>
    transport = <span class="string">"http://localhost:8080"</span><span class="separator">,</span>
    async = <span class="boolean">true</span><span class="separator">,</span>
    poll_delay<span class="keyword">:</span> <span class="message-type" >Duration</span><span class="keyword">?</span><span class="separator">,</span>
    timeout<span class="keyword">:</span> <span class="message-type" >Duration</span><span class="keyword">?</span><span class="separator">,</span>
    key<span class="keyword">?</span><span class="separator">,</span>
    driver_meta<span class="keyword">?</span>
  ) <span class="keyword">extends</span> <span class="task"><a href="stdlib_623000472.html#296300033">AsyncTask</a></span>(
    driver_meta = <span class="varref">$driver_meta</span><span class="separator">,</span>
    task_implementation_class = <span class="string">"com.logicblox.workflow.task.tdx.Export"</span>
  )
</code></pre>
          </div>
          <div class="lb-workflow-block" id="2055972593">
<p>Execute a TransactionRequest.</p><p>This is a low-level generic task that simply instantiates a TransactionExecutor to execute a fully specified TransactionRequest JSON message. You can find more information about the TransactionRequest message in lb-web&rsquo;s txn.proto.</p>
<hr/><p>@param <code>request</code> the fully specified TransactionRequest JSON message to execute.</p><pre><code class="lb-workflow"><span class="keyword">task</span> <span class="task">lb.tdx.TransactionRequest</span>(request<span class="separator">,</span> driver_meta<span class="keyword">?</span>) <span class="keyword">extends</span> <span class="task"><a href="stdlib_623000472.html#296300033">AsyncTask</a></span>(
    driver_meta = <span class="varref">$driver_meta</span><span class="separator">,</span>
    task_implementation_class = <span class="string">"com.logicblox.workflow.task.tdx.TransactionRequest"</span>
  )
</code></pre>
          </div>
          <div class="lb-workflow-block" id="1283649950">
<p>Execute a PartRequest.</p><p>This is a low-level generic task that simply instantiates a TransactionExecutor to execute a fully specified PartRequest JSON message. You can find more information about the PartRequest message in lb-web&rsquo;s txn.proto.</p>
<hr/><p>@param <code>request</code> the fully specified PartRequest JSON message to execute.</p><pre><code class="lb-workflow"><span class="keyword">task</span> <span class="task">lb.tdx.PartRequest</span>(request<span class="separator">,</span> driver_meta<span class="keyword">?</span>) <span class="keyword">extends</span> <span class="task"><a href="stdlib_623000472.html#296300033">AsyncTask</a></span>(
    driver_meta = <span class="varref">$driver_meta</span><span class="separator">,</span>
    task_implementation_class = <span class="string">"com.logicblox.workflow.task.tdx.PartRequest"</span>
  )
</code></pre>
          </div>
        </div>
      </div>
    </div>
    <script src="jquery.min.js"></script>
    <script src="jquery.hoverIntent.minified.js"></script>
    <script src="bootstrap.min.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
        $('[data-toggle="popover"]').popover();   
    });
    $(".modal-hook").hoverIntent({
      over: function () {
        var target = $(this).attr("data-target");
        $(target).modal("show");
      },
      interval: 700
    });
    </script>
  </body>
</html>