// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: blox/connect/ConnectBlox.proto

#ifndef PROTOBUF_blox_2fconnect_2fConnectBlox_2eproto__INCLUDED
#define PROTOBUF_blox_2fconnect_2fConnectBlox_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "blox/connect/BloxCommand.pb.h"
#include "blox/connect/Exception.pb.h"
// @@protoc_insertion_point(includes)

namespace blox {
namespace connect {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

class Request;
class Response;
class Transaction;
class TransactionResponse;
class CreateNamedBranch;
class CreateNamedBranchResponse;
class CloseNamedBranch;
class CloseNamedBranchResponse;
class GetBranchNames;
class GetBranchNamesResponse;
class RevertDatabase;
class RevertDatabaseResponse;
class CreateWorkSpace;
class CreateWorkSpaceResponse;
class CopyWorkSpace;
class CopyWorkSpaceResponse;
class DeleteWorkSpace;
class DeleteWorkSpaceResponse;
class ImportWorkSpace;
class ImportWorkSpaceResponse;
class ExportWorkSpace;
class ExportWorkSpaceResponse;
class GetWorkSpacePath;
class GetWorkSpacePathResponse;
class GetWorkSpaceVersion;
class GetWorkSpaceVersionResponse;
class CancelRequests;
class CancelRequestsResponse;
class AdminRequest;
class AdminResponse;
class ShutdownServer;
class ShutdownServerResponse;
class AbortTransaction;
class AbortTransactionResponse;
class ListWorkSpaces;
class ListWorkSpacesResponse;
class StatusRequest;
class StatusResponse;
class WorkspaceStatus;
class RequestStatus;
class AddReplicator;
class AddReplicatorResponse;
class GetWorkspaceInfo;
class GetWorkspaceInfoResponse;
class WorkSpaceOption;
class StartMirror;
class StartMirrorResponse;
class StopMirror;
class StopMirrorResponse;
class PromoteMirror;
class PromoteMirrorResponse;
class CopyRemoteWorkSpace;
class CopyRemoteWorkSpaceResponse;
class ExecuteBatchScript;
class ExecuteBatchScriptResponse;

enum GetWorkspaceInfoResponse_State {
  GetWorkspaceInfoResponse_State_CLOSED = 0,
  GetWorkspaceInfoResponse_State_OPENED = 1,
  GetWorkspaceInfoResponse_State_INIT = 2
};
bool GetWorkspaceInfoResponse_State_IsValid(int value);
const GetWorkspaceInfoResponse_State GetWorkspaceInfoResponse_State_State_MIN = GetWorkspaceInfoResponse_State_CLOSED;
const GetWorkspaceInfoResponse_State GetWorkspaceInfoResponse_State_State_MAX = GetWorkspaceInfoResponse_State_INIT;
const int GetWorkspaceInfoResponse_State_State_ARRAYSIZE = GetWorkspaceInfoResponse_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetWorkspaceInfoResponse_State_descriptor();
inline const ::std::string& GetWorkspaceInfoResponse_State_Name(GetWorkspaceInfoResponse_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetWorkspaceInfoResponse_State_descriptor(), value);
}
inline bool GetWorkspaceInfoResponse_State_Parse(
    const ::std::string& name, GetWorkspaceInfoResponse_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetWorkspaceInfoResponse_State>(
    GetWorkspaceInfoResponse_State_descriptor(), name, value);
}
enum Priority {
  NORMAL = 1,
  LOW = 2
};
bool Priority_IsValid(int value);
const Priority Priority_MIN = NORMAL;
const Priority Priority_MAX = LOW;
const int Priority_ARRAYSIZE = Priority_MAX + 1;

const ::google::protobuf::EnumDescriptor* Priority_descriptor();
inline const ::std::string& Priority_Name(Priority value) {
  return ::google::protobuf::internal::NameOfEnum(
    Priority_descriptor(), value);
}
inline bool Priority_Parse(
    const ::std::string& name, Priority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Priority>(
    Priority_descriptor(), name, value);
}
enum RequestStatusEnum {
  QUEUED = 1,
  ACTIVE = 2
};
bool RequestStatusEnum_IsValid(int value);
const RequestStatusEnum RequestStatusEnum_MIN = QUEUED;
const RequestStatusEnum RequestStatusEnum_MAX = ACTIVE;
const int RequestStatusEnum_ARRAYSIZE = RequestStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestStatusEnum_descriptor();
inline const ::std::string& RequestStatusEnum_Name(RequestStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestStatusEnum_descriptor(), value);
}
inline bool RequestStatusEnum_Parse(
    const ::std::string& name, RequestStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestStatusEnum>(
    RequestStatusEnum_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const char* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // optional string log_level = 2;
  inline bool has_log_level() const;
  inline void clear_log_level();
  static const int kLogLevelFieldNumber = 2;
  inline const ::std::string& log_level() const;
  inline void set_log_level(const ::std::string& value);
  inline void set_log_level(const char* value);
  inline void set_log_level(const char* value, size_t size);
  inline ::std::string* mutable_log_level();
  inline ::std::string* release_log_level();
  inline void set_allocated_log_level(::std::string* log_level);

  // optional bool return_log = 3 [default = false];
  inline bool has_return_log() const;
  inline void clear_return_log();
  static const int kReturnLogFieldNumber = 3;
  inline bool return_log() const;
  inline void set_return_log(bool value);

  // optional .blox.connect.Priority priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::blox::connect::Priority priority() const;
  inline void set_priority(::blox::connect::Priority value);

  // optional .blox.connect.Transaction transaction = 5;
  inline bool has_transaction() const;
  inline void clear_transaction();
  static const int kTransactionFieldNumber = 5;
  inline const ::blox::connect::Transaction& transaction() const;
  inline ::blox::connect::Transaction* mutable_transaction();
  inline ::blox::connect::Transaction* release_transaction();
  inline void set_allocated_transaction(::blox::connect::Transaction* transaction);

  // optional .blox.connect.CreateWorkSpace create = 6;
  inline bool has_create() const;
  inline void clear_create();
  static const int kCreateFieldNumber = 6;
  inline const ::blox::connect::CreateWorkSpace& create() const;
  inline ::blox::connect::CreateWorkSpace* mutable_create();
  inline ::blox::connect::CreateWorkSpace* release_create();
  inline void set_allocated_create(::blox::connect::CreateWorkSpace* create);

  // optional .blox.connect.CopyWorkSpace copy = 7;
  inline bool has_copy() const;
  inline void clear_copy();
  static const int kCopyFieldNumber = 7;
  inline const ::blox::connect::CopyWorkSpace& copy() const;
  inline ::blox::connect::CopyWorkSpace* mutable_copy();
  inline ::blox::connect::CopyWorkSpace* release_copy();
  inline void set_allocated_copy(::blox::connect::CopyWorkSpace* copy);

  // optional .blox.connect.DeleteWorkSpace delete = 8;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 8;
  inline const ::blox::connect::DeleteWorkSpace& delete_() const;
  inline ::blox::connect::DeleteWorkSpace* mutable_delete_();
  inline ::blox::connect::DeleteWorkSpace* release_delete_();
  inline void set_allocated_delete_(::blox::connect::DeleteWorkSpace* delete_);

  // optional .blox.connect.ImportWorkSpace importws = 9;
  inline bool has_importws() const;
  inline void clear_importws();
  static const int kImportwsFieldNumber = 9;
  inline const ::blox::connect::ImportWorkSpace& importws() const;
  inline ::blox::connect::ImportWorkSpace* mutable_importws();
  inline ::blox::connect::ImportWorkSpace* release_importws();
  inline void set_allocated_importws(::blox::connect::ImportWorkSpace* importws);

  // optional .blox.connect.ExportWorkSpace exportws = 10;
  inline bool has_exportws() const;
  inline void clear_exportws();
  static const int kExportwsFieldNumber = 10;
  inline const ::blox::connect::ExportWorkSpace& exportws() const;
  inline ::blox::connect::ExportWorkSpace* mutable_exportws();
  inline ::blox::connect::ExportWorkSpace* release_exportws();
  inline void set_allocated_exportws(::blox::connect::ExportWorkSpace* exportws);

  // optional .blox.connect.GetWorkSpacePath get_ws_path = 11;
  inline bool has_get_ws_path() const;
  inline void clear_get_ws_path();
  static const int kGetWsPathFieldNumber = 11;
  inline const ::blox::connect::GetWorkSpacePath& get_ws_path() const;
  inline ::blox::connect::GetWorkSpacePath* mutable_get_ws_path();
  inline ::blox::connect::GetWorkSpacePath* release_get_ws_path();
  inline void set_allocated_get_ws_path(::blox::connect::GetWorkSpacePath* get_ws_path);

  // optional string current_working_directory = 12;
  inline bool has_current_working_directory() const;
  inline void clear_current_working_directory();
  static const int kCurrentWorkingDirectoryFieldNumber = 12;
  inline const ::std::string& current_working_directory() const;
  inline void set_current_working_directory(const ::std::string& value);
  inline void set_current_working_directory(const char* value);
  inline void set_current_working_directory(const char* value, size_t size);
  inline ::std::string* mutable_current_working_directory();
  inline ::std::string* release_current_working_directory();
  inline void set_allocated_current_working_directory(::std::string* current_working_directory);

  // optional .blox.connect.GetWorkSpaceVersion get_ws_version = 13;
  inline bool has_get_ws_version() const;
  inline void clear_get_ws_version();
  static const int kGetWsVersionFieldNumber = 13;
  inline const ::blox::connect::GetWorkSpaceVersion& get_ws_version() const;
  inline ::blox::connect::GetWorkSpaceVersion* mutable_get_ws_version();
  inline ::blox::connect::GetWorkSpaceVersion* release_get_ws_version();
  inline void set_allocated_get_ws_version(::blox::connect::GetWorkSpaceVersion* get_ws_version);

  // optional string guid = 14;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 14;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // optional .blox.connect.CancelRequests cancel_requests = 15;
  inline bool has_cancel_requests() const;
  inline void clear_cancel_requests();
  static const int kCancelRequestsFieldNumber = 15;
  inline const ::blox::connect::CancelRequests& cancel_requests() const;
  inline ::blox::connect::CancelRequests* mutable_cancel_requests();
  inline ::blox::connect::CancelRequests* release_cancel_requests();
  inline void set_allocated_cancel_requests(::blox::connect::CancelRequests* cancel_requests);

  // optional .blox.connect.AddReplicator add_replicator = 16;
  inline bool has_add_replicator() const;
  inline void clear_add_replicator();
  static const int kAddReplicatorFieldNumber = 16;
  inline const ::blox::connect::AddReplicator& add_replicator() const;
  inline ::blox::connect::AddReplicator* mutable_add_replicator();
  inline ::blox::connect::AddReplicator* release_add_replicator();
  inline void set_allocated_add_replicator(::blox::connect::AddReplicator* add_replicator);

  // optional string authenticator = 17;
  inline bool has_authenticator() const;
  inline void clear_authenticator();
  static const int kAuthenticatorFieldNumber = 17;
  inline const ::std::string& authenticator() const;
  inline void set_authenticator(const ::std::string& value);
  inline void set_authenticator(const char* value);
  inline void set_authenticator(const char* value, size_t size);
  inline ::std::string* mutable_authenticator();
  inline ::std::string* release_authenticator();
  inline void set_allocated_authenticator(::std::string* authenticator);

  // optional .blox.connect.CreateNamedBranch create_named_branch = 18;
  inline bool has_create_named_branch() const;
  inline void clear_create_named_branch();
  static const int kCreateNamedBranchFieldNumber = 18;
  inline const ::blox::connect::CreateNamedBranch& create_named_branch() const;
  inline ::blox::connect::CreateNamedBranch* mutable_create_named_branch();
  inline ::blox::connect::CreateNamedBranch* release_create_named_branch();
  inline void set_allocated_create_named_branch(::blox::connect::CreateNamedBranch* create_named_branch);

  // optional .blox.connect.CloseNamedBranch close_named_branch = 19;
  inline bool has_close_named_branch() const;
  inline void clear_close_named_branch();
  static const int kCloseNamedBranchFieldNumber = 19;
  inline const ::blox::connect::CloseNamedBranch& close_named_branch() const;
  inline ::blox::connect::CloseNamedBranch* mutable_close_named_branch();
  inline ::blox::connect::CloseNamedBranch* release_close_named_branch();
  inline void set_allocated_close_named_branch(::blox::connect::CloseNamedBranch* close_named_branch);

  // optional .blox.connect.GetBranchNames get_branch_names = 20;
  inline bool has_get_branch_names() const;
  inline void clear_get_branch_names();
  static const int kGetBranchNamesFieldNumber = 20;
  inline const ::blox::connect::GetBranchNames& get_branch_names() const;
  inline ::blox::connect::GetBranchNames* mutable_get_branch_names();
  inline ::blox::connect::GetBranchNames* release_get_branch_names();
  inline void set_allocated_get_branch_names(::blox::connect::GetBranchNames* get_branch_names);

  // optional .blox.connect.RevertDatabase revert_database = 21;
  inline bool has_revert_database() const;
  inline void clear_revert_database();
  static const int kRevertDatabaseFieldNumber = 21;
  inline const ::blox::connect::RevertDatabase& revert_database() const;
  inline ::blox::connect::RevertDatabase* mutable_revert_database();
  inline ::blox::connect::RevertDatabase* release_revert_database();
  inline void set_allocated_revert_database(::blox::connect::RevertDatabase* revert_database);

  // optional .blox.connect.GetWorkspaceInfo get_workspace_info = 22;
  inline bool has_get_workspace_info() const;
  inline void clear_get_workspace_info();
  static const int kGetWorkspaceInfoFieldNumber = 22;
  inline const ::blox::connect::GetWorkspaceInfo& get_workspace_info() const;
  inline ::blox::connect::GetWorkspaceInfo* mutable_get_workspace_info();
  inline ::blox::connect::GetWorkspaceInfo* release_get_workspace_info();
  inline void set_allocated_get_workspace_info(::blox::connect::GetWorkspaceInfo* get_workspace_info);

  // optional .blox.connect.StartMirror start_mirror = 23;
  inline bool has_start_mirror() const;
  inline void clear_start_mirror();
  static const int kStartMirrorFieldNumber = 23;
  inline const ::blox::connect::StartMirror& start_mirror() const;
  inline ::blox::connect::StartMirror* mutable_start_mirror();
  inline ::blox::connect::StartMirror* release_start_mirror();
  inline void set_allocated_start_mirror(::blox::connect::StartMirror* start_mirror);

  // optional .blox.connect.StopMirror stop_mirror = 24;
  inline bool has_stop_mirror() const;
  inline void clear_stop_mirror();
  static const int kStopMirrorFieldNumber = 24;
  inline const ::blox::connect::StopMirror& stop_mirror() const;
  inline ::blox::connect::StopMirror* mutable_stop_mirror();
  inline ::blox::connect::StopMirror* release_stop_mirror();
  inline void set_allocated_stop_mirror(::blox::connect::StopMirror* stop_mirror);

  // optional .blox.connect.PromoteMirror promote_mirror = 25;
  inline bool has_promote_mirror() const;
  inline void clear_promote_mirror();
  static const int kPromoteMirrorFieldNumber = 25;
  inline const ::blox::connect::PromoteMirror& promote_mirror() const;
  inline ::blox::connect::PromoteMirror* mutable_promote_mirror();
  inline ::blox::connect::PromoteMirror* release_promote_mirror();
  inline void set_allocated_promote_mirror(::blox::connect::PromoteMirror* promote_mirror);

  // optional .blox.connect.CopyRemoteWorkSpace copy_remote_workspace = 26;
  inline bool has_copy_remote_workspace() const;
  inline void clear_copy_remote_workspace();
  static const int kCopyRemoteWorkspaceFieldNumber = 26;
  inline const ::blox::connect::CopyRemoteWorkSpace& copy_remote_workspace() const;
  inline ::blox::connect::CopyRemoteWorkSpace* mutable_copy_remote_workspace();
  inline ::blox::connect::CopyRemoteWorkSpace* release_copy_remote_workspace();
  inline void set_allocated_copy_remote_workspace(::blox::connect::CopyRemoteWorkSpace* copy_remote_workspace);

  // optional .blox.connect.ExecuteBatchScript execute_batch_script = 27;
  inline bool has_execute_batch_script() const;
  inline void clear_execute_batch_script();
  static const int kExecuteBatchScriptFieldNumber = 27;
  inline const ::blox::connect::ExecuteBatchScript& execute_batch_script() const;
  inline ::blox::connect::ExecuteBatchScript* mutable_execute_batch_script();
  inline ::blox::connect::ExecuteBatchScript* release_execute_batch_script();
  inline void set_allocated_execute_batch_script(::blox::connect::ExecuteBatchScript* execute_batch_script);

  // @@protoc_insertion_point(class_scope:blox.connect.Request)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_log_level();
  inline void clear_has_log_level();
  inline void set_has_return_log();
  inline void clear_has_return_log();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_transaction();
  inline void clear_has_transaction();
  inline void set_has_create();
  inline void clear_has_create();
  inline void set_has_copy();
  inline void clear_has_copy();
  inline void set_has_delete_();
  inline void clear_has_delete_();
  inline void set_has_importws();
  inline void clear_has_importws();
  inline void set_has_exportws();
  inline void clear_has_exportws();
  inline void set_has_get_ws_path();
  inline void clear_has_get_ws_path();
  inline void set_has_current_working_directory();
  inline void clear_has_current_working_directory();
  inline void set_has_get_ws_version();
  inline void clear_has_get_ws_version();
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_cancel_requests();
  inline void clear_has_cancel_requests();
  inline void set_has_add_replicator();
  inline void clear_has_add_replicator();
  inline void set_has_authenticator();
  inline void clear_has_authenticator();
  inline void set_has_create_named_branch();
  inline void clear_has_create_named_branch();
  inline void set_has_close_named_branch();
  inline void clear_has_close_named_branch();
  inline void set_has_get_branch_names();
  inline void clear_has_get_branch_names();
  inline void set_has_revert_database();
  inline void clear_has_revert_database();
  inline void set_has_get_workspace_info();
  inline void clear_has_get_workspace_info();
  inline void set_has_start_mirror();
  inline void clear_has_start_mirror();
  inline void set_has_stop_mirror();
  inline void clear_has_stop_mirror();
  inline void set_has_promote_mirror();
  inline void clear_has_promote_mirror();
  inline void set_has_copy_remote_workspace();
  inline void clear_has_copy_remote_workspace();
  inline void set_has_execute_batch_script();
  inline void clear_has_execute_batch_script();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  ::std::string* log_level_;
  bool return_log_;
  int priority_;
  ::blox::connect::Transaction* transaction_;
  ::blox::connect::CreateWorkSpace* create_;
  ::blox::connect::CopyWorkSpace* copy_;
  ::blox::connect::DeleteWorkSpace* delete__;
  ::blox::connect::ImportWorkSpace* importws_;
  ::blox::connect::ExportWorkSpace* exportws_;
  ::blox::connect::GetWorkSpacePath* get_ws_path_;
  ::std::string* current_working_directory_;
  ::blox::connect::GetWorkSpaceVersion* get_ws_version_;
  ::std::string* guid_;
  ::blox::connect::CancelRequests* cancel_requests_;
  ::blox::connect::AddReplicator* add_replicator_;
  ::std::string* authenticator_;
  ::blox::connect::CreateNamedBranch* create_named_branch_;
  ::blox::connect::CloseNamedBranch* close_named_branch_;
  ::blox::connect::GetBranchNames* get_branch_names_;
  ::blox::connect::RevertDatabase* revert_database_;
  ::blox::connect::GetWorkspaceInfo* get_workspace_info_;
  ::blox::connect::StartMirror* start_mirror_;
  ::blox::connect::StopMirror* stop_mirror_;
  ::blox::connect::PromoteMirror* promote_mirror_;
  ::blox::connect::CopyRemoteWorkSpace* copy_remote_workspace_;
  ::blox::connect::ExecuteBatchScript* execute_batch_script_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const char* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // optional .blox.connect.ExceptionContainer exception = 2;
  inline bool has_exception() const;
  inline void clear_exception();
  static const int kExceptionFieldNumber = 2;
  inline const ::blox::connect::ExceptionContainer& exception() const;
  inline ::blox::connect::ExceptionContainer* mutable_exception();
  inline ::blox::connect::ExceptionContainer* release_exception();
  inline void set_allocated_exception(::blox::connect::ExceptionContainer* exception);

  // optional .blox.connect.TransactionResponse transaction = 3;
  inline bool has_transaction() const;
  inline void clear_transaction();
  static const int kTransactionFieldNumber = 3;
  inline const ::blox::connect::TransactionResponse& transaction() const;
  inline ::blox::connect::TransactionResponse* mutable_transaction();
  inline ::blox::connect::TransactionResponse* release_transaction();
  inline void set_allocated_transaction(::blox::connect::TransactionResponse* transaction);

  // optional .blox.connect.CreateWorkSpaceResponse create = 4;
  inline bool has_create() const;
  inline void clear_create();
  static const int kCreateFieldNumber = 4;
  inline const ::blox::connect::CreateWorkSpaceResponse& create() const;
  inline ::blox::connect::CreateWorkSpaceResponse* mutable_create();
  inline ::blox::connect::CreateWorkSpaceResponse* release_create();
  inline void set_allocated_create(::blox::connect::CreateWorkSpaceResponse* create);

  // optional .blox.connect.CopyWorkSpaceResponse copy = 5;
  inline bool has_copy() const;
  inline void clear_copy();
  static const int kCopyFieldNumber = 5;
  inline const ::blox::connect::CopyWorkSpaceResponse& copy() const;
  inline ::blox::connect::CopyWorkSpaceResponse* mutable_copy();
  inline ::blox::connect::CopyWorkSpaceResponse* release_copy();
  inline void set_allocated_copy(::blox::connect::CopyWorkSpaceResponse* copy);

  // optional .blox.connect.DeleteWorkSpaceResponse delete = 6;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 6;
  inline const ::blox::connect::DeleteWorkSpaceResponse& delete_() const;
  inline ::blox::connect::DeleteWorkSpaceResponse* mutable_delete_();
  inline ::blox::connect::DeleteWorkSpaceResponse* release_delete_();
  inline void set_allocated_delete_(::blox::connect::DeleteWorkSpaceResponse* delete_);

  // optional .blox.connect.ImportWorkSpaceResponse importws = 7;
  inline bool has_importws() const;
  inline void clear_importws();
  static const int kImportwsFieldNumber = 7;
  inline const ::blox::connect::ImportWorkSpaceResponse& importws() const;
  inline ::blox::connect::ImportWorkSpaceResponse* mutable_importws();
  inline ::blox::connect::ImportWorkSpaceResponse* release_importws();
  inline void set_allocated_importws(::blox::connect::ImportWorkSpaceResponse* importws);

  // optional .blox.connect.ExportWorkSpaceResponse exportws = 8;
  inline bool has_exportws() const;
  inline void clear_exportws();
  static const int kExportwsFieldNumber = 8;
  inline const ::blox::connect::ExportWorkSpaceResponse& exportws() const;
  inline ::blox::connect::ExportWorkSpaceResponse* mutable_exportws();
  inline ::blox::connect::ExportWorkSpaceResponse* release_exportws();
  inline void set_allocated_exportws(::blox::connect::ExportWorkSpaceResponse* exportws);

  // optional .blox.connect.GetWorkSpacePathResponse get_ws_path = 9;
  inline bool has_get_ws_path() const;
  inline void clear_get_ws_path();
  static const int kGetWsPathFieldNumber = 9;
  inline const ::blox::connect::GetWorkSpacePathResponse& get_ws_path() const;
  inline ::blox::connect::GetWorkSpacePathResponse* mutable_get_ws_path();
  inline ::blox::connect::GetWorkSpacePathResponse* release_get_ws_path();
  inline void set_allocated_get_ws_path(::blox::connect::GetWorkSpacePathResponse* get_ws_path);

  // optional bytes compressed_log = 10;
  inline bool has_compressed_log() const;
  inline void clear_compressed_log();
  static const int kCompressedLogFieldNumber = 10;
  inline const ::std::string& compressed_log() const;
  inline void set_compressed_log(const ::std::string& value);
  inline void set_compressed_log(const char* value);
  inline void set_compressed_log(const void* value, size_t size);
  inline ::std::string* mutable_compressed_log();
  inline ::std::string* release_compressed_log();
  inline void set_allocated_compressed_log(::std::string* compressed_log);

  // optional .blox.connect.GetWorkSpaceVersionResponse get_ws_version = 11;
  inline bool has_get_ws_version() const;
  inline void clear_get_ws_version();
  static const int kGetWsVersionFieldNumber = 11;
  inline const ::blox::connect::GetWorkSpaceVersionResponse& get_ws_version() const;
  inline ::blox::connect::GetWorkSpaceVersionResponse* mutable_get_ws_version();
  inline ::blox::connect::GetWorkSpaceVersionResponse* release_get_ws_version();
  inline void set_allocated_get_ws_version(::blox::connect::GetWorkSpaceVersionResponse* get_ws_version);

  // optional .blox.connect.CancelRequestsResponse cancel_requests = 12;
  inline bool has_cancel_requests() const;
  inline void clear_cancel_requests();
  static const int kCancelRequestsFieldNumber = 12;
  inline const ::blox::connect::CancelRequestsResponse& cancel_requests() const;
  inline ::blox::connect::CancelRequestsResponse* mutable_cancel_requests();
  inline ::blox::connect::CancelRequestsResponse* release_cancel_requests();
  inline void set_allocated_cancel_requests(::blox::connect::CancelRequestsResponse* cancel_requests);

  // optional .blox.connect.AddReplicatorResponse add_replicator = 13;
  inline bool has_add_replicator() const;
  inline void clear_add_replicator();
  static const int kAddReplicatorFieldNumber = 13;
  inline const ::blox::connect::AddReplicatorResponse& add_replicator() const;
  inline ::blox::connect::AddReplicatorResponse* mutable_add_replicator();
  inline ::blox::connect::AddReplicatorResponse* release_add_replicator();
  inline void set_allocated_add_replicator(::blox::connect::AddReplicatorResponse* add_replicator);

  // optional .blox.connect.CreateNamedBranchResponse create_named_branch = 14;
  inline bool has_create_named_branch() const;
  inline void clear_create_named_branch();
  static const int kCreateNamedBranchFieldNumber = 14;
  inline const ::blox::connect::CreateNamedBranchResponse& create_named_branch() const;
  inline ::blox::connect::CreateNamedBranchResponse* mutable_create_named_branch();
  inline ::blox::connect::CreateNamedBranchResponse* release_create_named_branch();
  inline void set_allocated_create_named_branch(::blox::connect::CreateNamedBranchResponse* create_named_branch);

  // optional .blox.connect.CloseNamedBranchResponse close_named_branch = 15;
  inline bool has_close_named_branch() const;
  inline void clear_close_named_branch();
  static const int kCloseNamedBranchFieldNumber = 15;
  inline const ::blox::connect::CloseNamedBranchResponse& close_named_branch() const;
  inline ::blox::connect::CloseNamedBranchResponse* mutable_close_named_branch();
  inline ::blox::connect::CloseNamedBranchResponse* release_close_named_branch();
  inline void set_allocated_close_named_branch(::blox::connect::CloseNamedBranchResponse* close_named_branch);

  // optional .blox.connect.GetBranchNamesResponse get_branch_names = 16;
  inline bool has_get_branch_names() const;
  inline void clear_get_branch_names();
  static const int kGetBranchNamesFieldNumber = 16;
  inline const ::blox::connect::GetBranchNamesResponse& get_branch_names() const;
  inline ::blox::connect::GetBranchNamesResponse* mutable_get_branch_names();
  inline ::blox::connect::GetBranchNamesResponse* release_get_branch_names();
  inline void set_allocated_get_branch_names(::blox::connect::GetBranchNamesResponse* get_branch_names);

  // optional .blox.connect.RevertDatabaseResponse revert_database = 17;
  inline bool has_revert_database() const;
  inline void clear_revert_database();
  static const int kRevertDatabaseFieldNumber = 17;
  inline const ::blox::connect::RevertDatabaseResponse& revert_database() const;
  inline ::blox::connect::RevertDatabaseResponse* mutable_revert_database();
  inline ::blox::connect::RevertDatabaseResponse* release_revert_database();
  inline void set_allocated_revert_database(::blox::connect::RevertDatabaseResponse* revert_database);

  // optional .blox.connect.GetWorkspaceInfoResponse get_workspace_info = 18;
  inline bool has_get_workspace_info() const;
  inline void clear_get_workspace_info();
  static const int kGetWorkspaceInfoFieldNumber = 18;
  inline const ::blox::connect::GetWorkspaceInfoResponse& get_workspace_info() const;
  inline ::blox::connect::GetWorkspaceInfoResponse* mutable_get_workspace_info();
  inline ::blox::connect::GetWorkspaceInfoResponse* release_get_workspace_info();
  inline void set_allocated_get_workspace_info(::blox::connect::GetWorkspaceInfoResponse* get_workspace_info);

  // optional .blox.connect.StartMirrorResponse start_mirror = 19;
  inline bool has_start_mirror() const;
  inline void clear_start_mirror();
  static const int kStartMirrorFieldNumber = 19;
  inline const ::blox::connect::StartMirrorResponse& start_mirror() const;
  inline ::blox::connect::StartMirrorResponse* mutable_start_mirror();
  inline ::blox::connect::StartMirrorResponse* release_start_mirror();
  inline void set_allocated_start_mirror(::blox::connect::StartMirrorResponse* start_mirror);

  // optional .blox.connect.StopMirrorResponse stop_mirror = 20;
  inline bool has_stop_mirror() const;
  inline void clear_stop_mirror();
  static const int kStopMirrorFieldNumber = 20;
  inline const ::blox::connect::StopMirrorResponse& stop_mirror() const;
  inline ::blox::connect::StopMirrorResponse* mutable_stop_mirror();
  inline ::blox::connect::StopMirrorResponse* release_stop_mirror();
  inline void set_allocated_stop_mirror(::blox::connect::StopMirrorResponse* stop_mirror);

  // optional .blox.connect.PromoteMirrorResponse promote_mirror = 21;
  inline bool has_promote_mirror() const;
  inline void clear_promote_mirror();
  static const int kPromoteMirrorFieldNumber = 21;
  inline const ::blox::connect::PromoteMirrorResponse& promote_mirror() const;
  inline ::blox::connect::PromoteMirrorResponse* mutable_promote_mirror();
  inline ::blox::connect::PromoteMirrorResponse* release_promote_mirror();
  inline void set_allocated_promote_mirror(::blox::connect::PromoteMirrorResponse* promote_mirror);

  // optional .blox.connect.CopyRemoteWorkSpaceResponse copy_remote_workspace = 22;
  inline bool has_copy_remote_workspace() const;
  inline void clear_copy_remote_workspace();
  static const int kCopyRemoteWorkspaceFieldNumber = 22;
  inline const ::blox::connect::CopyRemoteWorkSpaceResponse& copy_remote_workspace() const;
  inline ::blox::connect::CopyRemoteWorkSpaceResponse* mutable_copy_remote_workspace();
  inline ::blox::connect::CopyRemoteWorkSpaceResponse* release_copy_remote_workspace();
  inline void set_allocated_copy_remote_workspace(::blox::connect::CopyRemoteWorkSpaceResponse* copy_remote_workspace);

  // optional .blox.connect.ExecuteBatchScriptResponse execute_batch_script = 23;
  inline bool has_execute_batch_script() const;
  inline void clear_execute_batch_script();
  static const int kExecuteBatchScriptFieldNumber = 23;
  inline const ::blox::connect::ExecuteBatchScriptResponse& execute_batch_script() const;
  inline ::blox::connect::ExecuteBatchScriptResponse* mutable_execute_batch_script();
  inline ::blox::connect::ExecuteBatchScriptResponse* release_execute_batch_script();
  inline void set_allocated_execute_batch_script(::blox::connect::ExecuteBatchScriptResponse* execute_batch_script);

  // @@protoc_insertion_point(class_scope:blox.connect.Response)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_exception();
  inline void clear_has_exception();
  inline void set_has_transaction();
  inline void clear_has_transaction();
  inline void set_has_create();
  inline void clear_has_create();
  inline void set_has_copy();
  inline void clear_has_copy();
  inline void set_has_delete_();
  inline void clear_has_delete_();
  inline void set_has_importws();
  inline void clear_has_importws();
  inline void set_has_exportws();
  inline void clear_has_exportws();
  inline void set_has_get_ws_path();
  inline void clear_has_get_ws_path();
  inline void set_has_compressed_log();
  inline void clear_has_compressed_log();
  inline void set_has_get_ws_version();
  inline void clear_has_get_ws_version();
  inline void set_has_cancel_requests();
  inline void clear_has_cancel_requests();
  inline void set_has_add_replicator();
  inline void clear_has_add_replicator();
  inline void set_has_create_named_branch();
  inline void clear_has_create_named_branch();
  inline void set_has_close_named_branch();
  inline void clear_has_close_named_branch();
  inline void set_has_get_branch_names();
  inline void clear_has_get_branch_names();
  inline void set_has_revert_database();
  inline void clear_has_revert_database();
  inline void set_has_get_workspace_info();
  inline void clear_has_get_workspace_info();
  inline void set_has_start_mirror();
  inline void clear_has_start_mirror();
  inline void set_has_stop_mirror();
  inline void clear_has_stop_mirror();
  inline void set_has_promote_mirror();
  inline void clear_has_promote_mirror();
  inline void set_has_copy_remote_workspace();
  inline void clear_has_copy_remote_workspace();
  inline void set_has_execute_batch_script();
  inline void clear_has_execute_batch_script();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  ::blox::connect::ExceptionContainer* exception_;
  ::blox::connect::TransactionResponse* transaction_;
  ::blox::connect::CreateWorkSpaceResponse* create_;
  ::blox::connect::CopyWorkSpaceResponse* copy_;
  ::blox::connect::DeleteWorkSpaceResponse* delete__;
  ::blox::connect::ImportWorkSpaceResponse* importws_;
  ::blox::connect::ExportWorkSpaceResponse* exportws_;
  ::blox::connect::GetWorkSpacePathResponse* get_ws_path_;
  ::std::string* compressed_log_;
  ::blox::connect::GetWorkSpaceVersionResponse* get_ws_version_;
  ::blox::connect::CancelRequestsResponse* cancel_requests_;
  ::blox::connect::AddReplicatorResponse* add_replicator_;
  ::blox::connect::CreateNamedBranchResponse* create_named_branch_;
  ::blox::connect::CloseNamedBranchResponse* close_named_branch_;
  ::blox::connect::GetBranchNamesResponse* get_branch_names_;
  ::blox::connect::RevertDatabaseResponse* revert_database_;
  ::blox::connect::GetWorkspaceInfoResponse* get_workspace_info_;
  ::blox::connect::StartMirrorResponse* start_mirror_;
  ::blox::connect::StopMirrorResponse* stop_mirror_;
  ::blox::connect::PromoteMirrorResponse* promote_mirror_;
  ::blox::connect::CopyRemoteWorkSpaceResponse* copy_remote_workspace_;
  ::blox::connect::ExecuteBatchScriptResponse* execute_batch_script_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  Transaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string workspace = 1;
  inline bool has_workspace() const;
  inline void clear_workspace();
  static const int kWorkspaceFieldNumber = 1;
  inline const ::std::string& workspace() const;
  inline void set_workspace(const ::std::string& value);
  inline void set_workspace(const char* value);
  inline void set_workspace(const char* value, size_t size);
  inline ::std::string* mutable_workspace();
  inline ::std::string* release_workspace();
  inline void set_allocated_workspace(::std::string* workspace);

  // repeated .blox.connect.Command command = 2;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::blox::connect::Command& command(int index) const;
  inline ::blox::connect::Command* mutable_command(int index);
  inline ::blox::connect::Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
      mutable_command();

  // repeated .blox.connect.Command command_after_fixpoint = 3;
  inline int command_after_fixpoint_size() const;
  inline void clear_command_after_fixpoint();
  static const int kCommandAfterFixpointFieldNumber = 3;
  inline const ::blox::connect::Command& command_after_fixpoint(int index) const;
  inline ::blox::connect::Command* mutable_command_after_fixpoint(int index);
  inline ::blox::connect::Command* add_command_after_fixpoint();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
      command_after_fixpoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
      mutable_command_after_fixpoint();

  // optional int32 timeout = 4 [default = -1];
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);

  // optional bool exclusive = 5 [default = false];
  inline bool has_exclusive() const;
  inline void clear_exclusive();
  static const int kExclusiveFieldNumber = 5;
  inline bool exclusive() const;
  inline void set_exclusive(bool value);

  // optional bool readonly = 6 [default = false];
  inline bool has_readonly() const;
  inline void clear_readonly();
  static const int kReadonlyFieldNumber = 6;
  inline bool readonly() const;
  inline void set_readonly(bool value);

  // optional string commit_mode = 7;
  inline bool has_commit_mode() const;
  inline void clear_commit_mode();
  static const int kCommitModeFieldNumber = 7;
  inline const ::std::string& commit_mode() const;
  inline void set_commit_mode(const ::std::string& value);
  inline void set_commit_mode(const char* value);
  inline void set_commit_mode(const char* value, size_t size);
  inline ::std::string* mutable_commit_mode();
  inline ::std::string* release_commit_mode();
  inline void set_allocated_commit_mode(::std::string* commit_mode);

  // @@protoc_insertion_point(class_scope:blox.connect.Transaction)
 private:
  inline void set_has_workspace();
  inline void clear_has_workspace();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_exclusive();
  inline void clear_has_exclusive();
  inline void set_has_readonly();
  inline void clear_has_readonly();
  inline void set_has_commit_mode();
  inline void clear_has_commit_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* workspace_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Command > command_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Command > command_after_fixpoint_;
  ::google::protobuf::int32 timeout_;
  bool exclusive_;
  bool readonly_;
  ::std::string* commit_mode_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class TransactionResponse : public ::google::protobuf::Message {
 public:
  TransactionResponse();
  virtual ~TransactionResponse();

  TransactionResponse(const TransactionResponse& from);

  inline TransactionResponse& operator=(const TransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionResponse& default_instance();

  void Swap(TransactionResponse* other);

  // implements Message ----------------------------------------------

  TransactionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionResponse& from);
  void MergeFrom(const TransactionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox.connect.CommandResponse command = 1;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::blox::connect::CommandResponse& command(int index) const;
  inline ::blox::connect::CommandResponse* mutable_command(int index);
  inline ::blox::connect::CommandResponse* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
      mutable_command();

  // repeated .blox.connect.CommandResponse command_after_fixpoint = 2;
  inline int command_after_fixpoint_size() const;
  inline void clear_command_after_fixpoint();
  static const int kCommandAfterFixpointFieldNumber = 2;
  inline const ::blox::connect::CommandResponse& command_after_fixpoint(int index) const;
  inline ::blox::connect::CommandResponse* mutable_command_after_fixpoint(int index);
  inline ::blox::connect::CommandResponse* add_command_after_fixpoint();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
      command_after_fixpoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
      mutable_command_after_fixpoint();

  // @@protoc_insertion_point(class_scope:blox.connect.TransactionResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse > command_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse > command_after_fixpoint_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static TransactionResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateNamedBranch : public ::google::protobuf::Message {
 public:
  CreateNamedBranch();
  virtual ~CreateNamedBranch();

  CreateNamedBranch(const CreateNamedBranch& from);

  inline CreateNamedBranch& operator=(const CreateNamedBranch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateNamedBranch& default_instance();

  void Swap(CreateNamedBranch* other);

  // implements Message ----------------------------------------------

  CreateNamedBranch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateNamedBranch& from);
  void MergeFrom(const CreateNamedBranch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string workspace = 1;
  inline bool has_workspace() const;
  inline void clear_workspace();
  static const int kWorkspaceFieldNumber = 1;
  inline const ::std::string& workspace() const;
  inline void set_workspace(const ::std::string& value);
  inline void set_workspace(const char* value);
  inline void set_workspace(const char* value, size_t size);
  inline ::std::string* mutable_workspace();
  inline ::std::string* release_workspace();
  inline void set_allocated_workspace(::std::string* workspace);

  // required string branch = 2;
  inline bool has_branch() const;
  inline void clear_branch();
  static const int kBranchFieldNumber = 2;
  inline const ::std::string& branch() const;
  inline void set_branch(const ::std::string& value);
  inline void set_branch(const char* value);
  inline void set_branch(const char* value, size_t size);
  inline ::std::string* mutable_branch();
  inline ::std::string* release_branch();
  inline void set_allocated_branch(::std::string* branch);

  // optional string from_branch = 3;
  inline bool has_from_branch() const;
  inline void clear_from_branch();
  static const int kFromBranchFieldNumber = 3;
  inline const ::std::string& from_branch() const;
  inline void set_from_branch(const ::std::string& value);
  inline void set_from_branch(const char* value);
  inline void set_from_branch(const char* value, size_t size);
  inline ::std::string* mutable_from_branch();
  inline ::std::string* release_from_branch();
  inline void set_allocated_from_branch(::std::string* from_branch);

  // optional bool overwrite = 4;
  inline bool has_overwrite() const;
  inline void clear_overwrite();
  static const int kOverwriteFieldNumber = 4;
  inline bool overwrite() const;
  inline void set_overwrite(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.CreateNamedBranch)
 private:
  inline void set_has_workspace();
  inline void clear_has_workspace();
  inline void set_has_branch();
  inline void clear_has_branch();
  inline void set_has_from_branch();
  inline void clear_has_from_branch();
  inline void set_has_overwrite();
  inline void clear_has_overwrite();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* workspace_;
  ::std::string* branch_;
  ::std::string* from_branch_;
  bool overwrite_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CreateNamedBranch* default_instance_;
};
// -------------------------------------------------------------------

class CreateNamedBranchResponse : public ::google::protobuf::Message {
 public:
  CreateNamedBranchResponse();
  virtual ~CreateNamedBranchResponse();

  CreateNamedBranchResponse(const CreateNamedBranchResponse& from);

  inline CreateNamedBranchResponse& operator=(const CreateNamedBranchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateNamedBranchResponse& default_instance();

  void Swap(CreateNamedBranchResponse* other);

  // implements Message ----------------------------------------------

  CreateNamedBranchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateNamedBranchResponse& from);
  void MergeFrom(const CreateNamedBranchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.CreateNamedBranchResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CreateNamedBranchResponse* default_instance_;
};
// -------------------------------------------------------------------

class CloseNamedBranch : public ::google::protobuf::Message {
 public:
  CloseNamedBranch();
  virtual ~CloseNamedBranch();

  CloseNamedBranch(const CloseNamedBranch& from);

  inline CloseNamedBranch& operator=(const CloseNamedBranch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseNamedBranch& default_instance();

  void Swap(CloseNamedBranch* other);

  // implements Message ----------------------------------------------

  CloseNamedBranch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseNamedBranch& from);
  void MergeFrom(const CloseNamedBranch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string workspace = 1;
  inline bool has_workspace() const;
  inline void clear_workspace();
  static const int kWorkspaceFieldNumber = 1;
  inline const ::std::string& workspace() const;
  inline void set_workspace(const ::std::string& value);
  inline void set_workspace(const char* value);
  inline void set_workspace(const char* value, size_t size);
  inline ::std::string* mutable_workspace();
  inline ::std::string* release_workspace();
  inline void set_allocated_workspace(::std::string* workspace);

  // required string branch = 2;
  inline bool has_branch() const;
  inline void clear_branch();
  static const int kBranchFieldNumber = 2;
  inline const ::std::string& branch() const;
  inline void set_branch(const ::std::string& value);
  inline void set_branch(const char* value);
  inline void set_branch(const char* value, size_t size);
  inline ::std::string* mutable_branch();
  inline ::std::string* release_branch();
  inline void set_allocated_branch(::std::string* branch);

  // @@protoc_insertion_point(class_scope:blox.connect.CloseNamedBranch)
 private:
  inline void set_has_workspace();
  inline void clear_has_workspace();
  inline void set_has_branch();
  inline void clear_has_branch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* workspace_;
  ::std::string* branch_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CloseNamedBranch* default_instance_;
};
// -------------------------------------------------------------------

class CloseNamedBranchResponse : public ::google::protobuf::Message {
 public:
  CloseNamedBranchResponse();
  virtual ~CloseNamedBranchResponse();

  CloseNamedBranchResponse(const CloseNamedBranchResponse& from);

  inline CloseNamedBranchResponse& operator=(const CloseNamedBranchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseNamedBranchResponse& default_instance();

  void Swap(CloseNamedBranchResponse* other);

  // implements Message ----------------------------------------------

  CloseNamedBranchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseNamedBranchResponse& from);
  void MergeFrom(const CloseNamedBranchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.CloseNamedBranchResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CloseNamedBranchResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetBranchNames : public ::google::protobuf::Message {
 public:
  GetBranchNames();
  virtual ~GetBranchNames();

  GetBranchNames(const GetBranchNames& from);

  inline GetBranchNames& operator=(const GetBranchNames& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBranchNames& default_instance();

  void Swap(GetBranchNames* other);

  // implements Message ----------------------------------------------

  GetBranchNames* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBranchNames& from);
  void MergeFrom(const GetBranchNames& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string workspace = 1;
  inline bool has_workspace() const;
  inline void clear_workspace();
  static const int kWorkspaceFieldNumber = 1;
  inline const ::std::string& workspace() const;
  inline void set_workspace(const ::std::string& value);
  inline void set_workspace(const char* value);
  inline void set_workspace(const char* value, size_t size);
  inline ::std::string* mutable_workspace();
  inline ::std::string* release_workspace();
  inline void set_allocated_workspace(::std::string* workspace);

  // required bool include_auto_versions = 2;
  inline bool has_include_auto_versions() const;
  inline void clear_include_auto_versions();
  static const int kIncludeAutoVersionsFieldNumber = 2;
  inline bool include_auto_versions() const;
  inline void set_include_auto_versions(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.GetBranchNames)
 private:
  inline void set_has_workspace();
  inline void clear_has_workspace();
  inline void set_has_include_auto_versions();
  inline void clear_has_include_auto_versions();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* workspace_;
  bool include_auto_versions_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static GetBranchNames* default_instance_;
};
// -------------------------------------------------------------------

class GetBranchNamesResponse : public ::google::protobuf::Message {
 public:
  GetBranchNamesResponse();
  virtual ~GetBranchNamesResponse();

  GetBranchNamesResponse(const GetBranchNamesResponse& from);

  inline GetBranchNamesResponse& operator=(const GetBranchNamesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBranchNamesResponse& default_instance();

  void Swap(GetBranchNamesResponse* other);

  // implements Message ----------------------------------------------

  GetBranchNamesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBranchNamesResponse& from);
  void MergeFrom(const GetBranchNamesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 1;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // @@protoc_insertion_point(class_scope:blox.connect.GetBranchNamesResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static GetBranchNamesResponse* default_instance_;
};
// -------------------------------------------------------------------

class RevertDatabase : public ::google::protobuf::Message {
 public:
  RevertDatabase();
  virtual ~RevertDatabase();

  RevertDatabase(const RevertDatabase& from);

  inline RevertDatabase& operator=(const RevertDatabase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RevertDatabase& default_instance();

  void Swap(RevertDatabase* other);

  // implements Message ----------------------------------------------

  RevertDatabase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RevertDatabase& from);
  void MergeFrom(const RevertDatabase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string workspace = 1;
  inline bool has_workspace() const;
  inline void clear_workspace();
  static const int kWorkspaceFieldNumber = 1;
  inline const ::std::string& workspace() const;
  inline void set_workspace(const ::std::string& value);
  inline void set_workspace(const char* value);
  inline void set_workspace(const char* value, size_t size);
  inline ::std::string* mutable_workspace();
  inline ::std::string* release_workspace();
  inline void set_allocated_workspace(::std::string* workspace);

  // required string older_branch = 2;
  inline bool has_older_branch() const;
  inline void clear_older_branch();
  static const int kOlderBranchFieldNumber = 2;
  inline const ::std::string& older_branch() const;
  inline void set_older_branch(const ::std::string& value);
  inline void set_older_branch(const char* value);
  inline void set_older_branch(const char* value, size_t size);
  inline ::std::string* mutable_older_branch();
  inline ::std::string* release_older_branch();
  inline void set_allocated_older_branch(::std::string* older_branch);

  // @@protoc_insertion_point(class_scope:blox.connect.RevertDatabase)
 private:
  inline void set_has_workspace();
  inline void clear_has_workspace();
  inline void set_has_older_branch();
  inline void clear_has_older_branch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* workspace_;
  ::std::string* older_branch_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static RevertDatabase* default_instance_;
};
// -------------------------------------------------------------------

class RevertDatabaseResponse : public ::google::protobuf::Message {
 public:
  RevertDatabaseResponse();
  virtual ~RevertDatabaseResponse();

  RevertDatabaseResponse(const RevertDatabaseResponse& from);

  inline RevertDatabaseResponse& operator=(const RevertDatabaseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RevertDatabaseResponse& default_instance();

  void Swap(RevertDatabaseResponse* other);

  // implements Message ----------------------------------------------

  RevertDatabaseResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RevertDatabaseResponse& from);
  void MergeFrom(const RevertDatabaseResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.RevertDatabaseResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static RevertDatabaseResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateWorkSpace : public ::google::protobuf::Message {
 public:
  CreateWorkSpace();
  virtual ~CreateWorkSpace();

  CreateWorkSpace(const CreateWorkSpace& from);

  inline CreateWorkSpace& operator=(const CreateWorkSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateWorkSpace& default_instance();

  void Swap(CreateWorkSpace* other);

  // implements Message ----------------------------------------------

  CreateWorkSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateWorkSpace& from);
  void MergeFrom(const CreateWorkSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .blox.connect.Command command = 2;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::blox::connect::Command& command(int index) const;
  inline ::blox::connect::Command* mutable_command(int index);
  inline ::blox::connect::Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
      mutable_command();

  // repeated .blox.connect.Command command_after_fixpoint = 3;
  inline int command_after_fixpoint_size() const;
  inline void clear_command_after_fixpoint();
  static const int kCommandAfterFixpointFieldNumber = 3;
  inline const ::blox::connect::Command& command_after_fixpoint(int index) const;
  inline ::blox::connect::Command* mutable_command_after_fixpoint(int index);
  inline ::blox::connect::Command* add_command_after_fixpoint();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
      command_after_fixpoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
      mutable_command_after_fixpoint();

  // optional bool measure_engine = 4 [default = false];
  inline bool has_measure_engine() const;
  inline void clear_measure_engine();
  static const int kMeasureEngineFieldNumber = 4;
  inline bool measure_engine() const;
  inline void set_measure_engine(bool value);

  // optional bool snapshot_isolation = 5 [default = false];
  inline bool has_snapshot_isolation() const;
  inline void clear_snapshot_isolation();
  static const int kSnapshotIsolationFieldNumber = 5;
  inline bool snapshot_isolation() const;
  inline void set_snapshot_isolation(bool value);

  // optional string libraries = 6;
  inline bool has_libraries() const;
  inline void clear_libraries();
  static const int kLibrariesFieldNumber = 6;
  inline const ::std::string& libraries() const;
  inline void set_libraries(const ::std::string& value);
  inline void set_libraries(const char* value);
  inline void set_libraries(const char* value, size_t size);
  inline ::std::string* mutable_libraries();
  inline ::std::string* release_libraries();
  inline void set_allocated_libraries(::std::string* libraries);

  // optional bool overwrite = 7;
  inline bool has_overwrite() const;
  inline void clear_overwrite();
  static const int kOverwriteFieldNumber = 7;
  inline bool overwrite() const;
  inline void set_overwrite(bool value);

  // optional bool unique = 8;
  inline bool has_unique() const;
  inline void clear_unique();
  static const int kUniqueFieldNumber = 8;
  inline bool unique() const;
  inline void set_unique(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.CreateWorkSpace)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_measure_engine();
  inline void clear_has_measure_engine();
  inline void set_has_snapshot_isolation();
  inline void clear_has_snapshot_isolation();
  inline void set_has_libraries();
  inline void clear_has_libraries();
  inline void set_has_overwrite();
  inline void clear_has_overwrite();
  inline void set_has_unique();
  inline void clear_has_unique();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Command > command_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Command > command_after_fixpoint_;
  ::std::string* libraries_;
  bool measure_engine_;
  bool snapshot_isolation_;
  bool overwrite_;
  bool unique_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CreateWorkSpace* default_instance_;
};
// -------------------------------------------------------------------

class CreateWorkSpaceResponse : public ::google::protobuf::Message {
 public:
  CreateWorkSpaceResponse();
  virtual ~CreateWorkSpaceResponse();

  CreateWorkSpaceResponse(const CreateWorkSpaceResponse& from);

  inline CreateWorkSpaceResponse& operator=(const CreateWorkSpaceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateWorkSpaceResponse& default_instance();

  void Swap(CreateWorkSpaceResponse* other);

  // implements Message ----------------------------------------------

  CreateWorkSpaceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateWorkSpaceResponse& from);
  void MergeFrom(const CreateWorkSpaceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .blox.connect.CommandResponse command = 2;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::blox::connect::CommandResponse& command(int index) const;
  inline ::blox::connect::CommandResponse* mutable_command(int index);
  inline ::blox::connect::CommandResponse* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
      mutable_command();

  // repeated .blox.connect.CommandResponse command_after_fixpoint = 3;
  inline int command_after_fixpoint_size() const;
  inline void clear_command_after_fixpoint();
  static const int kCommandAfterFixpointFieldNumber = 3;
  inline const ::blox::connect::CommandResponse& command_after_fixpoint(int index) const;
  inline ::blox::connect::CommandResponse* mutable_command_after_fixpoint(int index);
  inline ::blox::connect::CommandResponse* add_command_after_fixpoint();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
      command_after_fixpoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
      mutable_command_after_fixpoint();

  // @@protoc_insertion_point(class_scope:blox.connect.CreateWorkSpaceResponse)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse > command_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse > command_after_fixpoint_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CreateWorkSpaceResponse* default_instance_;
};
// -------------------------------------------------------------------

class CopyWorkSpace : public ::google::protobuf::Message {
 public:
  CopyWorkSpace();
  virtual ~CopyWorkSpace();

  CopyWorkSpace(const CopyWorkSpace& from);

  inline CopyWorkSpace& operator=(const CopyWorkSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CopyWorkSpace& default_instance();

  void Swap(CopyWorkSpace* other);

  // implements Message ----------------------------------------------

  CopyWorkSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CopyWorkSpace& from);
  void MergeFrom(const CopyWorkSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string new_path = 2;
  inline bool has_new_path() const;
  inline void clear_new_path();
  static const int kNewPathFieldNumber = 2;
  inline const ::std::string& new_path() const;
  inline void set_new_path(const ::std::string& value);
  inline void set_new_path(const char* value);
  inline void set_new_path(const char* value, size_t size);
  inline ::std::string* mutable_new_path();
  inline ::std::string* release_new_path();
  inline void set_allocated_new_path(::std::string* new_path);

  // @@protoc_insertion_point(class_scope:blox.connect.CopyWorkSpace)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_new_path();
  inline void clear_has_new_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::std::string* new_path_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CopyWorkSpace* default_instance_;
};
// -------------------------------------------------------------------

class CopyWorkSpaceResponse : public ::google::protobuf::Message {
 public:
  CopyWorkSpaceResponse();
  virtual ~CopyWorkSpaceResponse();

  CopyWorkSpaceResponse(const CopyWorkSpaceResponse& from);

  inline CopyWorkSpaceResponse& operator=(const CopyWorkSpaceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CopyWorkSpaceResponse& default_instance();

  void Swap(CopyWorkSpaceResponse* other);

  // implements Message ----------------------------------------------

  CopyWorkSpaceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CopyWorkSpaceResponse& from);
  void MergeFrom(const CopyWorkSpaceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:blox.connect.CopyWorkSpaceResponse)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CopyWorkSpaceResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteWorkSpace : public ::google::protobuf::Message {
 public:
  DeleteWorkSpace();
  virtual ~DeleteWorkSpace();

  DeleteWorkSpace(const DeleteWorkSpace& from);

  inline DeleteWorkSpace& operator=(const DeleteWorkSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteWorkSpace& default_instance();

  void Swap(DeleteWorkSpace* other);

  // implements Message ----------------------------------------------

  DeleteWorkSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteWorkSpace& from);
  void MergeFrom(const DeleteWorkSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool ignore_nonexistent = 2;
  inline bool has_ignore_nonexistent() const;
  inline void clear_ignore_nonexistent();
  static const int kIgnoreNonexistentFieldNumber = 2;
  inline bool ignore_nonexistent() const;
  inline void set_ignore_nonexistent(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.DeleteWorkSpace)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ignore_nonexistent();
  inline void clear_has_ignore_nonexistent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  bool ignore_nonexistent_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static DeleteWorkSpace* default_instance_;
};
// -------------------------------------------------------------------

class DeleteWorkSpaceResponse : public ::google::protobuf::Message {
 public:
  DeleteWorkSpaceResponse();
  virtual ~DeleteWorkSpaceResponse();

  DeleteWorkSpaceResponse(const DeleteWorkSpaceResponse& from);

  inline DeleteWorkSpaceResponse& operator=(const DeleteWorkSpaceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteWorkSpaceResponse& default_instance();

  void Swap(DeleteWorkSpaceResponse* other);

  // implements Message ----------------------------------------------

  DeleteWorkSpaceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteWorkSpaceResponse& from);
  void MergeFrom(const DeleteWorkSpaceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.DeleteWorkSpaceResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static DeleteWorkSpaceResponse* default_instance_;
};
// -------------------------------------------------------------------

class ImportWorkSpace : public ::google::protobuf::Message {
 public:
  ImportWorkSpace();
  virtual ~ImportWorkSpace();

  ImportWorkSpace(const ImportWorkSpace& from);

  inline ImportWorkSpace& operator=(const ImportWorkSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportWorkSpace& default_instance();

  void Swap(ImportWorkSpace* other);

  // implements Message ----------------------------------------------

  ImportWorkSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImportWorkSpace& from);
  void MergeFrom(const ImportWorkSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src_filepath = 1;
  inline bool has_src_filepath() const;
  inline void clear_src_filepath();
  static const int kSrcFilepathFieldNumber = 1;
  inline const ::std::string& src_filepath() const;
  inline void set_src_filepath(const ::std::string& value);
  inline void set_src_filepath(const char* value);
  inline void set_src_filepath(const char* value, size_t size);
  inline ::std::string* mutable_src_filepath();
  inline ::std::string* release_src_filepath();
  inline void set_allocated_src_filepath(::std::string* src_filepath);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool overwrite = 3;
  inline bool has_overwrite() const;
  inline void clear_overwrite();
  static const int kOverwriteFieldNumber = 3;
  inline bool overwrite() const;
  inline void set_overwrite(bool value);

  // optional bool unique = 4;
  inline bool has_unique() const;
  inline void clear_unique();
  static const int kUniqueFieldNumber = 4;
  inline bool unique() const;
  inline void set_unique(bool value);

  // repeated .blox.connect.Command command = 5;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 5;
  inline const ::blox::connect::Command& command(int index) const;
  inline ::blox::connect::Command* mutable_command(int index);
  inline ::blox::connect::Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
      mutable_command();

  // repeated .blox.connect.Command command_after_fixpoint = 6;
  inline int command_after_fixpoint_size() const;
  inline void clear_command_after_fixpoint();
  static const int kCommandAfterFixpointFieldNumber = 6;
  inline const ::blox::connect::Command& command_after_fixpoint(int index) const;
  inline ::blox::connect::Command* mutable_command_after_fixpoint(int index);
  inline ::blox::connect::Command* add_command_after_fixpoint();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
      command_after_fixpoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
      mutable_command_after_fixpoint();

  // @@protoc_insertion_point(class_scope:blox.connect.ImportWorkSpace)
 private:
  inline void set_has_src_filepath();
  inline void clear_has_src_filepath();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_overwrite();
  inline void clear_has_overwrite();
  inline void set_has_unique();
  inline void clear_has_unique();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* src_filepath_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Command > command_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Command > command_after_fixpoint_;
  bool overwrite_;
  bool unique_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ImportWorkSpace* default_instance_;
};
// -------------------------------------------------------------------

class ImportWorkSpaceResponse : public ::google::protobuf::Message {
 public:
  ImportWorkSpaceResponse();
  virtual ~ImportWorkSpaceResponse();

  ImportWorkSpaceResponse(const ImportWorkSpaceResponse& from);

  inline ImportWorkSpaceResponse& operator=(const ImportWorkSpaceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportWorkSpaceResponse& default_instance();

  void Swap(ImportWorkSpaceResponse* other);

  // implements Message ----------------------------------------------

  ImportWorkSpaceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImportWorkSpaceResponse& from);
  void MergeFrom(const ImportWorkSpaceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string filepath = 2;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 2;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // repeated .blox.connect.CommandResponse command = 3;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 3;
  inline const ::blox::connect::CommandResponse& command(int index) const;
  inline ::blox::connect::CommandResponse* mutable_command(int index);
  inline ::blox::connect::CommandResponse* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
      mutable_command();

  // repeated .blox.connect.CommandResponse command_after_fixpoint = 4;
  inline int command_after_fixpoint_size() const;
  inline void clear_command_after_fixpoint();
  static const int kCommandAfterFixpointFieldNumber = 4;
  inline const ::blox::connect::CommandResponse& command_after_fixpoint(int index) const;
  inline ::blox::connect::CommandResponse* mutable_command_after_fixpoint(int index);
  inline ::blox::connect::CommandResponse* add_command_after_fixpoint();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
      command_after_fixpoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
      mutable_command_after_fixpoint();

  // @@protoc_insertion_point(class_scope:blox.connect.ImportWorkSpaceResponse)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_filepath();
  inline void clear_has_filepath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* filepath_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse > command_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse > command_after_fixpoint_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ImportWorkSpaceResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExportWorkSpace : public ::google::protobuf::Message {
 public:
  ExportWorkSpace();
  virtual ~ExportWorkSpace();

  ExportWorkSpace(const ExportWorkSpace& from);

  inline ExportWorkSpace& operator=(const ExportWorkSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExportWorkSpace& default_instance();

  void Swap(ExportWorkSpace* other);

  // implements Message ----------------------------------------------

  ExportWorkSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExportWorkSpace& from);
  void MergeFrom(const ExportWorkSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string dest_filepath = 2;
  inline bool has_dest_filepath() const;
  inline void clear_dest_filepath();
  static const int kDestFilepathFieldNumber = 2;
  inline const ::std::string& dest_filepath() const;
  inline void set_dest_filepath(const ::std::string& value);
  inline void set_dest_filepath(const char* value);
  inline void set_dest_filepath(const char* value, size_t size);
  inline ::std::string* mutable_dest_filepath();
  inline ::std::string* release_dest_filepath();
  inline void set_allocated_dest_filepath(::std::string* dest_filepath);

  // optional bool overwrite = 5;
  inline bool has_overwrite() const;
  inline void clear_overwrite();
  static const int kOverwriteFieldNumber = 5;
  inline bool overwrite() const;
  inline void set_overwrite(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.ExportWorkSpace)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_dest_filepath();
  inline void clear_has_dest_filepath();
  inline void set_has_overwrite();
  inline void clear_has_overwrite();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* dest_filepath_;
  bool overwrite_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ExportWorkSpace* default_instance_;
};
// -------------------------------------------------------------------

class ExportWorkSpaceResponse : public ::google::protobuf::Message {
 public:
  ExportWorkSpaceResponse();
  virtual ~ExportWorkSpaceResponse();

  ExportWorkSpaceResponse(const ExportWorkSpaceResponse& from);

  inline ExportWorkSpaceResponse& operator=(const ExportWorkSpaceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExportWorkSpaceResponse& default_instance();

  void Swap(ExportWorkSpaceResponse* other);

  // implements Message ----------------------------------------------

  ExportWorkSpaceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExportWorkSpaceResponse& from);
  void MergeFrom(const ExportWorkSpaceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.ExportWorkSpaceResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ExportWorkSpaceResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetWorkSpacePath : public ::google::protobuf::Message {
 public:
  GetWorkSpacePath();
  virtual ~GetWorkSpacePath();

  GetWorkSpacePath(const GetWorkSpacePath& from);

  inline GetWorkSpacePath& operator=(const GetWorkSpacePath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWorkSpacePath& default_instance();

  void Swap(GetWorkSpacePath* other);

  // implements Message ----------------------------------------------

  GetWorkSpacePath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetWorkSpacePath& from);
  void MergeFrom(const GetWorkSpacePath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool inverse = 2 [default = false];
  inline bool has_inverse() const;
  inline void clear_inverse();
  static const int kInverseFieldNumber = 2;
  inline bool inverse() const;
  inline void set_inverse(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.GetWorkSpacePath)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_inverse();
  inline void clear_has_inverse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  bool inverse_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static GetWorkSpacePath* default_instance_;
};
// -------------------------------------------------------------------

class GetWorkSpacePathResponse : public ::google::protobuf::Message {
 public:
  GetWorkSpacePathResponse();
  virtual ~GetWorkSpacePathResponse();

  GetWorkSpacePathResponse(const GetWorkSpacePathResponse& from);

  inline GetWorkSpacePathResponse& operator=(const GetWorkSpacePathResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWorkSpacePathResponse& default_instance();

  void Swap(GetWorkSpacePathResponse* other);

  // implements Message ----------------------------------------------

  GetWorkSpacePathResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetWorkSpacePathResponse& from);
  void MergeFrom(const GetWorkSpacePathResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filepath = 1;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 1;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // @@protoc_insertion_point(class_scope:blox.connect.GetWorkSpacePathResponse)
 private:
  inline void set_has_filepath();
  inline void clear_has_filepath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filepath_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static GetWorkSpacePathResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetWorkSpaceVersion : public ::google::protobuf::Message {
 public:
  GetWorkSpaceVersion();
  virtual ~GetWorkSpaceVersion();

  GetWorkSpaceVersion(const GetWorkSpaceVersion& from);

  inline GetWorkSpaceVersion& operator=(const GetWorkSpaceVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWorkSpaceVersion& default_instance();

  void Swap(GetWorkSpaceVersion* other);

  // implements Message ----------------------------------------------

  GetWorkSpaceVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetWorkSpaceVersion& from);
  void MergeFrom(const GetWorkSpaceVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:blox.connect.GetWorkSpaceVersion)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static GetWorkSpaceVersion* default_instance_;
};
// -------------------------------------------------------------------

class GetWorkSpaceVersionResponse : public ::google::protobuf::Message {
 public:
  GetWorkSpaceVersionResponse();
  virtual ~GetWorkSpaceVersionResponse();

  GetWorkSpaceVersionResponse(const GetWorkSpaceVersionResponse& from);

  inline GetWorkSpaceVersionResponse& operator=(const GetWorkSpaceVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWorkSpaceVersionResponse& default_instance();

  void Swap(GetWorkSpaceVersionResponse* other);

  // implements Message ----------------------------------------------

  GetWorkSpaceVersionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetWorkSpaceVersionResponse& from);
  void MergeFrom(const GetWorkSpaceVersionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string minor_version = 3;
  inline bool has_minor_version() const;
  inline void clear_minor_version();
  static const int kMinorVersionFieldNumber = 3;
  inline const ::std::string& minor_version() const;
  inline void set_minor_version(const ::std::string& value);
  inline void set_minor_version(const char* value);
  inline void set_minor_version(const char* value, size_t size);
  inline ::std::string* mutable_minor_version();
  inline ::std::string* release_minor_version();
  inline void set_allocated_minor_version(::std::string* minor_version);

  // required string build_number = 1;
  inline bool has_build_number() const;
  inline void clear_build_number();
  static const int kBuildNumberFieldNumber = 1;
  inline const ::std::string& build_number() const;
  inline void set_build_number(const ::std::string& value);
  inline void set_build_number(const char* value);
  inline void set_build_number(const char* value, size_t size);
  inline ::std::string* mutable_build_number();
  inline ::std::string* release_build_number();
  inline void set_allocated_build_number(::std::string* build_number);

  // @@protoc_insertion_point(class_scope:blox.connect.GetWorkSpaceVersionResponse)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_minor_version();
  inline void clear_has_minor_version();
  inline void set_has_build_number();
  inline void clear_has_build_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* version_;
  ::std::string* minor_version_;
  ::std::string* build_number_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static GetWorkSpaceVersionResponse* default_instance_;
};
// -------------------------------------------------------------------

class CancelRequests : public ::google::protobuf::Message {
 public:
  CancelRequests();
  virtual ~CancelRequests();

  CancelRequests(const CancelRequests& from);

  inline CancelRequests& operator=(const CancelRequests& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelRequests& default_instance();

  void Swap(CancelRequests* other);

  // implements Message ----------------------------------------------

  CancelRequests* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelRequests& from);
  void MergeFrom(const CancelRequests& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string req_guid = 1;
  inline int req_guid_size() const;
  inline void clear_req_guid();
  static const int kReqGuidFieldNumber = 1;
  inline const ::std::string& req_guid(int index) const;
  inline ::std::string* mutable_req_guid(int index);
  inline void set_req_guid(int index, const ::std::string& value);
  inline void set_req_guid(int index, const char* value);
  inline void set_req_guid(int index, const char* value, size_t size);
  inline ::std::string* add_req_guid();
  inline void add_req_guid(const ::std::string& value);
  inline void add_req_guid(const char* value);
  inline void add_req_guid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& req_guid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_req_guid();

  // @@protoc_insertion_point(class_scope:blox.connect.CancelRequests)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> req_guid_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CancelRequests* default_instance_;
};
// -------------------------------------------------------------------

class CancelRequestsResponse : public ::google::protobuf::Message {
 public:
  CancelRequestsResponse();
  virtual ~CancelRequestsResponse();

  CancelRequestsResponse(const CancelRequestsResponse& from);

  inline CancelRequestsResponse& operator=(const CancelRequestsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelRequestsResponse& default_instance();

  void Swap(CancelRequestsResponse* other);

  // implements Message ----------------------------------------------

  CancelRequestsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelRequestsResponse& from);
  void MergeFrom(const CancelRequestsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string unknown_guids = 4;
  inline int unknown_guids_size() const;
  inline void clear_unknown_guids();
  static const int kUnknownGuidsFieldNumber = 4;
  inline const ::std::string& unknown_guids(int index) const;
  inline ::std::string* mutable_unknown_guids(int index);
  inline void set_unknown_guids(int index, const ::std::string& value);
  inline void set_unknown_guids(int index, const char* value);
  inline void set_unknown_guids(int index, const char* value, size_t size);
  inline ::std::string* add_unknown_guids();
  inline void add_unknown_guids(const ::std::string& value);
  inline void add_unknown_guids(const char* value);
  inline void add_unknown_guids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unknown_guids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unknown_guids();

  // @@protoc_insertion_point(class_scope:blox.connect.CancelRequestsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unknown_guids_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CancelRequestsResponse* default_instance_;
};
// -------------------------------------------------------------------

class AdminRequest : public ::google::protobuf::Message {
 public:
  AdminRequest();
  virtual ~AdminRequest();

  AdminRequest(const AdminRequest& from);

  inline AdminRequest& operator=(const AdminRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminRequest& default_instance();

  void Swap(AdminRequest* other);

  // implements Message ----------------------------------------------

  AdminRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminRequest& from);
  void MergeFrom(const AdminRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const char* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // optional .blox.connect.ShutdownServer shutdown_server = 2;
  inline bool has_shutdown_server() const;
  inline void clear_shutdown_server();
  static const int kShutdownServerFieldNumber = 2;
  inline const ::blox::connect::ShutdownServer& shutdown_server() const;
  inline ::blox::connect::ShutdownServer* mutable_shutdown_server();
  inline ::blox::connect::ShutdownServer* release_shutdown_server();
  inline void set_allocated_shutdown_server(::blox::connect::ShutdownServer* shutdown_server);

  // optional .blox.connect.AbortTransaction abort_transaction = 4;
  inline bool has_abort_transaction() const;
  inline void clear_abort_transaction();
  static const int kAbortTransactionFieldNumber = 4;
  inline const ::blox::connect::AbortTransaction& abort_transaction() const;
  inline ::blox::connect::AbortTransaction* mutable_abort_transaction();
  inline ::blox::connect::AbortTransaction* release_abort_transaction();
  inline void set_allocated_abort_transaction(::blox::connect::AbortTransaction* abort_transaction);

  // optional bool list_workspaces = 6;
  inline bool has_list_workspaces() const;
  inline void clear_list_workspaces();
  static const int kListWorkspacesFieldNumber = 6;
  inline bool list_workspaces() const;
  inline void set_list_workspaces(bool value);

  // optional .blox.connect.StatusRequest status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline const ::blox::connect::StatusRequest& status() const;
  inline ::blox::connect::StatusRequest* mutable_status();
  inline ::blox::connect::StatusRequest* release_status();
  inline void set_allocated_status(::blox::connect::StatusRequest* status);

  // optional string command = 8;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 8;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // optional string loglevel = 9;
  inline bool has_loglevel() const;
  inline void clear_loglevel();
  static const int kLoglevelFieldNumber = 9;
  inline const ::std::string& loglevel() const;
  inline void set_loglevel(const ::std::string& value);
  inline void set_loglevel(const char* value);
  inline void set_loglevel(const char* value, size_t size);
  inline ::std::string* mutable_loglevel();
  inline ::std::string* release_loglevel();
  inline void set_allocated_loglevel(::std::string* loglevel);

  // @@protoc_insertion_point(class_scope:blox.connect.AdminRequest)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_shutdown_server();
  inline void clear_has_shutdown_server();
  inline void set_has_abort_transaction();
  inline void clear_has_abort_transaction();
  inline void set_has_list_workspaces();
  inline void clear_has_list_workspaces();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_loglevel();
  inline void clear_has_loglevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  ::blox::connect::ShutdownServer* shutdown_server_;
  ::blox::connect::AbortTransaction* abort_transaction_;
  ::blox::connect::StatusRequest* status_;
  ::std::string* command_;
  ::std::string* loglevel_;
  bool list_workspaces_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static AdminRequest* default_instance_;
};
// -------------------------------------------------------------------

class AdminResponse : public ::google::protobuf::Message {
 public:
  AdminResponse();
  virtual ~AdminResponse();

  AdminResponse(const AdminResponse& from);

  inline AdminResponse& operator=(const AdminResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminResponse& default_instance();

  void Swap(AdminResponse* other);

  // implements Message ----------------------------------------------

  AdminResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminResponse& from);
  void MergeFrom(const AdminResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const char* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // optional .blox.connect.ExceptionContainer exception = 2;
  inline bool has_exception() const;
  inline void clear_exception();
  static const int kExceptionFieldNumber = 2;
  inline const ::blox::connect::ExceptionContainer& exception() const;
  inline ::blox::connect::ExceptionContainer* mutable_exception();
  inline ::blox::connect::ExceptionContainer* release_exception();
  inline void set_allocated_exception(::blox::connect::ExceptionContainer* exception);

  // optional .blox.connect.ShutdownServerResponse shutdown_server = 3;
  inline bool has_shutdown_server() const;
  inline void clear_shutdown_server();
  static const int kShutdownServerFieldNumber = 3;
  inline const ::blox::connect::ShutdownServerResponse& shutdown_server() const;
  inline ::blox::connect::ShutdownServerResponse* mutable_shutdown_server();
  inline ::blox::connect::ShutdownServerResponse* release_shutdown_server();
  inline void set_allocated_shutdown_server(::blox::connect::ShutdownServerResponse* shutdown_server);

  // optional .blox.connect.AbortTransactionResponse abort_transaction = 5;
  inline bool has_abort_transaction() const;
  inline void clear_abort_transaction();
  static const int kAbortTransactionFieldNumber = 5;
  inline const ::blox::connect::AbortTransactionResponse& abort_transaction() const;
  inline ::blox::connect::AbortTransactionResponse* mutable_abort_transaction();
  inline ::blox::connect::AbortTransactionResponse* release_abort_transaction();
  inline void set_allocated_abort_transaction(::blox::connect::AbortTransactionResponse* abort_transaction);

  // optional .blox.connect.ListWorkSpacesResponse list_workspaces = 7;
  inline bool has_list_workspaces() const;
  inline void clear_list_workspaces();
  static const int kListWorkspacesFieldNumber = 7;
  inline const ::blox::connect::ListWorkSpacesResponse& list_workspaces() const;
  inline ::blox::connect::ListWorkSpacesResponse* mutable_list_workspaces();
  inline ::blox::connect::ListWorkSpacesResponse* release_list_workspaces();
  inline void set_allocated_list_workspaces(::blox::connect::ListWorkSpacesResponse* list_workspaces);

  // optional .blox.connect.StatusResponse status = 8;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 8;
  inline const ::blox::connect::StatusResponse& status() const;
  inline ::blox::connect::StatusResponse* mutable_status();
  inline ::blox::connect::StatusResponse* release_status();
  inline void set_allocated_status(::blox::connect::StatusResponse* status);

  // optional string message = 9;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 9;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:blox.connect.AdminResponse)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_exception();
  inline void clear_has_exception();
  inline void set_has_shutdown_server();
  inline void clear_has_shutdown_server();
  inline void set_has_abort_transaction();
  inline void clear_has_abort_transaction();
  inline void set_has_list_workspaces();
  inline void clear_has_list_workspaces();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  ::blox::connect::ExceptionContainer* exception_;
  ::blox::connect::ShutdownServerResponse* shutdown_server_;
  ::blox::connect::AbortTransactionResponse* abort_transaction_;
  ::blox::connect::ListWorkSpacesResponse* list_workspaces_;
  ::blox::connect::StatusResponse* status_;
  ::std::string* message_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static AdminResponse* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownServer : public ::google::protobuf::Message {
 public:
  ShutdownServer();
  virtual ~ShutdownServer();

  ShutdownServer(const ShutdownServer& from);

  inline ShutdownServer& operator=(const ShutdownServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownServer& default_instance();

  void Swap(ShutdownServer* other);

  // implements Message ----------------------------------------------

  ShutdownServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownServer& from);
  void MergeFrom(const ShutdownServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool waitForProcesses = 1;
  inline bool has_waitforprocesses() const;
  inline void clear_waitforprocesses();
  static const int kWaitForProcessesFieldNumber = 1;
  inline bool waitforprocesses() const;
  inline void set_waitforprocesses(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.ShutdownServer)
 private:
  inline void set_has_waitforprocesses();
  inline void clear_has_waitforprocesses();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool waitforprocesses_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ShutdownServer* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownServerResponse : public ::google::protobuf::Message {
 public:
  ShutdownServerResponse();
  virtual ~ShutdownServerResponse();

  ShutdownServerResponse(const ShutdownServerResponse& from);

  inline ShutdownServerResponse& operator=(const ShutdownServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownServerResponse& default_instance();

  void Swap(ShutdownServerResponse* other);

  // implements Message ----------------------------------------------

  ShutdownServerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutdownServerResponse& from);
  void MergeFrom(const ShutdownServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:blox.connect.ShutdownServerResponse)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ShutdownServerResponse* default_instance_;
};
// -------------------------------------------------------------------

class AbortTransaction : public ::google::protobuf::Message {
 public:
  AbortTransaction();
  virtual ~AbortTransaction();

  AbortTransaction(const AbortTransaction& from);

  inline AbortTransaction& operator=(const AbortTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AbortTransaction& default_instance();

  void Swap(AbortTransaction* other);

  // implements Message ----------------------------------------------

  AbortTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AbortTransaction& from);
  void MergeFrom(const AbortTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string workspace = 1;
  inline bool has_workspace() const;
  inline void clear_workspace();
  static const int kWorkspaceFieldNumber = 1;
  inline const ::std::string& workspace() const;
  inline void set_workspace(const ::std::string& value);
  inline void set_workspace(const char* value);
  inline void set_workspace(const char* value, size_t size);
  inline ::std::string* mutable_workspace();
  inline ::std::string* release_workspace();
  inline void set_allocated_workspace(::std::string* workspace);

  // required string tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline const ::std::string& tid() const;
  inline void set_tid(const ::std::string& value);
  inline void set_tid(const char* value);
  inline void set_tid(const char* value, size_t size);
  inline ::std::string* mutable_tid();
  inline ::std::string* release_tid();
  inline void set_allocated_tid(::std::string* tid);

  // @@protoc_insertion_point(class_scope:blox.connect.AbortTransaction)
 private:
  inline void set_has_workspace();
  inline void clear_has_workspace();
  inline void set_has_tid();
  inline void clear_has_tid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* workspace_;
  ::std::string* tid_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static AbortTransaction* default_instance_;
};
// -------------------------------------------------------------------

class AbortTransactionResponse : public ::google::protobuf::Message {
 public:
  AbortTransactionResponse();
  virtual ~AbortTransactionResponse();

  AbortTransactionResponse(const AbortTransactionResponse& from);

  inline AbortTransactionResponse& operator=(const AbortTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AbortTransactionResponse& default_instance();

  void Swap(AbortTransactionResponse* other);

  // implements Message ----------------------------------------------

  AbortTransactionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AbortTransactionResponse& from);
  void MergeFrom(const AbortTransactionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:blox.connect.AbortTransactionResponse)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static AbortTransactionResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListWorkSpaces : public ::google::protobuf::Message {
 public:
  ListWorkSpaces();
  virtual ~ListWorkSpaces();

  ListWorkSpaces(const ListWorkSpaces& from);

  inline ListWorkSpaces& operator=(const ListWorkSpaces& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListWorkSpaces& default_instance();

  void Swap(ListWorkSpaces* other);

  // implements Message ----------------------------------------------

  ListWorkSpaces* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListWorkSpaces& from);
  void MergeFrom(const ListWorkSpaces& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.ListWorkSpaces)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ListWorkSpaces* default_instance_;
};
// -------------------------------------------------------------------

class ListWorkSpacesResponse : public ::google::protobuf::Message {
 public:
  ListWorkSpacesResponse();
  virtual ~ListWorkSpacesResponse();

  ListWorkSpacesResponse(const ListWorkSpacesResponse& from);

  inline ListWorkSpacesResponse& operator=(const ListWorkSpacesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListWorkSpacesResponse& default_instance();

  void Swap(ListWorkSpacesResponse* other);

  // implements Message ----------------------------------------------

  ListWorkSpacesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListWorkSpacesResponse& from);
  void MergeFrom(const ListWorkSpacesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string name = 1;
  inline int name_size() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name(int index) const;
  inline ::std::string* mutable_name(int index);
  inline void set_name(int index, const ::std::string& value);
  inline void set_name(int index, const char* value);
  inline void set_name(int index, const char* value, size_t size);
  inline ::std::string* add_name();
  inline void add_name(const ::std::string& value);
  inline void add_name(const char* value);
  inline void add_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // @@protoc_insertion_point(class_scope:blox.connect.ListWorkSpacesResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ListWorkSpacesResponse* default_instance_;
};
// -------------------------------------------------------------------

class StatusRequest : public ::google::protobuf::Message {
 public:
  StatusRequest();
  virtual ~StatusRequest();

  StatusRequest(const StatusRequest& from);

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusRequest& default_instance();

  void Swap(StatusRequest* other);

  // implements Message ----------------------------------------------

  StatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusRequest& from);
  void MergeFrom(const StatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string workspaces = 1;
  inline int workspaces_size() const;
  inline void clear_workspaces();
  static const int kWorkspacesFieldNumber = 1;
  inline const ::std::string& workspaces(int index) const;
  inline ::std::string* mutable_workspaces(int index);
  inline void set_workspaces(int index, const ::std::string& value);
  inline void set_workspaces(int index, const char* value);
  inline void set_workspaces(int index, const char* value, size_t size);
  inline ::std::string* add_workspaces();
  inline void add_workspaces(const ::std::string& value);
  inline void add_workspaces(const char* value);
  inline void add_workspaces(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& workspaces() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_workspaces();

  // optional bool show_active_requests = 2 [default = false];
  inline bool has_show_active_requests() const;
  inline void clear_show_active_requests();
  static const int kShowActiveRequestsFieldNumber = 2;
  inline bool show_active_requests() const;
  inline void set_show_active_requests(bool value);

  // optional bool show_queued_requests = 3 [default = false];
  inline bool has_show_queued_requests() const;
  inline void clear_show_queued_requests();
  static const int kShowQueuedRequestsFieldNumber = 3;
  inline bool show_queued_requests() const;
  inline void set_show_queued_requests(bool value);

  // optional bool add_debug_info = 99 [default = false];
  inline bool has_add_debug_info() const;
  inline void clear_add_debug_info();
  static const int kAddDebugInfoFieldNumber = 99;
  inline bool add_debug_info() const;
  inline void set_add_debug_info(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.StatusRequest)
 private:
  inline void set_has_show_active_requests();
  inline void clear_has_show_active_requests();
  inline void set_has_show_queued_requests();
  inline void clear_has_show_queued_requests();
  inline void set_has_add_debug_info();
  inline void clear_has_add_debug_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> workspaces_;
  bool show_active_requests_;
  bool show_queued_requests_;
  bool add_debug_info_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static StatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();

  void Swap(StatusResponse* other);

  // implements Message ----------------------------------------------

  StatusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox.connect.WorkspaceStatus workspaces = 1;
  inline int workspaces_size() const;
  inline void clear_workspaces();
  static const int kWorkspacesFieldNumber = 1;
  inline const ::blox::connect::WorkspaceStatus& workspaces(int index) const;
  inline ::blox::connect::WorkspaceStatus* mutable_workspaces(int index);
  inline ::blox::connect::WorkspaceStatus* add_workspaces();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkspaceStatus >&
      workspaces() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkspaceStatus >*
      mutable_workspaces();

  // repeated string debug_info = 99;
  inline int debug_info_size() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 99;
  inline const ::std::string& debug_info(int index) const;
  inline ::std::string* mutable_debug_info(int index);
  inline void set_debug_info(int index, const ::std::string& value);
  inline void set_debug_info(int index, const char* value);
  inline void set_debug_info(int index, const char* value, size_t size);
  inline ::std::string* add_debug_info();
  inline void add_debug_info(const ::std::string& value);
  inline void add_debug_info(const char* value);
  inline void add_debug_info(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& debug_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_debug_info();

  // @@protoc_insertion_point(class_scope:blox.connect.StatusResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkspaceStatus > workspaces_;
  ::google::protobuf::RepeatedPtrField< ::std::string> debug_info_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static StatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class WorkspaceStatus : public ::google::protobuf::Message {
 public:
  WorkspaceStatus();
  virtual ~WorkspaceStatus();

  WorkspaceStatus(const WorkspaceStatus& from);

  inline WorkspaceStatus& operator=(const WorkspaceStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkspaceStatus& default_instance();

  void Swap(WorkspaceStatus* other);

  // implements Message ----------------------------------------------

  WorkspaceStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorkspaceStatus& from);
  void MergeFrom(const WorkspaceStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = ""];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 num_requests = 2;
  inline bool has_num_requests() const;
  inline void clear_num_requests();
  static const int kNumRequestsFieldNumber = 2;
  inline ::google::protobuf::int32 num_requests() const;
  inline void set_num_requests(::google::protobuf::int32 value);

  // repeated .blox.connect.RequestStatus requests = 3;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 3;
  inline const ::blox::connect::RequestStatus& requests(int index) const;
  inline ::blox::connect::RequestStatus* mutable_requests(int index);
  inline ::blox::connect::RequestStatus* add_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::RequestStatus >&
      requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::RequestStatus >*
      mutable_requests();

  // repeated string debug_info = 99;
  inline int debug_info_size() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 99;
  inline const ::std::string& debug_info(int index) const;
  inline ::std::string* mutable_debug_info(int index);
  inline void set_debug_info(int index, const ::std::string& value);
  inline void set_debug_info(int index, const char* value);
  inline void set_debug_info(int index, const char* value, size_t size);
  inline ::std::string* add_debug_info();
  inline void add_debug_info(const ::std::string& value);
  inline void add_debug_info(const char* value);
  inline void add_debug_info(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& debug_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_debug_info();

  // @@protoc_insertion_point(class_scope:blox.connect.WorkspaceStatus)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_num_requests();
  inline void clear_has_num_requests();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::RequestStatus > requests_;
  ::google::protobuf::RepeatedPtrField< ::std::string> debug_info_;
  ::google::protobuf::int32 num_requests_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static WorkspaceStatus* default_instance_;
};
// -------------------------------------------------------------------

class RequestStatus : public ::google::protobuf::Message {
 public:
  RequestStatus();
  virtual ~RequestStatus();

  RequestStatus(const RequestStatus& from);

  inline RequestStatus& operator=(const RequestStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestStatus& default_instance();

  void Swap(RequestStatus* other);

  // implements Message ----------------------------------------------

  RequestStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestStatus& from);
  void MergeFrom(const RequestStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .blox.connect.Request request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::blox::connect::Request& request() const;
  inline ::blox::connect::Request* mutable_request();
  inline ::blox::connect::Request* release_request();
  inline void set_allocated_request(::blox::connect::Request* request);

  // optional .blox.connect.RequestStatusEnum state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::blox::connect::RequestStatusEnum state() const;
  inline void set_state(::blox::connect::RequestStatusEnum value);

  // optional int64 request_id = 3;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 3;
  inline ::google::protobuf::int64 request_id() const;
  inline void set_request_id(::google::protobuf::int64 value);

  // repeated string debug_info = 99;
  inline int debug_info_size() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 99;
  inline const ::std::string& debug_info(int index) const;
  inline ::std::string* mutable_debug_info(int index);
  inline void set_debug_info(int index, const ::std::string& value);
  inline void set_debug_info(int index, const char* value);
  inline void set_debug_info(int index, const char* value, size_t size);
  inline ::std::string* add_debug_info();
  inline void add_debug_info(const ::std::string& value);
  inline void add_debug_info(const char* value);
  inline void add_debug_info(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& debug_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_debug_info();

  // @@protoc_insertion_point(class_scope:blox.connect.RequestStatus)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::Request* request_;
  ::google::protobuf::int64 request_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> debug_info_;
  int state_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static RequestStatus* default_instance_;
};
// -------------------------------------------------------------------

class AddReplicator : public ::google::protobuf::Message {
 public:
  AddReplicator();
  virtual ~AddReplicator();

  AddReplicator(const AddReplicator& from);

  inline AddReplicator& operator=(const AddReplicator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddReplicator& default_instance();

  void Swap(AddReplicator* other);

  // implements Message ----------------------------------------------

  AddReplicator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddReplicator& from);
  void MergeFrom(const AddReplicator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string workspace_name = 1;
  inline bool has_workspace_name() const;
  inline void clear_workspace_name();
  static const int kWorkspaceNameFieldNumber = 1;
  inline const ::std::string& workspace_name() const;
  inline void set_workspace_name(const ::std::string& value);
  inline void set_workspace_name(const char* value);
  inline void set_workspace_name(const char* value, size_t size);
  inline ::std::string* mutable_workspace_name();
  inline ::std::string* release_workspace_name();
  inline void set_allocated_workspace_name(::std::string* workspace_name);

  // required uint64 prev_version = 2;
  inline bool has_prev_version() const;
  inline void clear_prev_version();
  static const int kPrevVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 prev_version() const;
  inline void set_prev_version(::google::protobuf::uint64 value);

  // optional bool replicate_once = 3 [default = false];
  inline bool has_replicate_once() const;
  inline void clear_replicate_once();
  static const int kReplicateOnceFieldNumber = 3;
  inline bool replicate_once() const;
  inline void set_replicate_once(bool value);

  // required uint64 prev_version_timestamp = 4;
  inline bool has_prev_version_timestamp() const;
  inline void clear_prev_version_timestamp();
  static const int kPrevVersionTimestampFieldNumber = 4;
  inline ::google::protobuf::uint64 prev_version_timestamp() const;
  inline void set_prev_version_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:blox.connect.AddReplicator)
 private:
  inline void set_has_workspace_name();
  inline void clear_has_workspace_name();
  inline void set_has_prev_version();
  inline void clear_has_prev_version();
  inline void set_has_replicate_once();
  inline void clear_has_replicate_once();
  inline void set_has_prev_version_timestamp();
  inline void clear_has_prev_version_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* workspace_name_;
  ::google::protobuf::uint64 prev_version_;
  ::google::protobuf::uint64 prev_version_timestamp_;
  bool replicate_once_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static AddReplicator* default_instance_;
};
// -------------------------------------------------------------------

class AddReplicatorResponse : public ::google::protobuf::Message {
 public:
  AddReplicatorResponse();
  virtual ~AddReplicatorResponse();

  AddReplicatorResponse(const AddReplicatorResponse& from);

  inline AddReplicatorResponse& operator=(const AddReplicatorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddReplicatorResponse& default_instance();

  void Swap(AddReplicatorResponse* other);

  // implements Message ----------------------------------------------

  AddReplicatorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddReplicatorResponse& from);
  void MergeFrom(const AddReplicatorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // required string schema_version = 2;
  inline bool has_schema_version() const;
  inline void clear_schema_version();
  static const int kSchemaVersionFieldNumber = 2;
  inline const ::std::string& schema_version() const;
  inline void set_schema_version(const ::std::string& value);
  inline void set_schema_version(const char* value);
  inline void set_schema_version(const char* value, size_t size);
  inline ::std::string* mutable_schema_version();
  inline ::std::string* release_schema_version();
  inline void set_allocated_schema_version(::std::string* schema_version);

  // @@protoc_insertion_point(class_scope:blox.connect.AddReplicatorResponse)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_schema_version();
  inline void clear_has_schema_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* uuid_;
  ::std::string* schema_version_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static AddReplicatorResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetWorkspaceInfo : public ::google::protobuf::Message {
 public:
  GetWorkspaceInfo();
  virtual ~GetWorkspaceInfo();

  GetWorkspaceInfo(const GetWorkspaceInfo& from);

  inline GetWorkspaceInfo& operator=(const GetWorkspaceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWorkspaceInfo& default_instance();

  void Swap(GetWorkspaceInfo* other);

  // implements Message ----------------------------------------------

  GetWorkspaceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetWorkspaceInfo& from);
  void MergeFrom(const GetWorkspaceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:blox.connect.GetWorkspaceInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static GetWorkspaceInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetWorkspaceInfoResponse : public ::google::protobuf::Message {
 public:
  GetWorkspaceInfoResponse();
  virtual ~GetWorkspaceInfoResponse();

  GetWorkspaceInfoResponse(const GetWorkspaceInfoResponse& from);

  inline GetWorkspaceInfoResponse& operator=(const GetWorkspaceInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWorkspaceInfoResponse& default_instance();

  void Swap(GetWorkspaceInfoResponse* other);

  // implements Message ----------------------------------------------

  GetWorkspaceInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetWorkspaceInfoResponse& from);
  void MergeFrom(const GetWorkspaceInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetWorkspaceInfoResponse_State State;
  static const State CLOSED = GetWorkspaceInfoResponse_State_CLOSED;
  static const State OPENED = GetWorkspaceInfoResponse_State_OPENED;
  static const State INIT = GetWorkspaceInfoResponse_State_INIT;
  static inline bool State_IsValid(int value) {
    return GetWorkspaceInfoResponse_State_IsValid(value);
  }
  static const State State_MIN =
    GetWorkspaceInfoResponse_State_State_MIN;
  static const State State_MAX =
    GetWorkspaceInfoResponse_State_State_MAX;
  static const int State_ARRAYSIZE =
    GetWorkspaceInfoResponse_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return GetWorkspaceInfoResponse_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return GetWorkspaceInfoResponse_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return GetWorkspaceInfoResponse_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional uint64 commit_version = 2;
  inline bool has_commit_version() const;
  inline void clear_commit_version();
  static const int kCommitVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 commit_version() const;
  inline void set_commit_version(::google::protobuf::uint64 value);

  // repeated .blox.connect.WorkSpaceOption option = 3;
  inline int option_size() const;
  inline void clear_option();
  static const int kOptionFieldNumber = 3;
  inline const ::blox::connect::WorkSpaceOption& option(int index) const;
  inline ::blox::connect::WorkSpaceOption* mutable_option(int index);
  inline ::blox::connect::WorkSpaceOption* add_option();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkSpaceOption >&
      option() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkSpaceOption >*
      mutable_option();

  // required bool is_mirror = 4;
  inline bool has_is_mirror() const;
  inline void clear_is_mirror();
  static const int kIsMirrorFieldNumber = 4;
  inline bool is_mirror() const;
  inline void set_is_mirror(bool value);

  // optional bool is_mirroring = 5;
  inline bool has_is_mirroring() const;
  inline void clear_is_mirroring();
  static const int kIsMirroringFieldNumber = 5;
  inline bool is_mirroring() const;
  inline void set_is_mirroring(bool value);

  // optional uint64 mirroring_since = 6;
  inline bool has_mirroring_since() const;
  inline void clear_mirroring_since();
  static const int kMirroringSinceFieldNumber = 6;
  inline ::google::protobuf::uint64 mirroring_since() const;
  inline void set_mirroring_since(::google::protobuf::uint64 value);

  // optional uint64 pages_received = 7;
  inline bool has_pages_received() const;
  inline void clear_pages_received();
  static const int kPagesReceivedFieldNumber = 7;
  inline ::google::protobuf::uint64 pages_received() const;
  inline void set_pages_received(::google::protobuf::uint64 value);

  // optional uint64 versions_received = 8;
  inline bool has_versions_received() const;
  inline void clear_versions_received();
  static const int kVersionsReceivedFieldNumber = 8;
  inline ::google::protobuf::uint64 versions_received() const;
  inline void set_versions_received(::google::protobuf::uint64 value);

  // optional uint64 used_disk_space = 9;
  inline bool has_used_disk_space() const;
  inline void clear_used_disk_space();
  static const int kUsedDiskSpaceFieldNumber = 9;
  inline ::google::protobuf::uint64 used_disk_space() const;
  inline void set_used_disk_space(::google::protobuf::uint64 value);

  // optional uint64 active_mirror_count = 10;
  inline bool has_active_mirror_count() const;
  inline void clear_active_mirror_count();
  static const int kActiveMirrorCountFieldNumber = 10;
  inline ::google::protobuf::uint64 active_mirror_count() const;
  inline void set_active_mirror_count(::google::protobuf::uint64 value);

  // required string uuid = 11;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 11;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional string schema_version = 12;
  inline bool has_schema_version() const;
  inline void clear_schema_version();
  static const int kSchemaVersionFieldNumber = 12;
  inline const ::std::string& schema_version() const;
  inline void set_schema_version(const ::std::string& value);
  inline void set_schema_version(const char* value);
  inline void set_schema_version(const char* value, size_t size);
  inline ::std::string* mutable_schema_version();
  inline ::std::string* release_schema_version();
  inline void set_allocated_schema_version(::std::string* schema_version);

  // repeated string active_mirrors = 13;
  inline int active_mirrors_size() const;
  inline void clear_active_mirrors();
  static const int kActiveMirrorsFieldNumber = 13;
  inline const ::std::string& active_mirrors(int index) const;
  inline ::std::string* mutable_active_mirrors(int index);
  inline void set_active_mirrors(int index, const ::std::string& value);
  inline void set_active_mirrors(int index, const char* value);
  inline void set_active_mirrors(int index, const char* value, size_t size);
  inline ::std::string* add_active_mirrors();
  inline void add_active_mirrors(const ::std::string& value);
  inline void add_active_mirrors(const char* value);
  inline void add_active_mirrors(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& active_mirrors() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_active_mirrors();

  // optional uint64 pages_in_incoming_version = 14;
  inline bool has_pages_in_incoming_version() const;
  inline void clear_pages_in_incoming_version();
  static const int kPagesInIncomingVersionFieldNumber = 14;
  inline ::google::protobuf::uint64 pages_in_incoming_version() const;
  inline void set_pages_in_incoming_version(::google::protobuf::uint64 value);

  // optional uint64 pages_received_in_incoming_version = 15;
  inline bool has_pages_received_in_incoming_version() const;
  inline void clear_pages_received_in_incoming_version();
  static const int kPagesReceivedInIncomingVersionFieldNumber = 15;
  inline ::google::protobuf::uint64 pages_received_in_incoming_version() const;
  inline void set_pages_received_in_incoming_version(::google::protobuf::uint64 value);

  // required .blox.connect.GetWorkspaceInfoResponse.State state = 16;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 16;
  inline ::blox::connect::GetWorkspaceInfoResponse_State state() const;
  inline void set_state(::blox::connect::GetWorkspaceInfoResponse_State value);

  // optional uint64 commit_timestamp = 17;
  inline bool has_commit_timestamp() const;
  inline void clear_commit_timestamp();
  static const int kCommitTimestampFieldNumber = 17;
  inline ::google::protobuf::uint64 commit_timestamp() const;
  inline void set_commit_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:blox.connect.GetWorkspaceInfoResponse)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_commit_version();
  inline void clear_has_commit_version();
  inline void set_has_is_mirror();
  inline void clear_has_is_mirror();
  inline void set_has_is_mirroring();
  inline void clear_has_is_mirroring();
  inline void set_has_mirroring_since();
  inline void clear_has_mirroring_since();
  inline void set_has_pages_received();
  inline void clear_has_pages_received();
  inline void set_has_versions_received();
  inline void clear_has_versions_received();
  inline void set_has_used_disk_space();
  inline void clear_has_used_disk_space();
  inline void set_has_active_mirror_count();
  inline void clear_has_active_mirror_count();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_schema_version();
  inline void clear_has_schema_version();
  inline void set_has_pages_in_incoming_version();
  inline void clear_has_pages_in_incoming_version();
  inline void set_has_pages_received_in_incoming_version();
  inline void clear_has_pages_received_in_incoming_version();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_commit_timestamp();
  inline void clear_has_commit_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::google::protobuf::uint64 commit_version_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkSpaceOption > option_;
  ::google::protobuf::uint64 mirroring_since_;
  ::google::protobuf::uint64 pages_received_;
  ::google::protobuf::uint64 versions_received_;
  bool is_mirror_;
  bool is_mirroring_;
  int state_;
  ::google::protobuf::uint64 used_disk_space_;
  ::google::protobuf::uint64 active_mirror_count_;
  ::std::string* uuid_;
  ::std::string* schema_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> active_mirrors_;
  ::google::protobuf::uint64 pages_in_incoming_version_;
  ::google::protobuf::uint64 pages_received_in_incoming_version_;
  ::google::protobuf::uint64 commit_timestamp_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static GetWorkspaceInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class WorkSpaceOption : public ::google::protobuf::Message {
 public:
  WorkSpaceOption();
  virtual ~WorkSpaceOption();

  WorkSpaceOption(const WorkSpaceOption& from);

  inline WorkSpaceOption& operator=(const WorkSpaceOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkSpaceOption& default_instance();

  void Swap(WorkSpaceOption* other);

  // implements Message ----------------------------------------------

  WorkSpaceOption* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorkSpaceOption& from);
  void MergeFrom(const WorkSpaceOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:blox.connect.WorkSpaceOption)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static WorkSpaceOption* default_instance_;
};
// -------------------------------------------------------------------

class StartMirror : public ::google::protobuf::Message {
 public:
  StartMirror();
  virtual ~StartMirror();

  StartMirror(const StartMirror& from);

  inline StartMirror& operator=(const StartMirror& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartMirror& default_instance();

  void Swap(StartMirror* other);

  // implements Message ----------------------------------------------

  StartMirror* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartMirror& from);
  void MergeFrom(const StartMirror& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string remote_host = 2;
  inline bool has_remote_host() const;
  inline void clear_remote_host();
  static const int kRemoteHostFieldNumber = 2;
  inline const ::std::string& remote_host() const;
  inline void set_remote_host(const ::std::string& value);
  inline void set_remote_host(const char* value);
  inline void set_remote_host(const char* value, size_t size);
  inline ::std::string* mutable_remote_host();
  inline ::std::string* release_remote_host();
  inline void set_allocated_remote_host(::std::string* remote_host);

  // required uint32 remote_port = 3;
  inline bool has_remote_port() const;
  inline void clear_remote_port();
  static const int kRemotePortFieldNumber = 3;
  inline ::google::protobuf::uint32 remote_port() const;
  inline void set_remote_port(::google::protobuf::uint32 value);

  // required string remote_workspace = 4;
  inline bool has_remote_workspace() const;
  inline void clear_remote_workspace();
  static const int kRemoteWorkspaceFieldNumber = 4;
  inline const ::std::string& remote_workspace() const;
  inline void set_remote_workspace(const ::std::string& value);
  inline void set_remote_workspace(const char* value);
  inline void set_remote_workspace(const char* value, size_t size);
  inline ::std::string* mutable_remote_workspace();
  inline ::std::string* release_remote_workspace();
  inline void set_allocated_remote_workspace(::std::string* remote_workspace);

  // @@protoc_insertion_point(class_scope:blox.connect.StartMirror)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_remote_host();
  inline void clear_has_remote_host();
  inline void set_has_remote_port();
  inline void clear_has_remote_port();
  inline void set_has_remote_workspace();
  inline void clear_has_remote_workspace();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* remote_host_;
  ::std::string* remote_workspace_;
  ::google::protobuf::uint32 remote_port_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static StartMirror* default_instance_;
};
// -------------------------------------------------------------------

class StartMirrorResponse : public ::google::protobuf::Message {
 public:
  StartMirrorResponse();
  virtual ~StartMirrorResponse();

  StartMirrorResponse(const StartMirrorResponse& from);

  inline StartMirrorResponse& operator=(const StartMirrorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartMirrorResponse& default_instance();

  void Swap(StartMirrorResponse* other);

  // implements Message ----------------------------------------------

  StartMirrorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartMirrorResponse& from);
  void MergeFrom(const StartMirrorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.StartMirrorResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static StartMirrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class StopMirror : public ::google::protobuf::Message {
 public:
  StopMirror();
  virtual ~StopMirror();

  StopMirror(const StopMirror& from);

  inline StopMirror& operator=(const StopMirror& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopMirror& default_instance();

  void Swap(StopMirror* other);

  // implements Message ----------------------------------------------

  StopMirror* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopMirror& from);
  void MergeFrom(const StopMirror& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:blox.connect.StopMirror)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static StopMirror* default_instance_;
};
// -------------------------------------------------------------------

class StopMirrorResponse : public ::google::protobuf::Message {
 public:
  StopMirrorResponse();
  virtual ~StopMirrorResponse();

  StopMirrorResponse(const StopMirrorResponse& from);

  inline StopMirrorResponse& operator=(const StopMirrorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopMirrorResponse& default_instance();

  void Swap(StopMirrorResponse* other);

  // implements Message ----------------------------------------------

  StopMirrorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopMirrorResponse& from);
  void MergeFrom(const StopMirrorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.StopMirrorResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static StopMirrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class PromoteMirror : public ::google::protobuf::Message {
 public:
  PromoteMirror();
  virtual ~PromoteMirror();

  PromoteMirror(const PromoteMirror& from);

  inline PromoteMirror& operator=(const PromoteMirror& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PromoteMirror& default_instance();

  void Swap(PromoteMirror* other);

  // implements Message ----------------------------------------------

  PromoteMirror* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PromoteMirror& from);
  void MergeFrom(const PromoteMirror& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:blox.connect.PromoteMirror)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static PromoteMirror* default_instance_;
};
// -------------------------------------------------------------------

class PromoteMirrorResponse : public ::google::protobuf::Message {
 public:
  PromoteMirrorResponse();
  virtual ~PromoteMirrorResponse();

  PromoteMirrorResponse(const PromoteMirrorResponse& from);

  inline PromoteMirrorResponse& operator=(const PromoteMirrorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PromoteMirrorResponse& default_instance();

  void Swap(PromoteMirrorResponse* other);

  // implements Message ----------------------------------------------

  PromoteMirrorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PromoteMirrorResponse& from);
  void MergeFrom(const PromoteMirrorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.PromoteMirrorResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static PromoteMirrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class CopyRemoteWorkSpace : public ::google::protobuf::Message {
 public:
  CopyRemoteWorkSpace();
  virtual ~CopyRemoteWorkSpace();

  CopyRemoteWorkSpace(const CopyRemoteWorkSpace& from);

  inline CopyRemoteWorkSpace& operator=(const CopyRemoteWorkSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CopyRemoteWorkSpace& default_instance();

  void Swap(CopyRemoteWorkSpace* other);

  // implements Message ----------------------------------------------

  CopyRemoteWorkSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CopyRemoteWorkSpace& from);
  void MergeFrom(const CopyRemoteWorkSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string remote_host = 2;
  inline bool has_remote_host() const;
  inline void clear_remote_host();
  static const int kRemoteHostFieldNumber = 2;
  inline const ::std::string& remote_host() const;
  inline void set_remote_host(const ::std::string& value);
  inline void set_remote_host(const char* value);
  inline void set_remote_host(const char* value, size_t size);
  inline ::std::string* mutable_remote_host();
  inline ::std::string* release_remote_host();
  inline void set_allocated_remote_host(::std::string* remote_host);

  // required uint32 remote_port = 3;
  inline bool has_remote_port() const;
  inline void clear_remote_port();
  static const int kRemotePortFieldNumber = 3;
  inline ::google::protobuf::uint32 remote_port() const;
  inline void set_remote_port(::google::protobuf::uint32 value);

  // required string remote_workspace = 4;
  inline bool has_remote_workspace() const;
  inline void clear_remote_workspace();
  static const int kRemoteWorkspaceFieldNumber = 4;
  inline const ::std::string& remote_workspace() const;
  inline void set_remote_workspace(const ::std::string& value);
  inline void set_remote_workspace(const char* value);
  inline void set_remote_workspace(const char* value, size_t size);
  inline ::std::string* mutable_remote_workspace();
  inline ::std::string* release_remote_workspace();
  inline void set_allocated_remote_workspace(::std::string* remote_workspace);

  // @@protoc_insertion_point(class_scope:blox.connect.CopyRemoteWorkSpace)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_remote_host();
  inline void clear_has_remote_host();
  inline void set_has_remote_port();
  inline void clear_has_remote_port();
  inline void set_has_remote_workspace();
  inline void clear_has_remote_workspace();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* remote_host_;
  ::std::string* remote_workspace_;
  ::google::protobuf::uint32 remote_port_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CopyRemoteWorkSpace* default_instance_;
};
// -------------------------------------------------------------------

class CopyRemoteWorkSpaceResponse : public ::google::protobuf::Message {
 public:
  CopyRemoteWorkSpaceResponse();
  virtual ~CopyRemoteWorkSpaceResponse();

  CopyRemoteWorkSpaceResponse(const CopyRemoteWorkSpaceResponse& from);

  inline CopyRemoteWorkSpaceResponse& operator=(const CopyRemoteWorkSpaceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CopyRemoteWorkSpaceResponse& default_instance();

  void Swap(CopyRemoteWorkSpaceResponse* other);

  // implements Message ----------------------------------------------

  CopyRemoteWorkSpaceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CopyRemoteWorkSpaceResponse& from);
  void MergeFrom(const CopyRemoteWorkSpaceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.CopyRemoteWorkSpaceResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static CopyRemoteWorkSpaceResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteBatchScript : public ::google::protobuf::Message {
 public:
  ExecuteBatchScript();
  virtual ~ExecuteBatchScript();

  ExecuteBatchScript(const ExecuteBatchScript& from);

  inline ExecuteBatchScript& operator=(const ExecuteBatchScript& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteBatchScript& default_instance();

  void Swap(ExecuteBatchScript* other);

  // implements Message ----------------------------------------------

  ExecuteBatchScript* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecuteBatchScript& from);
  void MergeFrom(const ExecuteBatchScript& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string script = 1;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 1;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  inline void set_allocated_script(::std::string* script);

  // required string workspace = 2;
  inline bool has_workspace() const;
  inline void clear_workspace();
  static const int kWorkspaceFieldNumber = 2;
  inline const ::std::string& workspace() const;
  inline void set_workspace(const ::std::string& value);
  inline void set_workspace(const char* value);
  inline void set_workspace(const char* value, size_t size);
  inline ::std::string* mutable_workspace();
  inline ::std::string* release_workspace();
  inline void set_allocated_workspace(::std::string* workspace);

  // required bool transactional = 3;
  inline bool has_transactional() const;
  inline void clear_transactional();
  static const int kTransactionalFieldNumber = 3;
  inline bool transactional() const;
  inline void set_transactional(bool value);

  // optional bool return_data = 4;
  inline bool has_return_data() const;
  inline void clear_return_data();
  static const int kReturnDataFieldNumber = 4;
  inline bool return_data() const;
  inline void set_return_data(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.ExecuteBatchScript)
 private:
  inline void set_has_script();
  inline void clear_has_script();
  inline void set_has_workspace();
  inline void clear_has_workspace();
  inline void set_has_transactional();
  inline void clear_has_transactional();
  inline void set_has_return_data();
  inline void clear_has_return_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* script_;
  ::std::string* workspace_;
  bool transactional_;
  bool return_data_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ExecuteBatchScript* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteBatchScriptResponse : public ::google::protobuf::Message {
 public:
  ExecuteBatchScriptResponse();
  virtual ~ExecuteBatchScriptResponse();

  ExecuteBatchScriptResponse(const ExecuteBatchScriptResponse& from);

  inline ExecuteBatchScriptResponse& operator=(const ExecuteBatchScriptResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteBatchScriptResponse& default_instance();

  void Swap(ExecuteBatchScriptResponse* other);

  // implements Message ----------------------------------------------

  ExecuteBatchScriptResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecuteBatchScriptResponse& from);
  void MergeFrom(const ExecuteBatchScriptResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string output = 1;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 1;
  inline const ::std::string& output() const;
  inline void set_output(const ::std::string& value);
  inline void set_output(const char* value);
  inline void set_output(const char* value, size_t size);
  inline ::std::string* mutable_output();
  inline ::std::string* release_output();
  inline void set_allocated_output(::std::string* output);

  // repeated .blox.connect.Relation returned_data = 2;
  inline int returned_data_size() const;
  inline void clear_returned_data();
  static const int kReturnedDataFieldNumber = 2;
  inline const ::blox::connect::Relation& returned_data(int index) const;
  inline ::blox::connect::Relation* mutable_returned_data(int index);
  inline ::blox::connect::Relation* add_returned_data();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >&
      returned_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >*
      mutable_returned_data();

  // @@protoc_insertion_point(class_scope:blox.connect.ExecuteBatchScriptResponse)
 private:
  inline void set_has_output();
  inline void clear_has_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* output_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation > returned_data_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fConnectBlox_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fConnectBlox_2eproto();

  void InitAsDefaultInstance();
  static ExecuteBatchScriptResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Request

// optional string client_id = 1;
inline bool Request::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& Request::client_id() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.client_id)
  return *client_id_;
}
inline void Request::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Request.client_id)
}
inline void Request::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Request.client_id)
}
inline void Request::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Request.client_id)
}
inline ::std::string* Request::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.client_id)
  return client_id_;
}
inline ::std::string* Request::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.client_id)
}

// optional string log_level = 2;
inline bool Request::has_log_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_log_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_log_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_log_level() {
  if (log_level_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_level_->clear();
  }
  clear_has_log_level();
}
inline const ::std::string& Request::log_level() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.log_level)
  return *log_level_;
}
inline void Request::set_log_level(const ::std::string& value) {
  set_has_log_level();
  if (log_level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_level_ = new ::std::string;
  }
  log_level_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Request.log_level)
}
inline void Request::set_log_level(const char* value) {
  set_has_log_level();
  if (log_level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_level_ = new ::std::string;
  }
  log_level_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Request.log_level)
}
inline void Request::set_log_level(const char* value, size_t size) {
  set_has_log_level();
  if (log_level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_level_ = new ::std::string;
  }
  log_level_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Request.log_level)
}
inline ::std::string* Request::mutable_log_level() {
  set_has_log_level();
  if (log_level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    log_level_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.log_level)
  return log_level_;
}
inline ::std::string* Request::release_log_level() {
  clear_has_log_level();
  if (log_level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = log_level_;
    log_level_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_log_level(::std::string* log_level) {
  if (log_level_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete log_level_;
  }
  if (log_level) {
    set_has_log_level();
    log_level_ = log_level;
  } else {
    clear_has_log_level();
    log_level_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.log_level)
}

// optional bool return_log = 3 [default = false];
inline bool Request::has_return_log() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_return_log() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_return_log() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_return_log() {
  return_log_ = false;
  clear_has_return_log();
}
inline bool Request::return_log() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.return_log)
  return return_log_;
}
inline void Request::set_return_log(bool value) {
  set_has_return_log();
  return_log_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.Request.return_log)
}

// optional .blox.connect.Priority priority = 4;
inline bool Request::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_priority() {
  priority_ = 1;
  clear_has_priority();
}
inline ::blox::connect::Priority Request::priority() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.priority)
  return static_cast< ::blox::connect::Priority >(priority_);
}
inline void Request::set_priority(::blox::connect::Priority value) {
  assert(::blox::connect::Priority_IsValid(value));
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.Request.priority)
}

// optional .blox.connect.Transaction transaction = 5;
inline bool Request::has_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_transaction() {
  if (transaction_ != NULL) transaction_->::blox::connect::Transaction::Clear();
  clear_has_transaction();
}
inline const ::blox::connect::Transaction& Request::transaction() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.transaction)
  return transaction_ != NULL ? *transaction_ : *default_instance_->transaction_;
}
inline ::blox::connect::Transaction* Request::mutable_transaction() {
  set_has_transaction();
  if (transaction_ == NULL) transaction_ = new ::blox::connect::Transaction;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.transaction)
  return transaction_;
}
inline ::blox::connect::Transaction* Request::release_transaction() {
  clear_has_transaction();
  ::blox::connect::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void Request::set_allocated_transaction(::blox::connect::Transaction* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    set_has_transaction();
  } else {
    clear_has_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.transaction)
}

// optional .blox.connect.CreateWorkSpace create = 6;
inline bool Request::has_create() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_create() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_create() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_create() {
  if (create_ != NULL) create_->::blox::connect::CreateWorkSpace::Clear();
  clear_has_create();
}
inline const ::blox::connect::CreateWorkSpace& Request::create() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.create)
  return create_ != NULL ? *create_ : *default_instance_->create_;
}
inline ::blox::connect::CreateWorkSpace* Request::mutable_create() {
  set_has_create();
  if (create_ == NULL) create_ = new ::blox::connect::CreateWorkSpace;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.create)
  return create_;
}
inline ::blox::connect::CreateWorkSpace* Request::release_create() {
  clear_has_create();
  ::blox::connect::CreateWorkSpace* temp = create_;
  create_ = NULL;
  return temp;
}
inline void Request::set_allocated_create(::blox::connect::CreateWorkSpace* create) {
  delete create_;
  create_ = create;
  if (create) {
    set_has_create();
  } else {
    clear_has_create();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.create)
}

// optional .blox.connect.CopyWorkSpace copy = 7;
inline bool Request::has_copy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_copy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_copy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_copy() {
  if (copy_ != NULL) copy_->::blox::connect::CopyWorkSpace::Clear();
  clear_has_copy();
}
inline const ::blox::connect::CopyWorkSpace& Request::copy() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.copy)
  return copy_ != NULL ? *copy_ : *default_instance_->copy_;
}
inline ::blox::connect::CopyWorkSpace* Request::mutable_copy() {
  set_has_copy();
  if (copy_ == NULL) copy_ = new ::blox::connect::CopyWorkSpace;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.copy)
  return copy_;
}
inline ::blox::connect::CopyWorkSpace* Request::release_copy() {
  clear_has_copy();
  ::blox::connect::CopyWorkSpace* temp = copy_;
  copy_ = NULL;
  return temp;
}
inline void Request::set_allocated_copy(::blox::connect::CopyWorkSpace* copy) {
  delete copy_;
  copy_ = copy;
  if (copy) {
    set_has_copy();
  } else {
    clear_has_copy();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.copy)
}

// optional .blox.connect.DeleteWorkSpace delete = 8;
inline bool Request::has_delete_() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_delete_() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_delete_() {
  if (delete__ != NULL) delete__->::blox::connect::DeleteWorkSpace::Clear();
  clear_has_delete_();
}
inline const ::blox::connect::DeleteWorkSpace& Request::delete_() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::blox::connect::DeleteWorkSpace* Request::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) delete__ = new ::blox::connect::DeleteWorkSpace;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.delete)
  return delete__;
}
inline ::blox::connect::DeleteWorkSpace* Request::release_delete_() {
  clear_has_delete_();
  ::blox::connect::DeleteWorkSpace* temp = delete__;
  delete__ = NULL;
  return temp;
}
inline void Request::set_allocated_delete_(::blox::connect::DeleteWorkSpace* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.delete)
}

// optional .blox.connect.ImportWorkSpace importws = 9;
inline bool Request::has_importws() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_importws() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_importws() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_importws() {
  if (importws_ != NULL) importws_->::blox::connect::ImportWorkSpace::Clear();
  clear_has_importws();
}
inline const ::blox::connect::ImportWorkSpace& Request::importws() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.importws)
  return importws_ != NULL ? *importws_ : *default_instance_->importws_;
}
inline ::blox::connect::ImportWorkSpace* Request::mutable_importws() {
  set_has_importws();
  if (importws_ == NULL) importws_ = new ::blox::connect::ImportWorkSpace;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.importws)
  return importws_;
}
inline ::blox::connect::ImportWorkSpace* Request::release_importws() {
  clear_has_importws();
  ::blox::connect::ImportWorkSpace* temp = importws_;
  importws_ = NULL;
  return temp;
}
inline void Request::set_allocated_importws(::blox::connect::ImportWorkSpace* importws) {
  delete importws_;
  importws_ = importws;
  if (importws) {
    set_has_importws();
  } else {
    clear_has_importws();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.importws)
}

// optional .blox.connect.ExportWorkSpace exportws = 10;
inline bool Request::has_exportws() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_exportws() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_exportws() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_exportws() {
  if (exportws_ != NULL) exportws_->::blox::connect::ExportWorkSpace::Clear();
  clear_has_exportws();
}
inline const ::blox::connect::ExportWorkSpace& Request::exportws() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.exportws)
  return exportws_ != NULL ? *exportws_ : *default_instance_->exportws_;
}
inline ::blox::connect::ExportWorkSpace* Request::mutable_exportws() {
  set_has_exportws();
  if (exportws_ == NULL) exportws_ = new ::blox::connect::ExportWorkSpace;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.exportws)
  return exportws_;
}
inline ::blox::connect::ExportWorkSpace* Request::release_exportws() {
  clear_has_exportws();
  ::blox::connect::ExportWorkSpace* temp = exportws_;
  exportws_ = NULL;
  return temp;
}
inline void Request::set_allocated_exportws(::blox::connect::ExportWorkSpace* exportws) {
  delete exportws_;
  exportws_ = exportws;
  if (exportws) {
    set_has_exportws();
  } else {
    clear_has_exportws();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.exportws)
}

// optional .blox.connect.GetWorkSpacePath get_ws_path = 11;
inline bool Request::has_get_ws_path() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Request::set_has_get_ws_path() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Request::clear_has_get_ws_path() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Request::clear_get_ws_path() {
  if (get_ws_path_ != NULL) get_ws_path_->::blox::connect::GetWorkSpacePath::Clear();
  clear_has_get_ws_path();
}
inline const ::blox::connect::GetWorkSpacePath& Request::get_ws_path() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.get_ws_path)
  return get_ws_path_ != NULL ? *get_ws_path_ : *default_instance_->get_ws_path_;
}
inline ::blox::connect::GetWorkSpacePath* Request::mutable_get_ws_path() {
  set_has_get_ws_path();
  if (get_ws_path_ == NULL) get_ws_path_ = new ::blox::connect::GetWorkSpacePath;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.get_ws_path)
  return get_ws_path_;
}
inline ::blox::connect::GetWorkSpacePath* Request::release_get_ws_path() {
  clear_has_get_ws_path();
  ::blox::connect::GetWorkSpacePath* temp = get_ws_path_;
  get_ws_path_ = NULL;
  return temp;
}
inline void Request::set_allocated_get_ws_path(::blox::connect::GetWorkSpacePath* get_ws_path) {
  delete get_ws_path_;
  get_ws_path_ = get_ws_path;
  if (get_ws_path) {
    set_has_get_ws_path();
  } else {
    clear_has_get_ws_path();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.get_ws_path)
}

// optional string current_working_directory = 12;
inline bool Request::has_current_working_directory() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Request::set_has_current_working_directory() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Request::clear_has_current_working_directory() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Request::clear_current_working_directory() {
  if (current_working_directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_working_directory_->clear();
  }
  clear_has_current_working_directory();
}
inline const ::std::string& Request::current_working_directory() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.current_working_directory)
  return *current_working_directory_;
}
inline void Request::set_current_working_directory(const ::std::string& value) {
  set_has_current_working_directory();
  if (current_working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_working_directory_ = new ::std::string;
  }
  current_working_directory_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Request.current_working_directory)
}
inline void Request::set_current_working_directory(const char* value) {
  set_has_current_working_directory();
  if (current_working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_working_directory_ = new ::std::string;
  }
  current_working_directory_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Request.current_working_directory)
}
inline void Request::set_current_working_directory(const char* value, size_t size) {
  set_has_current_working_directory();
  if (current_working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_working_directory_ = new ::std::string;
  }
  current_working_directory_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Request.current_working_directory)
}
inline ::std::string* Request::mutable_current_working_directory() {
  set_has_current_working_directory();
  if (current_working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_working_directory_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.current_working_directory)
  return current_working_directory_;
}
inline ::std::string* Request::release_current_working_directory() {
  clear_has_current_working_directory();
  if (current_working_directory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = current_working_directory_;
    current_working_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_current_working_directory(::std::string* current_working_directory) {
  if (current_working_directory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete current_working_directory_;
  }
  if (current_working_directory) {
    set_has_current_working_directory();
    current_working_directory_ = current_working_directory;
  } else {
    clear_has_current_working_directory();
    current_working_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.current_working_directory)
}

// optional .blox.connect.GetWorkSpaceVersion get_ws_version = 13;
inline bool Request::has_get_ws_version() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Request::set_has_get_ws_version() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Request::clear_has_get_ws_version() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Request::clear_get_ws_version() {
  if (get_ws_version_ != NULL) get_ws_version_->::blox::connect::GetWorkSpaceVersion::Clear();
  clear_has_get_ws_version();
}
inline const ::blox::connect::GetWorkSpaceVersion& Request::get_ws_version() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.get_ws_version)
  return get_ws_version_ != NULL ? *get_ws_version_ : *default_instance_->get_ws_version_;
}
inline ::blox::connect::GetWorkSpaceVersion* Request::mutable_get_ws_version() {
  set_has_get_ws_version();
  if (get_ws_version_ == NULL) get_ws_version_ = new ::blox::connect::GetWorkSpaceVersion;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.get_ws_version)
  return get_ws_version_;
}
inline ::blox::connect::GetWorkSpaceVersion* Request::release_get_ws_version() {
  clear_has_get_ws_version();
  ::blox::connect::GetWorkSpaceVersion* temp = get_ws_version_;
  get_ws_version_ = NULL;
  return temp;
}
inline void Request::set_allocated_get_ws_version(::blox::connect::GetWorkSpaceVersion* get_ws_version) {
  delete get_ws_version_;
  get_ws_version_ = get_ws_version;
  if (get_ws_version) {
    set_has_get_ws_version();
  } else {
    clear_has_get_ws_version();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.get_ws_version)
}

// optional string guid = 14;
inline bool Request::has_guid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Request::set_has_guid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Request::clear_has_guid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Request::clear_guid() {
  if (guid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& Request::guid() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.guid)
  return *guid_;
}
inline void Request::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Request.guid)
}
inline void Request::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Request.guid)
}
inline void Request::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Request.guid)
}
inline ::std::string* Request::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.guid)
  return guid_;
}
inline ::std::string* Request::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.guid)
}

// optional .blox.connect.CancelRequests cancel_requests = 15;
inline bool Request::has_cancel_requests() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Request::set_has_cancel_requests() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Request::clear_has_cancel_requests() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Request::clear_cancel_requests() {
  if (cancel_requests_ != NULL) cancel_requests_->::blox::connect::CancelRequests::Clear();
  clear_has_cancel_requests();
}
inline const ::blox::connect::CancelRequests& Request::cancel_requests() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.cancel_requests)
  return cancel_requests_ != NULL ? *cancel_requests_ : *default_instance_->cancel_requests_;
}
inline ::blox::connect::CancelRequests* Request::mutable_cancel_requests() {
  set_has_cancel_requests();
  if (cancel_requests_ == NULL) cancel_requests_ = new ::blox::connect::CancelRequests;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.cancel_requests)
  return cancel_requests_;
}
inline ::blox::connect::CancelRequests* Request::release_cancel_requests() {
  clear_has_cancel_requests();
  ::blox::connect::CancelRequests* temp = cancel_requests_;
  cancel_requests_ = NULL;
  return temp;
}
inline void Request::set_allocated_cancel_requests(::blox::connect::CancelRequests* cancel_requests) {
  delete cancel_requests_;
  cancel_requests_ = cancel_requests;
  if (cancel_requests) {
    set_has_cancel_requests();
  } else {
    clear_has_cancel_requests();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.cancel_requests)
}

// optional .blox.connect.AddReplicator add_replicator = 16;
inline bool Request::has_add_replicator() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Request::set_has_add_replicator() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Request::clear_has_add_replicator() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Request::clear_add_replicator() {
  if (add_replicator_ != NULL) add_replicator_->::blox::connect::AddReplicator::Clear();
  clear_has_add_replicator();
}
inline const ::blox::connect::AddReplicator& Request::add_replicator() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.add_replicator)
  return add_replicator_ != NULL ? *add_replicator_ : *default_instance_->add_replicator_;
}
inline ::blox::connect::AddReplicator* Request::mutable_add_replicator() {
  set_has_add_replicator();
  if (add_replicator_ == NULL) add_replicator_ = new ::blox::connect::AddReplicator;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.add_replicator)
  return add_replicator_;
}
inline ::blox::connect::AddReplicator* Request::release_add_replicator() {
  clear_has_add_replicator();
  ::blox::connect::AddReplicator* temp = add_replicator_;
  add_replicator_ = NULL;
  return temp;
}
inline void Request::set_allocated_add_replicator(::blox::connect::AddReplicator* add_replicator) {
  delete add_replicator_;
  add_replicator_ = add_replicator;
  if (add_replicator) {
    set_has_add_replicator();
  } else {
    clear_has_add_replicator();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.add_replicator)
}

// optional string authenticator = 17;
inline bool Request::has_authenticator() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Request::set_has_authenticator() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Request::clear_has_authenticator() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Request::clear_authenticator() {
  if (authenticator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authenticator_->clear();
  }
  clear_has_authenticator();
}
inline const ::std::string& Request::authenticator() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.authenticator)
  return *authenticator_;
}
inline void Request::set_authenticator(const ::std::string& value) {
  set_has_authenticator();
  if (authenticator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authenticator_ = new ::std::string;
  }
  authenticator_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Request.authenticator)
}
inline void Request::set_authenticator(const char* value) {
  set_has_authenticator();
  if (authenticator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authenticator_ = new ::std::string;
  }
  authenticator_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Request.authenticator)
}
inline void Request::set_authenticator(const char* value, size_t size) {
  set_has_authenticator();
  if (authenticator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authenticator_ = new ::std::string;
  }
  authenticator_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Request.authenticator)
}
inline ::std::string* Request::mutable_authenticator() {
  set_has_authenticator();
  if (authenticator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authenticator_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.authenticator)
  return authenticator_;
}
inline ::std::string* Request::release_authenticator() {
  clear_has_authenticator();
  if (authenticator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = authenticator_;
    authenticator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_authenticator(::std::string* authenticator) {
  if (authenticator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete authenticator_;
  }
  if (authenticator) {
    set_has_authenticator();
    authenticator_ = authenticator;
  } else {
    clear_has_authenticator();
    authenticator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.authenticator)
}

// optional .blox.connect.CreateNamedBranch create_named_branch = 18;
inline bool Request::has_create_named_branch() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Request::set_has_create_named_branch() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Request::clear_has_create_named_branch() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Request::clear_create_named_branch() {
  if (create_named_branch_ != NULL) create_named_branch_->::blox::connect::CreateNamedBranch::Clear();
  clear_has_create_named_branch();
}
inline const ::blox::connect::CreateNamedBranch& Request::create_named_branch() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.create_named_branch)
  return create_named_branch_ != NULL ? *create_named_branch_ : *default_instance_->create_named_branch_;
}
inline ::blox::connect::CreateNamedBranch* Request::mutable_create_named_branch() {
  set_has_create_named_branch();
  if (create_named_branch_ == NULL) create_named_branch_ = new ::blox::connect::CreateNamedBranch;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.create_named_branch)
  return create_named_branch_;
}
inline ::blox::connect::CreateNamedBranch* Request::release_create_named_branch() {
  clear_has_create_named_branch();
  ::blox::connect::CreateNamedBranch* temp = create_named_branch_;
  create_named_branch_ = NULL;
  return temp;
}
inline void Request::set_allocated_create_named_branch(::blox::connect::CreateNamedBranch* create_named_branch) {
  delete create_named_branch_;
  create_named_branch_ = create_named_branch;
  if (create_named_branch) {
    set_has_create_named_branch();
  } else {
    clear_has_create_named_branch();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.create_named_branch)
}

// optional .blox.connect.CloseNamedBranch close_named_branch = 19;
inline bool Request::has_close_named_branch() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Request::set_has_close_named_branch() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Request::clear_has_close_named_branch() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Request::clear_close_named_branch() {
  if (close_named_branch_ != NULL) close_named_branch_->::blox::connect::CloseNamedBranch::Clear();
  clear_has_close_named_branch();
}
inline const ::blox::connect::CloseNamedBranch& Request::close_named_branch() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.close_named_branch)
  return close_named_branch_ != NULL ? *close_named_branch_ : *default_instance_->close_named_branch_;
}
inline ::blox::connect::CloseNamedBranch* Request::mutable_close_named_branch() {
  set_has_close_named_branch();
  if (close_named_branch_ == NULL) close_named_branch_ = new ::blox::connect::CloseNamedBranch;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.close_named_branch)
  return close_named_branch_;
}
inline ::blox::connect::CloseNamedBranch* Request::release_close_named_branch() {
  clear_has_close_named_branch();
  ::blox::connect::CloseNamedBranch* temp = close_named_branch_;
  close_named_branch_ = NULL;
  return temp;
}
inline void Request::set_allocated_close_named_branch(::blox::connect::CloseNamedBranch* close_named_branch) {
  delete close_named_branch_;
  close_named_branch_ = close_named_branch;
  if (close_named_branch) {
    set_has_close_named_branch();
  } else {
    clear_has_close_named_branch();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.close_named_branch)
}

// optional .blox.connect.GetBranchNames get_branch_names = 20;
inline bool Request::has_get_branch_names() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Request::set_has_get_branch_names() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Request::clear_has_get_branch_names() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Request::clear_get_branch_names() {
  if (get_branch_names_ != NULL) get_branch_names_->::blox::connect::GetBranchNames::Clear();
  clear_has_get_branch_names();
}
inline const ::blox::connect::GetBranchNames& Request::get_branch_names() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.get_branch_names)
  return get_branch_names_ != NULL ? *get_branch_names_ : *default_instance_->get_branch_names_;
}
inline ::blox::connect::GetBranchNames* Request::mutable_get_branch_names() {
  set_has_get_branch_names();
  if (get_branch_names_ == NULL) get_branch_names_ = new ::blox::connect::GetBranchNames;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.get_branch_names)
  return get_branch_names_;
}
inline ::blox::connect::GetBranchNames* Request::release_get_branch_names() {
  clear_has_get_branch_names();
  ::blox::connect::GetBranchNames* temp = get_branch_names_;
  get_branch_names_ = NULL;
  return temp;
}
inline void Request::set_allocated_get_branch_names(::blox::connect::GetBranchNames* get_branch_names) {
  delete get_branch_names_;
  get_branch_names_ = get_branch_names;
  if (get_branch_names) {
    set_has_get_branch_names();
  } else {
    clear_has_get_branch_names();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.get_branch_names)
}

// optional .blox.connect.RevertDatabase revert_database = 21;
inline bool Request::has_revert_database() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Request::set_has_revert_database() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Request::clear_has_revert_database() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Request::clear_revert_database() {
  if (revert_database_ != NULL) revert_database_->::blox::connect::RevertDatabase::Clear();
  clear_has_revert_database();
}
inline const ::blox::connect::RevertDatabase& Request::revert_database() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.revert_database)
  return revert_database_ != NULL ? *revert_database_ : *default_instance_->revert_database_;
}
inline ::blox::connect::RevertDatabase* Request::mutable_revert_database() {
  set_has_revert_database();
  if (revert_database_ == NULL) revert_database_ = new ::blox::connect::RevertDatabase;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.revert_database)
  return revert_database_;
}
inline ::blox::connect::RevertDatabase* Request::release_revert_database() {
  clear_has_revert_database();
  ::blox::connect::RevertDatabase* temp = revert_database_;
  revert_database_ = NULL;
  return temp;
}
inline void Request::set_allocated_revert_database(::blox::connect::RevertDatabase* revert_database) {
  delete revert_database_;
  revert_database_ = revert_database;
  if (revert_database) {
    set_has_revert_database();
  } else {
    clear_has_revert_database();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.revert_database)
}

// optional .blox.connect.GetWorkspaceInfo get_workspace_info = 22;
inline bool Request::has_get_workspace_info() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Request::set_has_get_workspace_info() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Request::clear_has_get_workspace_info() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Request::clear_get_workspace_info() {
  if (get_workspace_info_ != NULL) get_workspace_info_->::blox::connect::GetWorkspaceInfo::Clear();
  clear_has_get_workspace_info();
}
inline const ::blox::connect::GetWorkspaceInfo& Request::get_workspace_info() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.get_workspace_info)
  return get_workspace_info_ != NULL ? *get_workspace_info_ : *default_instance_->get_workspace_info_;
}
inline ::blox::connect::GetWorkspaceInfo* Request::mutable_get_workspace_info() {
  set_has_get_workspace_info();
  if (get_workspace_info_ == NULL) get_workspace_info_ = new ::blox::connect::GetWorkspaceInfo;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.get_workspace_info)
  return get_workspace_info_;
}
inline ::blox::connect::GetWorkspaceInfo* Request::release_get_workspace_info() {
  clear_has_get_workspace_info();
  ::blox::connect::GetWorkspaceInfo* temp = get_workspace_info_;
  get_workspace_info_ = NULL;
  return temp;
}
inline void Request::set_allocated_get_workspace_info(::blox::connect::GetWorkspaceInfo* get_workspace_info) {
  delete get_workspace_info_;
  get_workspace_info_ = get_workspace_info;
  if (get_workspace_info) {
    set_has_get_workspace_info();
  } else {
    clear_has_get_workspace_info();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.get_workspace_info)
}

// optional .blox.connect.StartMirror start_mirror = 23;
inline bool Request::has_start_mirror() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Request::set_has_start_mirror() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Request::clear_has_start_mirror() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Request::clear_start_mirror() {
  if (start_mirror_ != NULL) start_mirror_->::blox::connect::StartMirror::Clear();
  clear_has_start_mirror();
}
inline const ::blox::connect::StartMirror& Request::start_mirror() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.start_mirror)
  return start_mirror_ != NULL ? *start_mirror_ : *default_instance_->start_mirror_;
}
inline ::blox::connect::StartMirror* Request::mutable_start_mirror() {
  set_has_start_mirror();
  if (start_mirror_ == NULL) start_mirror_ = new ::blox::connect::StartMirror;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.start_mirror)
  return start_mirror_;
}
inline ::blox::connect::StartMirror* Request::release_start_mirror() {
  clear_has_start_mirror();
  ::blox::connect::StartMirror* temp = start_mirror_;
  start_mirror_ = NULL;
  return temp;
}
inline void Request::set_allocated_start_mirror(::blox::connect::StartMirror* start_mirror) {
  delete start_mirror_;
  start_mirror_ = start_mirror;
  if (start_mirror) {
    set_has_start_mirror();
  } else {
    clear_has_start_mirror();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.start_mirror)
}

// optional .blox.connect.StopMirror stop_mirror = 24;
inline bool Request::has_stop_mirror() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Request::set_has_stop_mirror() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Request::clear_has_stop_mirror() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Request::clear_stop_mirror() {
  if (stop_mirror_ != NULL) stop_mirror_->::blox::connect::StopMirror::Clear();
  clear_has_stop_mirror();
}
inline const ::blox::connect::StopMirror& Request::stop_mirror() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.stop_mirror)
  return stop_mirror_ != NULL ? *stop_mirror_ : *default_instance_->stop_mirror_;
}
inline ::blox::connect::StopMirror* Request::mutable_stop_mirror() {
  set_has_stop_mirror();
  if (stop_mirror_ == NULL) stop_mirror_ = new ::blox::connect::StopMirror;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.stop_mirror)
  return stop_mirror_;
}
inline ::blox::connect::StopMirror* Request::release_stop_mirror() {
  clear_has_stop_mirror();
  ::blox::connect::StopMirror* temp = stop_mirror_;
  stop_mirror_ = NULL;
  return temp;
}
inline void Request::set_allocated_stop_mirror(::blox::connect::StopMirror* stop_mirror) {
  delete stop_mirror_;
  stop_mirror_ = stop_mirror;
  if (stop_mirror) {
    set_has_stop_mirror();
  } else {
    clear_has_stop_mirror();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.stop_mirror)
}

// optional .blox.connect.PromoteMirror promote_mirror = 25;
inline bool Request::has_promote_mirror() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Request::set_has_promote_mirror() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Request::clear_has_promote_mirror() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Request::clear_promote_mirror() {
  if (promote_mirror_ != NULL) promote_mirror_->::blox::connect::PromoteMirror::Clear();
  clear_has_promote_mirror();
}
inline const ::blox::connect::PromoteMirror& Request::promote_mirror() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.promote_mirror)
  return promote_mirror_ != NULL ? *promote_mirror_ : *default_instance_->promote_mirror_;
}
inline ::blox::connect::PromoteMirror* Request::mutable_promote_mirror() {
  set_has_promote_mirror();
  if (promote_mirror_ == NULL) promote_mirror_ = new ::blox::connect::PromoteMirror;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.promote_mirror)
  return promote_mirror_;
}
inline ::blox::connect::PromoteMirror* Request::release_promote_mirror() {
  clear_has_promote_mirror();
  ::blox::connect::PromoteMirror* temp = promote_mirror_;
  promote_mirror_ = NULL;
  return temp;
}
inline void Request::set_allocated_promote_mirror(::blox::connect::PromoteMirror* promote_mirror) {
  delete promote_mirror_;
  promote_mirror_ = promote_mirror;
  if (promote_mirror) {
    set_has_promote_mirror();
  } else {
    clear_has_promote_mirror();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.promote_mirror)
}

// optional .blox.connect.CopyRemoteWorkSpace copy_remote_workspace = 26;
inline bool Request::has_copy_remote_workspace() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Request::set_has_copy_remote_workspace() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Request::clear_has_copy_remote_workspace() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Request::clear_copy_remote_workspace() {
  if (copy_remote_workspace_ != NULL) copy_remote_workspace_->::blox::connect::CopyRemoteWorkSpace::Clear();
  clear_has_copy_remote_workspace();
}
inline const ::blox::connect::CopyRemoteWorkSpace& Request::copy_remote_workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.copy_remote_workspace)
  return copy_remote_workspace_ != NULL ? *copy_remote_workspace_ : *default_instance_->copy_remote_workspace_;
}
inline ::blox::connect::CopyRemoteWorkSpace* Request::mutable_copy_remote_workspace() {
  set_has_copy_remote_workspace();
  if (copy_remote_workspace_ == NULL) copy_remote_workspace_ = new ::blox::connect::CopyRemoteWorkSpace;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.copy_remote_workspace)
  return copy_remote_workspace_;
}
inline ::blox::connect::CopyRemoteWorkSpace* Request::release_copy_remote_workspace() {
  clear_has_copy_remote_workspace();
  ::blox::connect::CopyRemoteWorkSpace* temp = copy_remote_workspace_;
  copy_remote_workspace_ = NULL;
  return temp;
}
inline void Request::set_allocated_copy_remote_workspace(::blox::connect::CopyRemoteWorkSpace* copy_remote_workspace) {
  delete copy_remote_workspace_;
  copy_remote_workspace_ = copy_remote_workspace;
  if (copy_remote_workspace) {
    set_has_copy_remote_workspace();
  } else {
    clear_has_copy_remote_workspace();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.copy_remote_workspace)
}

// optional .blox.connect.ExecuteBatchScript execute_batch_script = 27;
inline bool Request::has_execute_batch_script() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Request::set_has_execute_batch_script() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Request::clear_has_execute_batch_script() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Request::clear_execute_batch_script() {
  if (execute_batch_script_ != NULL) execute_batch_script_->::blox::connect::ExecuteBatchScript::Clear();
  clear_has_execute_batch_script();
}
inline const ::blox::connect::ExecuteBatchScript& Request::execute_batch_script() const {
  // @@protoc_insertion_point(field_get:blox.connect.Request.execute_batch_script)
  return execute_batch_script_ != NULL ? *execute_batch_script_ : *default_instance_->execute_batch_script_;
}
inline ::blox::connect::ExecuteBatchScript* Request::mutable_execute_batch_script() {
  set_has_execute_batch_script();
  if (execute_batch_script_ == NULL) execute_batch_script_ = new ::blox::connect::ExecuteBatchScript;
  // @@protoc_insertion_point(field_mutable:blox.connect.Request.execute_batch_script)
  return execute_batch_script_;
}
inline ::blox::connect::ExecuteBatchScript* Request::release_execute_batch_script() {
  clear_has_execute_batch_script();
  ::blox::connect::ExecuteBatchScript* temp = execute_batch_script_;
  execute_batch_script_ = NULL;
  return temp;
}
inline void Request::set_allocated_execute_batch_script(::blox::connect::ExecuteBatchScript* execute_batch_script) {
  delete execute_batch_script_;
  execute_batch_script_ = execute_batch_script;
  if (execute_batch_script) {
    set_has_execute_batch_script();
  } else {
    clear_has_execute_batch_script();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Request.execute_batch_script)
}

// -------------------------------------------------------------------

// Response

// optional string client_id = 1;
inline bool Response::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& Response::client_id() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.client_id)
  return *client_id_;
}
inline void Response::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Response.client_id)
}
inline void Response::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Response.client_id)
}
inline void Response::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Response.client_id)
}
inline ::std::string* Response::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.client_id)
  return client_id_;
}
inline ::std::string* Response::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.client_id)
}

// optional .blox.connect.ExceptionContainer exception = 2;
inline bool Response::has_exception() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_exception() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_exception() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_exception() {
  if (exception_ != NULL) exception_->::blox::connect::ExceptionContainer::Clear();
  clear_has_exception();
}
inline const ::blox::connect::ExceptionContainer& Response::exception() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.exception)
  return exception_ != NULL ? *exception_ : *default_instance_->exception_;
}
inline ::blox::connect::ExceptionContainer* Response::mutable_exception() {
  set_has_exception();
  if (exception_ == NULL) exception_ = new ::blox::connect::ExceptionContainer;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.exception)
  return exception_;
}
inline ::blox::connect::ExceptionContainer* Response::release_exception() {
  clear_has_exception();
  ::blox::connect::ExceptionContainer* temp = exception_;
  exception_ = NULL;
  return temp;
}
inline void Response::set_allocated_exception(::blox::connect::ExceptionContainer* exception) {
  delete exception_;
  exception_ = exception;
  if (exception) {
    set_has_exception();
  } else {
    clear_has_exception();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.exception)
}

// optional .blox.connect.TransactionResponse transaction = 3;
inline bool Response::has_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_transaction() {
  if (transaction_ != NULL) transaction_->::blox::connect::TransactionResponse::Clear();
  clear_has_transaction();
}
inline const ::blox::connect::TransactionResponse& Response::transaction() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.transaction)
  return transaction_ != NULL ? *transaction_ : *default_instance_->transaction_;
}
inline ::blox::connect::TransactionResponse* Response::mutable_transaction() {
  set_has_transaction();
  if (transaction_ == NULL) transaction_ = new ::blox::connect::TransactionResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.transaction)
  return transaction_;
}
inline ::blox::connect::TransactionResponse* Response::release_transaction() {
  clear_has_transaction();
  ::blox::connect::TransactionResponse* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void Response::set_allocated_transaction(::blox::connect::TransactionResponse* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    set_has_transaction();
  } else {
    clear_has_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.transaction)
}

// optional .blox.connect.CreateWorkSpaceResponse create = 4;
inline bool Response::has_create() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_create() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_create() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_create() {
  if (create_ != NULL) create_->::blox::connect::CreateWorkSpaceResponse::Clear();
  clear_has_create();
}
inline const ::blox::connect::CreateWorkSpaceResponse& Response::create() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.create)
  return create_ != NULL ? *create_ : *default_instance_->create_;
}
inline ::blox::connect::CreateWorkSpaceResponse* Response::mutable_create() {
  set_has_create();
  if (create_ == NULL) create_ = new ::blox::connect::CreateWorkSpaceResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.create)
  return create_;
}
inline ::blox::connect::CreateWorkSpaceResponse* Response::release_create() {
  clear_has_create();
  ::blox::connect::CreateWorkSpaceResponse* temp = create_;
  create_ = NULL;
  return temp;
}
inline void Response::set_allocated_create(::blox::connect::CreateWorkSpaceResponse* create) {
  delete create_;
  create_ = create;
  if (create) {
    set_has_create();
  } else {
    clear_has_create();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.create)
}

// optional .blox.connect.CopyWorkSpaceResponse copy = 5;
inline bool Response::has_copy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_copy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_copy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_copy() {
  if (copy_ != NULL) copy_->::blox::connect::CopyWorkSpaceResponse::Clear();
  clear_has_copy();
}
inline const ::blox::connect::CopyWorkSpaceResponse& Response::copy() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.copy)
  return copy_ != NULL ? *copy_ : *default_instance_->copy_;
}
inline ::blox::connect::CopyWorkSpaceResponse* Response::mutable_copy() {
  set_has_copy();
  if (copy_ == NULL) copy_ = new ::blox::connect::CopyWorkSpaceResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.copy)
  return copy_;
}
inline ::blox::connect::CopyWorkSpaceResponse* Response::release_copy() {
  clear_has_copy();
  ::blox::connect::CopyWorkSpaceResponse* temp = copy_;
  copy_ = NULL;
  return temp;
}
inline void Response::set_allocated_copy(::blox::connect::CopyWorkSpaceResponse* copy) {
  delete copy_;
  copy_ = copy;
  if (copy) {
    set_has_copy();
  } else {
    clear_has_copy();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.copy)
}

// optional .blox.connect.DeleteWorkSpaceResponse delete = 6;
inline bool Response::has_delete_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_delete_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_delete_() {
  if (delete__ != NULL) delete__->::blox::connect::DeleteWorkSpaceResponse::Clear();
  clear_has_delete_();
}
inline const ::blox::connect::DeleteWorkSpaceResponse& Response::delete_() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::blox::connect::DeleteWorkSpaceResponse* Response::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) delete__ = new ::blox::connect::DeleteWorkSpaceResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.delete)
  return delete__;
}
inline ::blox::connect::DeleteWorkSpaceResponse* Response::release_delete_() {
  clear_has_delete_();
  ::blox::connect::DeleteWorkSpaceResponse* temp = delete__;
  delete__ = NULL;
  return temp;
}
inline void Response::set_allocated_delete_(::blox::connect::DeleteWorkSpaceResponse* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.delete)
}

// optional .blox.connect.ImportWorkSpaceResponse importws = 7;
inline bool Response::has_importws() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_importws() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_importws() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_importws() {
  if (importws_ != NULL) importws_->::blox::connect::ImportWorkSpaceResponse::Clear();
  clear_has_importws();
}
inline const ::blox::connect::ImportWorkSpaceResponse& Response::importws() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.importws)
  return importws_ != NULL ? *importws_ : *default_instance_->importws_;
}
inline ::blox::connect::ImportWorkSpaceResponse* Response::mutable_importws() {
  set_has_importws();
  if (importws_ == NULL) importws_ = new ::blox::connect::ImportWorkSpaceResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.importws)
  return importws_;
}
inline ::blox::connect::ImportWorkSpaceResponse* Response::release_importws() {
  clear_has_importws();
  ::blox::connect::ImportWorkSpaceResponse* temp = importws_;
  importws_ = NULL;
  return temp;
}
inline void Response::set_allocated_importws(::blox::connect::ImportWorkSpaceResponse* importws) {
  delete importws_;
  importws_ = importws;
  if (importws) {
    set_has_importws();
  } else {
    clear_has_importws();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.importws)
}

// optional .blox.connect.ExportWorkSpaceResponse exportws = 8;
inline bool Response::has_exportws() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_exportws() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_exportws() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_exportws() {
  if (exportws_ != NULL) exportws_->::blox::connect::ExportWorkSpaceResponse::Clear();
  clear_has_exportws();
}
inline const ::blox::connect::ExportWorkSpaceResponse& Response::exportws() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.exportws)
  return exportws_ != NULL ? *exportws_ : *default_instance_->exportws_;
}
inline ::blox::connect::ExportWorkSpaceResponse* Response::mutable_exportws() {
  set_has_exportws();
  if (exportws_ == NULL) exportws_ = new ::blox::connect::ExportWorkSpaceResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.exportws)
  return exportws_;
}
inline ::blox::connect::ExportWorkSpaceResponse* Response::release_exportws() {
  clear_has_exportws();
  ::blox::connect::ExportWorkSpaceResponse* temp = exportws_;
  exportws_ = NULL;
  return temp;
}
inline void Response::set_allocated_exportws(::blox::connect::ExportWorkSpaceResponse* exportws) {
  delete exportws_;
  exportws_ = exportws;
  if (exportws) {
    set_has_exportws();
  } else {
    clear_has_exportws();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.exportws)
}

// optional .blox.connect.GetWorkSpacePathResponse get_ws_path = 9;
inline bool Response::has_get_ws_path() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_get_ws_path() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_get_ws_path() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_get_ws_path() {
  if (get_ws_path_ != NULL) get_ws_path_->::blox::connect::GetWorkSpacePathResponse::Clear();
  clear_has_get_ws_path();
}
inline const ::blox::connect::GetWorkSpacePathResponse& Response::get_ws_path() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.get_ws_path)
  return get_ws_path_ != NULL ? *get_ws_path_ : *default_instance_->get_ws_path_;
}
inline ::blox::connect::GetWorkSpacePathResponse* Response::mutable_get_ws_path() {
  set_has_get_ws_path();
  if (get_ws_path_ == NULL) get_ws_path_ = new ::blox::connect::GetWorkSpacePathResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.get_ws_path)
  return get_ws_path_;
}
inline ::blox::connect::GetWorkSpacePathResponse* Response::release_get_ws_path() {
  clear_has_get_ws_path();
  ::blox::connect::GetWorkSpacePathResponse* temp = get_ws_path_;
  get_ws_path_ = NULL;
  return temp;
}
inline void Response::set_allocated_get_ws_path(::blox::connect::GetWorkSpacePathResponse* get_ws_path) {
  delete get_ws_path_;
  get_ws_path_ = get_ws_path;
  if (get_ws_path) {
    set_has_get_ws_path();
  } else {
    clear_has_get_ws_path();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.get_ws_path)
}

// optional bytes compressed_log = 10;
inline bool Response::has_compressed_log() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Response::set_has_compressed_log() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Response::clear_has_compressed_log() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Response::clear_compressed_log() {
  if (compressed_log_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_log_->clear();
  }
  clear_has_compressed_log();
}
inline const ::std::string& Response::compressed_log() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.compressed_log)
  return *compressed_log_;
}
inline void Response::set_compressed_log(const ::std::string& value) {
  set_has_compressed_log();
  if (compressed_log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_log_ = new ::std::string;
  }
  compressed_log_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Response.compressed_log)
}
inline void Response::set_compressed_log(const char* value) {
  set_has_compressed_log();
  if (compressed_log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_log_ = new ::std::string;
  }
  compressed_log_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Response.compressed_log)
}
inline void Response::set_compressed_log(const void* value, size_t size) {
  set_has_compressed_log();
  if (compressed_log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_log_ = new ::std::string;
  }
  compressed_log_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Response.compressed_log)
}
inline ::std::string* Response::mutable_compressed_log() {
  set_has_compressed_log();
  if (compressed_log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compressed_log_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.compressed_log)
  return compressed_log_;
}
inline ::std::string* Response::release_compressed_log() {
  clear_has_compressed_log();
  if (compressed_log_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = compressed_log_;
    compressed_log_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response::set_allocated_compressed_log(::std::string* compressed_log) {
  if (compressed_log_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete compressed_log_;
  }
  if (compressed_log) {
    set_has_compressed_log();
    compressed_log_ = compressed_log;
  } else {
    clear_has_compressed_log();
    compressed_log_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.compressed_log)
}

// optional .blox.connect.GetWorkSpaceVersionResponse get_ws_version = 11;
inline bool Response::has_get_ws_version() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Response::set_has_get_ws_version() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Response::clear_has_get_ws_version() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Response::clear_get_ws_version() {
  if (get_ws_version_ != NULL) get_ws_version_->::blox::connect::GetWorkSpaceVersionResponse::Clear();
  clear_has_get_ws_version();
}
inline const ::blox::connect::GetWorkSpaceVersionResponse& Response::get_ws_version() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.get_ws_version)
  return get_ws_version_ != NULL ? *get_ws_version_ : *default_instance_->get_ws_version_;
}
inline ::blox::connect::GetWorkSpaceVersionResponse* Response::mutable_get_ws_version() {
  set_has_get_ws_version();
  if (get_ws_version_ == NULL) get_ws_version_ = new ::blox::connect::GetWorkSpaceVersionResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.get_ws_version)
  return get_ws_version_;
}
inline ::blox::connect::GetWorkSpaceVersionResponse* Response::release_get_ws_version() {
  clear_has_get_ws_version();
  ::blox::connect::GetWorkSpaceVersionResponse* temp = get_ws_version_;
  get_ws_version_ = NULL;
  return temp;
}
inline void Response::set_allocated_get_ws_version(::blox::connect::GetWorkSpaceVersionResponse* get_ws_version) {
  delete get_ws_version_;
  get_ws_version_ = get_ws_version;
  if (get_ws_version) {
    set_has_get_ws_version();
  } else {
    clear_has_get_ws_version();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.get_ws_version)
}

// optional .blox.connect.CancelRequestsResponse cancel_requests = 12;
inline bool Response::has_cancel_requests() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Response::set_has_cancel_requests() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Response::clear_has_cancel_requests() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Response::clear_cancel_requests() {
  if (cancel_requests_ != NULL) cancel_requests_->::blox::connect::CancelRequestsResponse::Clear();
  clear_has_cancel_requests();
}
inline const ::blox::connect::CancelRequestsResponse& Response::cancel_requests() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.cancel_requests)
  return cancel_requests_ != NULL ? *cancel_requests_ : *default_instance_->cancel_requests_;
}
inline ::blox::connect::CancelRequestsResponse* Response::mutable_cancel_requests() {
  set_has_cancel_requests();
  if (cancel_requests_ == NULL) cancel_requests_ = new ::blox::connect::CancelRequestsResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.cancel_requests)
  return cancel_requests_;
}
inline ::blox::connect::CancelRequestsResponse* Response::release_cancel_requests() {
  clear_has_cancel_requests();
  ::blox::connect::CancelRequestsResponse* temp = cancel_requests_;
  cancel_requests_ = NULL;
  return temp;
}
inline void Response::set_allocated_cancel_requests(::blox::connect::CancelRequestsResponse* cancel_requests) {
  delete cancel_requests_;
  cancel_requests_ = cancel_requests;
  if (cancel_requests) {
    set_has_cancel_requests();
  } else {
    clear_has_cancel_requests();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.cancel_requests)
}

// optional .blox.connect.AddReplicatorResponse add_replicator = 13;
inline bool Response::has_add_replicator() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Response::set_has_add_replicator() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Response::clear_has_add_replicator() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Response::clear_add_replicator() {
  if (add_replicator_ != NULL) add_replicator_->::blox::connect::AddReplicatorResponse::Clear();
  clear_has_add_replicator();
}
inline const ::blox::connect::AddReplicatorResponse& Response::add_replicator() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.add_replicator)
  return add_replicator_ != NULL ? *add_replicator_ : *default_instance_->add_replicator_;
}
inline ::blox::connect::AddReplicatorResponse* Response::mutable_add_replicator() {
  set_has_add_replicator();
  if (add_replicator_ == NULL) add_replicator_ = new ::blox::connect::AddReplicatorResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.add_replicator)
  return add_replicator_;
}
inline ::blox::connect::AddReplicatorResponse* Response::release_add_replicator() {
  clear_has_add_replicator();
  ::blox::connect::AddReplicatorResponse* temp = add_replicator_;
  add_replicator_ = NULL;
  return temp;
}
inline void Response::set_allocated_add_replicator(::blox::connect::AddReplicatorResponse* add_replicator) {
  delete add_replicator_;
  add_replicator_ = add_replicator;
  if (add_replicator) {
    set_has_add_replicator();
  } else {
    clear_has_add_replicator();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.add_replicator)
}

// optional .blox.connect.CreateNamedBranchResponse create_named_branch = 14;
inline bool Response::has_create_named_branch() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Response::set_has_create_named_branch() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Response::clear_has_create_named_branch() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Response::clear_create_named_branch() {
  if (create_named_branch_ != NULL) create_named_branch_->::blox::connect::CreateNamedBranchResponse::Clear();
  clear_has_create_named_branch();
}
inline const ::blox::connect::CreateNamedBranchResponse& Response::create_named_branch() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.create_named_branch)
  return create_named_branch_ != NULL ? *create_named_branch_ : *default_instance_->create_named_branch_;
}
inline ::blox::connect::CreateNamedBranchResponse* Response::mutable_create_named_branch() {
  set_has_create_named_branch();
  if (create_named_branch_ == NULL) create_named_branch_ = new ::blox::connect::CreateNamedBranchResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.create_named_branch)
  return create_named_branch_;
}
inline ::blox::connect::CreateNamedBranchResponse* Response::release_create_named_branch() {
  clear_has_create_named_branch();
  ::blox::connect::CreateNamedBranchResponse* temp = create_named_branch_;
  create_named_branch_ = NULL;
  return temp;
}
inline void Response::set_allocated_create_named_branch(::blox::connect::CreateNamedBranchResponse* create_named_branch) {
  delete create_named_branch_;
  create_named_branch_ = create_named_branch;
  if (create_named_branch) {
    set_has_create_named_branch();
  } else {
    clear_has_create_named_branch();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.create_named_branch)
}

// optional .blox.connect.CloseNamedBranchResponse close_named_branch = 15;
inline bool Response::has_close_named_branch() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Response::set_has_close_named_branch() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Response::clear_has_close_named_branch() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Response::clear_close_named_branch() {
  if (close_named_branch_ != NULL) close_named_branch_->::blox::connect::CloseNamedBranchResponse::Clear();
  clear_has_close_named_branch();
}
inline const ::blox::connect::CloseNamedBranchResponse& Response::close_named_branch() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.close_named_branch)
  return close_named_branch_ != NULL ? *close_named_branch_ : *default_instance_->close_named_branch_;
}
inline ::blox::connect::CloseNamedBranchResponse* Response::mutable_close_named_branch() {
  set_has_close_named_branch();
  if (close_named_branch_ == NULL) close_named_branch_ = new ::blox::connect::CloseNamedBranchResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.close_named_branch)
  return close_named_branch_;
}
inline ::blox::connect::CloseNamedBranchResponse* Response::release_close_named_branch() {
  clear_has_close_named_branch();
  ::blox::connect::CloseNamedBranchResponse* temp = close_named_branch_;
  close_named_branch_ = NULL;
  return temp;
}
inline void Response::set_allocated_close_named_branch(::blox::connect::CloseNamedBranchResponse* close_named_branch) {
  delete close_named_branch_;
  close_named_branch_ = close_named_branch;
  if (close_named_branch) {
    set_has_close_named_branch();
  } else {
    clear_has_close_named_branch();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.close_named_branch)
}

// optional .blox.connect.GetBranchNamesResponse get_branch_names = 16;
inline bool Response::has_get_branch_names() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Response::set_has_get_branch_names() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Response::clear_has_get_branch_names() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Response::clear_get_branch_names() {
  if (get_branch_names_ != NULL) get_branch_names_->::blox::connect::GetBranchNamesResponse::Clear();
  clear_has_get_branch_names();
}
inline const ::blox::connect::GetBranchNamesResponse& Response::get_branch_names() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.get_branch_names)
  return get_branch_names_ != NULL ? *get_branch_names_ : *default_instance_->get_branch_names_;
}
inline ::blox::connect::GetBranchNamesResponse* Response::mutable_get_branch_names() {
  set_has_get_branch_names();
  if (get_branch_names_ == NULL) get_branch_names_ = new ::blox::connect::GetBranchNamesResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.get_branch_names)
  return get_branch_names_;
}
inline ::blox::connect::GetBranchNamesResponse* Response::release_get_branch_names() {
  clear_has_get_branch_names();
  ::blox::connect::GetBranchNamesResponse* temp = get_branch_names_;
  get_branch_names_ = NULL;
  return temp;
}
inline void Response::set_allocated_get_branch_names(::blox::connect::GetBranchNamesResponse* get_branch_names) {
  delete get_branch_names_;
  get_branch_names_ = get_branch_names;
  if (get_branch_names) {
    set_has_get_branch_names();
  } else {
    clear_has_get_branch_names();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.get_branch_names)
}

// optional .blox.connect.RevertDatabaseResponse revert_database = 17;
inline bool Response::has_revert_database() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Response::set_has_revert_database() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Response::clear_has_revert_database() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Response::clear_revert_database() {
  if (revert_database_ != NULL) revert_database_->::blox::connect::RevertDatabaseResponse::Clear();
  clear_has_revert_database();
}
inline const ::blox::connect::RevertDatabaseResponse& Response::revert_database() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.revert_database)
  return revert_database_ != NULL ? *revert_database_ : *default_instance_->revert_database_;
}
inline ::blox::connect::RevertDatabaseResponse* Response::mutable_revert_database() {
  set_has_revert_database();
  if (revert_database_ == NULL) revert_database_ = new ::blox::connect::RevertDatabaseResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.revert_database)
  return revert_database_;
}
inline ::blox::connect::RevertDatabaseResponse* Response::release_revert_database() {
  clear_has_revert_database();
  ::blox::connect::RevertDatabaseResponse* temp = revert_database_;
  revert_database_ = NULL;
  return temp;
}
inline void Response::set_allocated_revert_database(::blox::connect::RevertDatabaseResponse* revert_database) {
  delete revert_database_;
  revert_database_ = revert_database;
  if (revert_database) {
    set_has_revert_database();
  } else {
    clear_has_revert_database();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.revert_database)
}

// optional .blox.connect.GetWorkspaceInfoResponse get_workspace_info = 18;
inline bool Response::has_get_workspace_info() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Response::set_has_get_workspace_info() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Response::clear_has_get_workspace_info() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Response::clear_get_workspace_info() {
  if (get_workspace_info_ != NULL) get_workspace_info_->::blox::connect::GetWorkspaceInfoResponse::Clear();
  clear_has_get_workspace_info();
}
inline const ::blox::connect::GetWorkspaceInfoResponse& Response::get_workspace_info() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.get_workspace_info)
  return get_workspace_info_ != NULL ? *get_workspace_info_ : *default_instance_->get_workspace_info_;
}
inline ::blox::connect::GetWorkspaceInfoResponse* Response::mutable_get_workspace_info() {
  set_has_get_workspace_info();
  if (get_workspace_info_ == NULL) get_workspace_info_ = new ::blox::connect::GetWorkspaceInfoResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.get_workspace_info)
  return get_workspace_info_;
}
inline ::blox::connect::GetWorkspaceInfoResponse* Response::release_get_workspace_info() {
  clear_has_get_workspace_info();
  ::blox::connect::GetWorkspaceInfoResponse* temp = get_workspace_info_;
  get_workspace_info_ = NULL;
  return temp;
}
inline void Response::set_allocated_get_workspace_info(::blox::connect::GetWorkspaceInfoResponse* get_workspace_info) {
  delete get_workspace_info_;
  get_workspace_info_ = get_workspace_info;
  if (get_workspace_info) {
    set_has_get_workspace_info();
  } else {
    clear_has_get_workspace_info();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.get_workspace_info)
}

// optional .blox.connect.StartMirrorResponse start_mirror = 19;
inline bool Response::has_start_mirror() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Response::set_has_start_mirror() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Response::clear_has_start_mirror() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Response::clear_start_mirror() {
  if (start_mirror_ != NULL) start_mirror_->::blox::connect::StartMirrorResponse::Clear();
  clear_has_start_mirror();
}
inline const ::blox::connect::StartMirrorResponse& Response::start_mirror() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.start_mirror)
  return start_mirror_ != NULL ? *start_mirror_ : *default_instance_->start_mirror_;
}
inline ::blox::connect::StartMirrorResponse* Response::mutable_start_mirror() {
  set_has_start_mirror();
  if (start_mirror_ == NULL) start_mirror_ = new ::blox::connect::StartMirrorResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.start_mirror)
  return start_mirror_;
}
inline ::blox::connect::StartMirrorResponse* Response::release_start_mirror() {
  clear_has_start_mirror();
  ::blox::connect::StartMirrorResponse* temp = start_mirror_;
  start_mirror_ = NULL;
  return temp;
}
inline void Response::set_allocated_start_mirror(::blox::connect::StartMirrorResponse* start_mirror) {
  delete start_mirror_;
  start_mirror_ = start_mirror;
  if (start_mirror) {
    set_has_start_mirror();
  } else {
    clear_has_start_mirror();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.start_mirror)
}

// optional .blox.connect.StopMirrorResponse stop_mirror = 20;
inline bool Response::has_stop_mirror() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Response::set_has_stop_mirror() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Response::clear_has_stop_mirror() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Response::clear_stop_mirror() {
  if (stop_mirror_ != NULL) stop_mirror_->::blox::connect::StopMirrorResponse::Clear();
  clear_has_stop_mirror();
}
inline const ::blox::connect::StopMirrorResponse& Response::stop_mirror() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.stop_mirror)
  return stop_mirror_ != NULL ? *stop_mirror_ : *default_instance_->stop_mirror_;
}
inline ::blox::connect::StopMirrorResponse* Response::mutable_stop_mirror() {
  set_has_stop_mirror();
  if (stop_mirror_ == NULL) stop_mirror_ = new ::blox::connect::StopMirrorResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.stop_mirror)
  return stop_mirror_;
}
inline ::blox::connect::StopMirrorResponse* Response::release_stop_mirror() {
  clear_has_stop_mirror();
  ::blox::connect::StopMirrorResponse* temp = stop_mirror_;
  stop_mirror_ = NULL;
  return temp;
}
inline void Response::set_allocated_stop_mirror(::blox::connect::StopMirrorResponse* stop_mirror) {
  delete stop_mirror_;
  stop_mirror_ = stop_mirror;
  if (stop_mirror) {
    set_has_stop_mirror();
  } else {
    clear_has_stop_mirror();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.stop_mirror)
}

// optional .blox.connect.PromoteMirrorResponse promote_mirror = 21;
inline bool Response::has_promote_mirror() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Response::set_has_promote_mirror() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Response::clear_has_promote_mirror() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Response::clear_promote_mirror() {
  if (promote_mirror_ != NULL) promote_mirror_->::blox::connect::PromoteMirrorResponse::Clear();
  clear_has_promote_mirror();
}
inline const ::blox::connect::PromoteMirrorResponse& Response::promote_mirror() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.promote_mirror)
  return promote_mirror_ != NULL ? *promote_mirror_ : *default_instance_->promote_mirror_;
}
inline ::blox::connect::PromoteMirrorResponse* Response::mutable_promote_mirror() {
  set_has_promote_mirror();
  if (promote_mirror_ == NULL) promote_mirror_ = new ::blox::connect::PromoteMirrorResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.promote_mirror)
  return promote_mirror_;
}
inline ::blox::connect::PromoteMirrorResponse* Response::release_promote_mirror() {
  clear_has_promote_mirror();
  ::blox::connect::PromoteMirrorResponse* temp = promote_mirror_;
  promote_mirror_ = NULL;
  return temp;
}
inline void Response::set_allocated_promote_mirror(::blox::connect::PromoteMirrorResponse* promote_mirror) {
  delete promote_mirror_;
  promote_mirror_ = promote_mirror;
  if (promote_mirror) {
    set_has_promote_mirror();
  } else {
    clear_has_promote_mirror();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.promote_mirror)
}

// optional .blox.connect.CopyRemoteWorkSpaceResponse copy_remote_workspace = 22;
inline bool Response::has_copy_remote_workspace() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Response::set_has_copy_remote_workspace() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Response::clear_has_copy_remote_workspace() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Response::clear_copy_remote_workspace() {
  if (copy_remote_workspace_ != NULL) copy_remote_workspace_->::blox::connect::CopyRemoteWorkSpaceResponse::Clear();
  clear_has_copy_remote_workspace();
}
inline const ::blox::connect::CopyRemoteWorkSpaceResponse& Response::copy_remote_workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.copy_remote_workspace)
  return copy_remote_workspace_ != NULL ? *copy_remote_workspace_ : *default_instance_->copy_remote_workspace_;
}
inline ::blox::connect::CopyRemoteWorkSpaceResponse* Response::mutable_copy_remote_workspace() {
  set_has_copy_remote_workspace();
  if (copy_remote_workspace_ == NULL) copy_remote_workspace_ = new ::blox::connect::CopyRemoteWorkSpaceResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.copy_remote_workspace)
  return copy_remote_workspace_;
}
inline ::blox::connect::CopyRemoteWorkSpaceResponse* Response::release_copy_remote_workspace() {
  clear_has_copy_remote_workspace();
  ::blox::connect::CopyRemoteWorkSpaceResponse* temp = copy_remote_workspace_;
  copy_remote_workspace_ = NULL;
  return temp;
}
inline void Response::set_allocated_copy_remote_workspace(::blox::connect::CopyRemoteWorkSpaceResponse* copy_remote_workspace) {
  delete copy_remote_workspace_;
  copy_remote_workspace_ = copy_remote_workspace;
  if (copy_remote_workspace) {
    set_has_copy_remote_workspace();
  } else {
    clear_has_copy_remote_workspace();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.copy_remote_workspace)
}

// optional .blox.connect.ExecuteBatchScriptResponse execute_batch_script = 23;
inline bool Response::has_execute_batch_script() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Response::set_has_execute_batch_script() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Response::clear_has_execute_batch_script() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Response::clear_execute_batch_script() {
  if (execute_batch_script_ != NULL) execute_batch_script_->::blox::connect::ExecuteBatchScriptResponse::Clear();
  clear_has_execute_batch_script();
}
inline const ::blox::connect::ExecuteBatchScriptResponse& Response::execute_batch_script() const {
  // @@protoc_insertion_point(field_get:blox.connect.Response.execute_batch_script)
  return execute_batch_script_ != NULL ? *execute_batch_script_ : *default_instance_->execute_batch_script_;
}
inline ::blox::connect::ExecuteBatchScriptResponse* Response::mutable_execute_batch_script() {
  set_has_execute_batch_script();
  if (execute_batch_script_ == NULL) execute_batch_script_ = new ::blox::connect::ExecuteBatchScriptResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.Response.execute_batch_script)
  return execute_batch_script_;
}
inline ::blox::connect::ExecuteBatchScriptResponse* Response::release_execute_batch_script() {
  clear_has_execute_batch_script();
  ::blox::connect::ExecuteBatchScriptResponse* temp = execute_batch_script_;
  execute_batch_script_ = NULL;
  return temp;
}
inline void Response::set_allocated_execute_batch_script(::blox::connect::ExecuteBatchScriptResponse* execute_batch_script) {
  delete execute_batch_script_;
  execute_batch_script_ = execute_batch_script;
  if (execute_batch_script) {
    set_has_execute_batch_script();
  } else {
    clear_has_execute_batch_script();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Response.execute_batch_script)
}

// -------------------------------------------------------------------

// Transaction

// required string workspace = 1;
inline bool Transaction::has_workspace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transaction::set_has_workspace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transaction::clear_has_workspace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transaction::clear_workspace() {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_->clear();
  }
  clear_has_workspace();
}
inline const ::std::string& Transaction::workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.Transaction.workspace)
  return *workspace_;
}
inline void Transaction::set_workspace(const ::std::string& value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Transaction.workspace)
}
inline void Transaction::set_workspace(const char* value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Transaction.workspace)
}
inline void Transaction::set_workspace(const char* value, size_t size) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Transaction.workspace)
}
inline ::std::string* Transaction::mutable_workspace() {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Transaction.workspace)
  return workspace_;
}
inline ::std::string* Transaction::release_workspace() {
  clear_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workspace_;
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Transaction::set_allocated_workspace(::std::string* workspace) {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workspace_;
  }
  if (workspace) {
    set_has_workspace();
    workspace_ = workspace;
  } else {
    clear_has_workspace();
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Transaction.workspace)
}

// repeated .blox.connect.Command command = 2;
inline int Transaction::command_size() const {
  return command_.size();
}
inline void Transaction::clear_command() {
  command_.Clear();
}
inline const ::blox::connect::Command& Transaction::command(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Transaction.command)
  return command_.Get(index);
}
inline ::blox::connect::Command* Transaction::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.Transaction.command)
  return command_.Mutable(index);
}
inline ::blox::connect::Command* Transaction::add_command() {
  // @@protoc_insertion_point(field_add:blox.connect.Transaction.command)
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
Transaction::command() const {
  // @@protoc_insertion_point(field_list:blox.connect.Transaction.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
Transaction::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Transaction.command)
  return &command_;
}

// repeated .blox.connect.Command command_after_fixpoint = 3;
inline int Transaction::command_after_fixpoint_size() const {
  return command_after_fixpoint_.size();
}
inline void Transaction::clear_command_after_fixpoint() {
  command_after_fixpoint_.Clear();
}
inline const ::blox::connect::Command& Transaction::command_after_fixpoint(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Transaction.command_after_fixpoint)
  return command_after_fixpoint_.Get(index);
}
inline ::blox::connect::Command* Transaction::mutable_command_after_fixpoint(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.Transaction.command_after_fixpoint)
  return command_after_fixpoint_.Mutable(index);
}
inline ::blox::connect::Command* Transaction::add_command_after_fixpoint() {
  // @@protoc_insertion_point(field_add:blox.connect.Transaction.command_after_fixpoint)
  return command_after_fixpoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
Transaction::command_after_fixpoint() const {
  // @@protoc_insertion_point(field_list:blox.connect.Transaction.command_after_fixpoint)
  return command_after_fixpoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
Transaction::mutable_command_after_fixpoint() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Transaction.command_after_fixpoint)
  return &command_after_fixpoint_;
}

// optional int32 timeout = 4 [default = -1];
inline bool Transaction::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transaction::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transaction::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transaction::clear_timeout() {
  timeout_ = -1;
  clear_has_timeout();
}
inline ::google::protobuf::int32 Transaction::timeout() const {
  // @@protoc_insertion_point(field_get:blox.connect.Transaction.timeout)
  return timeout_;
}
inline void Transaction::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.Transaction.timeout)
}

// optional bool exclusive = 5 [default = false];
inline bool Transaction::has_exclusive() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transaction::set_has_exclusive() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transaction::clear_has_exclusive() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transaction::clear_exclusive() {
  exclusive_ = false;
  clear_has_exclusive();
}
inline bool Transaction::exclusive() const {
  // @@protoc_insertion_point(field_get:blox.connect.Transaction.exclusive)
  return exclusive_;
}
inline void Transaction::set_exclusive(bool value) {
  set_has_exclusive();
  exclusive_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.Transaction.exclusive)
}

// optional bool readonly = 6 [default = false];
inline bool Transaction::has_readonly() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Transaction::set_has_readonly() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Transaction::clear_has_readonly() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Transaction::clear_readonly() {
  readonly_ = false;
  clear_has_readonly();
}
inline bool Transaction::readonly() const {
  // @@protoc_insertion_point(field_get:blox.connect.Transaction.readonly)
  return readonly_;
}
inline void Transaction::set_readonly(bool value) {
  set_has_readonly();
  readonly_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.Transaction.readonly)
}

// optional string commit_mode = 7;
inline bool Transaction::has_commit_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Transaction::set_has_commit_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Transaction::clear_has_commit_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Transaction::clear_commit_mode() {
  if (commit_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commit_mode_->clear();
  }
  clear_has_commit_mode();
}
inline const ::std::string& Transaction::commit_mode() const {
  // @@protoc_insertion_point(field_get:blox.connect.Transaction.commit_mode)
  return *commit_mode_;
}
inline void Transaction::set_commit_mode(const ::std::string& value) {
  set_has_commit_mode();
  if (commit_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commit_mode_ = new ::std::string;
  }
  commit_mode_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Transaction.commit_mode)
}
inline void Transaction::set_commit_mode(const char* value) {
  set_has_commit_mode();
  if (commit_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commit_mode_ = new ::std::string;
  }
  commit_mode_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Transaction.commit_mode)
}
inline void Transaction::set_commit_mode(const char* value, size_t size) {
  set_has_commit_mode();
  if (commit_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commit_mode_ = new ::std::string;
  }
  commit_mode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Transaction.commit_mode)
}
inline ::std::string* Transaction::mutable_commit_mode() {
  set_has_commit_mode();
  if (commit_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commit_mode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Transaction.commit_mode)
  return commit_mode_;
}
inline ::std::string* Transaction::release_commit_mode() {
  clear_has_commit_mode();
  if (commit_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = commit_mode_;
    commit_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Transaction::set_allocated_commit_mode(::std::string* commit_mode) {
  if (commit_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete commit_mode_;
  }
  if (commit_mode) {
    set_has_commit_mode();
    commit_mode_ = commit_mode;
  } else {
    clear_has_commit_mode();
    commit_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Transaction.commit_mode)
}

// -------------------------------------------------------------------

// TransactionResponse

// repeated .blox.connect.CommandResponse command = 1;
inline int TransactionResponse::command_size() const {
  return command_.size();
}
inline void TransactionResponse::clear_command() {
  command_.Clear();
}
inline const ::blox::connect::CommandResponse& TransactionResponse::command(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.TransactionResponse.command)
  return command_.Get(index);
}
inline ::blox::connect::CommandResponse* TransactionResponse::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.TransactionResponse.command)
  return command_.Mutable(index);
}
inline ::blox::connect::CommandResponse* TransactionResponse::add_command() {
  // @@protoc_insertion_point(field_add:blox.connect.TransactionResponse.command)
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
TransactionResponse::command() const {
  // @@protoc_insertion_point(field_list:blox.connect.TransactionResponse.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
TransactionResponse::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.TransactionResponse.command)
  return &command_;
}

// repeated .blox.connect.CommandResponse command_after_fixpoint = 2;
inline int TransactionResponse::command_after_fixpoint_size() const {
  return command_after_fixpoint_.size();
}
inline void TransactionResponse::clear_command_after_fixpoint() {
  command_after_fixpoint_.Clear();
}
inline const ::blox::connect::CommandResponse& TransactionResponse::command_after_fixpoint(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.TransactionResponse.command_after_fixpoint)
  return command_after_fixpoint_.Get(index);
}
inline ::blox::connect::CommandResponse* TransactionResponse::mutable_command_after_fixpoint(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.TransactionResponse.command_after_fixpoint)
  return command_after_fixpoint_.Mutable(index);
}
inline ::blox::connect::CommandResponse* TransactionResponse::add_command_after_fixpoint() {
  // @@protoc_insertion_point(field_add:blox.connect.TransactionResponse.command_after_fixpoint)
  return command_after_fixpoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
TransactionResponse::command_after_fixpoint() const {
  // @@protoc_insertion_point(field_list:blox.connect.TransactionResponse.command_after_fixpoint)
  return command_after_fixpoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
TransactionResponse::mutable_command_after_fixpoint() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.TransactionResponse.command_after_fixpoint)
  return &command_after_fixpoint_;
}

// -------------------------------------------------------------------

// CreateNamedBranch

// required string workspace = 1;
inline bool CreateNamedBranch::has_workspace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateNamedBranch::set_has_workspace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateNamedBranch::clear_has_workspace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateNamedBranch::clear_workspace() {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_->clear();
  }
  clear_has_workspace();
}
inline const ::std::string& CreateNamedBranch::workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateNamedBranch.workspace)
  return *workspace_;
}
inline void CreateNamedBranch::set_workspace(const ::std::string& value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CreateNamedBranch.workspace)
}
inline void CreateNamedBranch::set_workspace(const char* value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CreateNamedBranch.workspace)
}
inline void CreateNamedBranch::set_workspace(const char* value, size_t size) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CreateNamedBranch.workspace)
}
inline ::std::string* CreateNamedBranch::mutable_workspace() {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateNamedBranch.workspace)
  return workspace_;
}
inline ::std::string* CreateNamedBranch::release_workspace() {
  clear_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workspace_;
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateNamedBranch::set_allocated_workspace(::std::string* workspace) {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workspace_;
  }
  if (workspace) {
    set_has_workspace();
    workspace_ = workspace;
  } else {
    clear_has_workspace();
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CreateNamedBranch.workspace)
}

// required string branch = 2;
inline bool CreateNamedBranch::has_branch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateNamedBranch::set_has_branch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateNamedBranch::clear_has_branch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateNamedBranch::clear_branch() {
  if (branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_->clear();
  }
  clear_has_branch();
}
inline const ::std::string& CreateNamedBranch::branch() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateNamedBranch.branch)
  return *branch_;
}
inline void CreateNamedBranch::set_branch(const ::std::string& value) {
  set_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_ = new ::std::string;
  }
  branch_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CreateNamedBranch.branch)
}
inline void CreateNamedBranch::set_branch(const char* value) {
  set_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_ = new ::std::string;
  }
  branch_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CreateNamedBranch.branch)
}
inline void CreateNamedBranch::set_branch(const char* value, size_t size) {
  set_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_ = new ::std::string;
  }
  branch_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CreateNamedBranch.branch)
}
inline ::std::string* CreateNamedBranch::mutable_branch() {
  set_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateNamedBranch.branch)
  return branch_;
}
inline ::std::string* CreateNamedBranch::release_branch() {
  clear_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = branch_;
    branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateNamedBranch::set_allocated_branch(::std::string* branch) {
  if (branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete branch_;
  }
  if (branch) {
    set_has_branch();
    branch_ = branch;
  } else {
    clear_has_branch();
    branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CreateNamedBranch.branch)
}

// optional string from_branch = 3;
inline bool CreateNamedBranch::has_from_branch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateNamedBranch::set_has_from_branch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateNamedBranch::clear_has_from_branch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateNamedBranch::clear_from_branch() {
  if (from_branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_branch_->clear();
  }
  clear_has_from_branch();
}
inline const ::std::string& CreateNamedBranch::from_branch() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateNamedBranch.from_branch)
  return *from_branch_;
}
inline void CreateNamedBranch::set_from_branch(const ::std::string& value) {
  set_has_from_branch();
  if (from_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_branch_ = new ::std::string;
  }
  from_branch_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CreateNamedBranch.from_branch)
}
inline void CreateNamedBranch::set_from_branch(const char* value) {
  set_has_from_branch();
  if (from_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_branch_ = new ::std::string;
  }
  from_branch_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CreateNamedBranch.from_branch)
}
inline void CreateNamedBranch::set_from_branch(const char* value, size_t size) {
  set_has_from_branch();
  if (from_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_branch_ = new ::std::string;
  }
  from_branch_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CreateNamedBranch.from_branch)
}
inline ::std::string* CreateNamedBranch::mutable_from_branch() {
  set_has_from_branch();
  if (from_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_branch_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateNamedBranch.from_branch)
  return from_branch_;
}
inline ::std::string* CreateNamedBranch::release_from_branch() {
  clear_has_from_branch();
  if (from_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = from_branch_;
    from_branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateNamedBranch::set_allocated_from_branch(::std::string* from_branch) {
  if (from_branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_branch_;
  }
  if (from_branch) {
    set_has_from_branch();
    from_branch_ = from_branch;
  } else {
    clear_has_from_branch();
    from_branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CreateNamedBranch.from_branch)
}

// optional bool overwrite = 4;
inline bool CreateNamedBranch::has_overwrite() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateNamedBranch::set_has_overwrite() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateNamedBranch::clear_has_overwrite() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateNamedBranch::clear_overwrite() {
  overwrite_ = false;
  clear_has_overwrite();
}
inline bool CreateNamedBranch::overwrite() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateNamedBranch.overwrite)
  return overwrite_;
}
inline void CreateNamedBranch::set_overwrite(bool value) {
  set_has_overwrite();
  overwrite_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.CreateNamedBranch.overwrite)
}

// -------------------------------------------------------------------

// CreateNamedBranchResponse

// -------------------------------------------------------------------

// CloseNamedBranch

// required string workspace = 1;
inline bool CloseNamedBranch::has_workspace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseNamedBranch::set_has_workspace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseNamedBranch::clear_has_workspace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseNamedBranch::clear_workspace() {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_->clear();
  }
  clear_has_workspace();
}
inline const ::std::string& CloseNamedBranch::workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.CloseNamedBranch.workspace)
  return *workspace_;
}
inline void CloseNamedBranch::set_workspace(const ::std::string& value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CloseNamedBranch.workspace)
}
inline void CloseNamedBranch::set_workspace(const char* value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CloseNamedBranch.workspace)
}
inline void CloseNamedBranch::set_workspace(const char* value, size_t size) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CloseNamedBranch.workspace)
}
inline ::std::string* CloseNamedBranch::mutable_workspace() {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CloseNamedBranch.workspace)
  return workspace_;
}
inline ::std::string* CloseNamedBranch::release_workspace() {
  clear_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workspace_;
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CloseNamedBranch::set_allocated_workspace(::std::string* workspace) {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workspace_;
  }
  if (workspace) {
    set_has_workspace();
    workspace_ = workspace;
  } else {
    clear_has_workspace();
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CloseNamedBranch.workspace)
}

// required string branch = 2;
inline bool CloseNamedBranch::has_branch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseNamedBranch::set_has_branch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseNamedBranch::clear_has_branch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseNamedBranch::clear_branch() {
  if (branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_->clear();
  }
  clear_has_branch();
}
inline const ::std::string& CloseNamedBranch::branch() const {
  // @@protoc_insertion_point(field_get:blox.connect.CloseNamedBranch.branch)
  return *branch_;
}
inline void CloseNamedBranch::set_branch(const ::std::string& value) {
  set_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_ = new ::std::string;
  }
  branch_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CloseNamedBranch.branch)
}
inline void CloseNamedBranch::set_branch(const char* value) {
  set_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_ = new ::std::string;
  }
  branch_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CloseNamedBranch.branch)
}
inline void CloseNamedBranch::set_branch(const char* value, size_t size) {
  set_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_ = new ::std::string;
  }
  branch_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CloseNamedBranch.branch)
}
inline ::std::string* CloseNamedBranch::mutable_branch() {
  set_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CloseNamedBranch.branch)
  return branch_;
}
inline ::std::string* CloseNamedBranch::release_branch() {
  clear_has_branch();
  if (branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = branch_;
    branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CloseNamedBranch::set_allocated_branch(::std::string* branch) {
  if (branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete branch_;
  }
  if (branch) {
    set_has_branch();
    branch_ = branch;
  } else {
    clear_has_branch();
    branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CloseNamedBranch.branch)
}

// -------------------------------------------------------------------

// CloseNamedBranchResponse

// -------------------------------------------------------------------

// GetBranchNames

// required string workspace = 1;
inline bool GetBranchNames::has_workspace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBranchNames::set_has_workspace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBranchNames::clear_has_workspace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBranchNames::clear_workspace() {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_->clear();
  }
  clear_has_workspace();
}
inline const ::std::string& GetBranchNames::workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetBranchNames.workspace)
  return *workspace_;
}
inline void GetBranchNames::set_workspace(const ::std::string& value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetBranchNames.workspace)
}
inline void GetBranchNames::set_workspace(const char* value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetBranchNames.workspace)
}
inline void GetBranchNames::set_workspace(const char* value, size_t size) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetBranchNames.workspace)
}
inline ::std::string* GetBranchNames::mutable_workspace() {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetBranchNames.workspace)
  return workspace_;
}
inline ::std::string* GetBranchNames::release_workspace() {
  clear_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workspace_;
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetBranchNames::set_allocated_workspace(::std::string* workspace) {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workspace_;
  }
  if (workspace) {
    set_has_workspace();
    workspace_ = workspace;
  } else {
    clear_has_workspace();
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetBranchNames.workspace)
}

// required bool include_auto_versions = 2;
inline bool GetBranchNames::has_include_auto_versions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBranchNames::set_has_include_auto_versions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBranchNames::clear_has_include_auto_versions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBranchNames::clear_include_auto_versions() {
  include_auto_versions_ = false;
  clear_has_include_auto_versions();
}
inline bool GetBranchNames::include_auto_versions() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetBranchNames.include_auto_versions)
  return include_auto_versions_;
}
inline void GetBranchNames::set_include_auto_versions(bool value) {
  set_has_include_auto_versions();
  include_auto_versions_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetBranchNames.include_auto_versions)
}

// -------------------------------------------------------------------

// GetBranchNamesResponse

// repeated string names = 1;
inline int GetBranchNamesResponse::names_size() const {
  return names_.size();
}
inline void GetBranchNamesResponse::clear_names() {
  names_.Clear();
}
inline const ::std::string& GetBranchNamesResponse::names(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetBranchNamesResponse.names)
  return names_.Get(index);
}
inline ::std::string* GetBranchNamesResponse::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetBranchNamesResponse.names)
  return names_.Mutable(index);
}
inline void GetBranchNamesResponse::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.GetBranchNamesResponse.names)
  names_.Mutable(index)->assign(value);
}
inline void GetBranchNamesResponse::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetBranchNamesResponse.names)
}
inline void GetBranchNamesResponse::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetBranchNamesResponse.names)
}
inline ::std::string* GetBranchNamesResponse::add_names() {
  return names_.Add();
}
inline void GetBranchNamesResponse::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.GetBranchNamesResponse.names)
}
inline void GetBranchNamesResponse::add_names(const char* value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.GetBranchNamesResponse.names)
}
inline void GetBranchNamesResponse::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.GetBranchNamesResponse.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetBranchNamesResponse::names() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetBranchNamesResponse.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetBranchNamesResponse::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetBranchNamesResponse.names)
  return &names_;
}

// -------------------------------------------------------------------

// RevertDatabase

// required string workspace = 1;
inline bool RevertDatabase::has_workspace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RevertDatabase::set_has_workspace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RevertDatabase::clear_has_workspace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RevertDatabase::clear_workspace() {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_->clear();
  }
  clear_has_workspace();
}
inline const ::std::string& RevertDatabase::workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.RevertDatabase.workspace)
  return *workspace_;
}
inline void RevertDatabase::set_workspace(const ::std::string& value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.RevertDatabase.workspace)
}
inline void RevertDatabase::set_workspace(const char* value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.RevertDatabase.workspace)
}
inline void RevertDatabase::set_workspace(const char* value, size_t size) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.RevertDatabase.workspace)
}
inline ::std::string* RevertDatabase::mutable_workspace() {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.RevertDatabase.workspace)
  return workspace_;
}
inline ::std::string* RevertDatabase::release_workspace() {
  clear_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workspace_;
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RevertDatabase::set_allocated_workspace(::std::string* workspace) {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workspace_;
  }
  if (workspace) {
    set_has_workspace();
    workspace_ = workspace;
  } else {
    clear_has_workspace();
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.RevertDatabase.workspace)
}

// required string older_branch = 2;
inline bool RevertDatabase::has_older_branch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RevertDatabase::set_has_older_branch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RevertDatabase::clear_has_older_branch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RevertDatabase::clear_older_branch() {
  if (older_branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    older_branch_->clear();
  }
  clear_has_older_branch();
}
inline const ::std::string& RevertDatabase::older_branch() const {
  // @@protoc_insertion_point(field_get:blox.connect.RevertDatabase.older_branch)
  return *older_branch_;
}
inline void RevertDatabase::set_older_branch(const ::std::string& value) {
  set_has_older_branch();
  if (older_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    older_branch_ = new ::std::string;
  }
  older_branch_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.RevertDatabase.older_branch)
}
inline void RevertDatabase::set_older_branch(const char* value) {
  set_has_older_branch();
  if (older_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    older_branch_ = new ::std::string;
  }
  older_branch_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.RevertDatabase.older_branch)
}
inline void RevertDatabase::set_older_branch(const char* value, size_t size) {
  set_has_older_branch();
  if (older_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    older_branch_ = new ::std::string;
  }
  older_branch_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.RevertDatabase.older_branch)
}
inline ::std::string* RevertDatabase::mutable_older_branch() {
  set_has_older_branch();
  if (older_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    older_branch_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.RevertDatabase.older_branch)
  return older_branch_;
}
inline ::std::string* RevertDatabase::release_older_branch() {
  clear_has_older_branch();
  if (older_branch_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = older_branch_;
    older_branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RevertDatabase::set_allocated_older_branch(::std::string* older_branch) {
  if (older_branch_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete older_branch_;
  }
  if (older_branch) {
    set_has_older_branch();
    older_branch_ = older_branch;
  } else {
    clear_has_older_branch();
    older_branch_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.RevertDatabase.older_branch)
}

// -------------------------------------------------------------------

// RevertDatabaseResponse

// -------------------------------------------------------------------

// CreateWorkSpace

// optional string name = 1;
inline bool CreateWorkSpace::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateWorkSpace::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateWorkSpace::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateWorkSpace::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateWorkSpace::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpace.name)
  return *name_;
}
inline void CreateWorkSpace::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CreateWorkSpace.name)
}
inline void CreateWorkSpace::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CreateWorkSpace.name)
}
inline void CreateWorkSpace::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CreateWorkSpace.name)
}
inline ::std::string* CreateWorkSpace::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateWorkSpace.name)
  return name_;
}
inline ::std::string* CreateWorkSpace::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateWorkSpace::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CreateWorkSpace.name)
}

// repeated .blox.connect.Command command = 2;
inline int CreateWorkSpace::command_size() const {
  return command_.size();
}
inline void CreateWorkSpace::clear_command() {
  command_.Clear();
}
inline const ::blox::connect::Command& CreateWorkSpace::command(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpace.command)
  return command_.Get(index);
}
inline ::blox::connect::Command* CreateWorkSpace::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateWorkSpace.command)
  return command_.Mutable(index);
}
inline ::blox::connect::Command* CreateWorkSpace::add_command() {
  // @@protoc_insertion_point(field_add:blox.connect.CreateWorkSpace.command)
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
CreateWorkSpace::command() const {
  // @@protoc_insertion_point(field_list:blox.connect.CreateWorkSpace.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
CreateWorkSpace::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.CreateWorkSpace.command)
  return &command_;
}

// repeated .blox.connect.Command command_after_fixpoint = 3;
inline int CreateWorkSpace::command_after_fixpoint_size() const {
  return command_after_fixpoint_.size();
}
inline void CreateWorkSpace::clear_command_after_fixpoint() {
  command_after_fixpoint_.Clear();
}
inline const ::blox::connect::Command& CreateWorkSpace::command_after_fixpoint(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpace.command_after_fixpoint)
  return command_after_fixpoint_.Get(index);
}
inline ::blox::connect::Command* CreateWorkSpace::mutable_command_after_fixpoint(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateWorkSpace.command_after_fixpoint)
  return command_after_fixpoint_.Mutable(index);
}
inline ::blox::connect::Command* CreateWorkSpace::add_command_after_fixpoint() {
  // @@protoc_insertion_point(field_add:blox.connect.CreateWorkSpace.command_after_fixpoint)
  return command_after_fixpoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
CreateWorkSpace::command_after_fixpoint() const {
  // @@protoc_insertion_point(field_list:blox.connect.CreateWorkSpace.command_after_fixpoint)
  return command_after_fixpoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
CreateWorkSpace::mutable_command_after_fixpoint() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.CreateWorkSpace.command_after_fixpoint)
  return &command_after_fixpoint_;
}

// optional bool measure_engine = 4 [default = false];
inline bool CreateWorkSpace::has_measure_engine() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateWorkSpace::set_has_measure_engine() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateWorkSpace::clear_has_measure_engine() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateWorkSpace::clear_measure_engine() {
  measure_engine_ = false;
  clear_has_measure_engine();
}
inline bool CreateWorkSpace::measure_engine() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpace.measure_engine)
  return measure_engine_;
}
inline void CreateWorkSpace::set_measure_engine(bool value) {
  set_has_measure_engine();
  measure_engine_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.CreateWorkSpace.measure_engine)
}

// optional bool snapshot_isolation = 5 [default = false];
inline bool CreateWorkSpace::has_snapshot_isolation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateWorkSpace::set_has_snapshot_isolation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateWorkSpace::clear_has_snapshot_isolation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateWorkSpace::clear_snapshot_isolation() {
  snapshot_isolation_ = false;
  clear_has_snapshot_isolation();
}
inline bool CreateWorkSpace::snapshot_isolation() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpace.snapshot_isolation)
  return snapshot_isolation_;
}
inline void CreateWorkSpace::set_snapshot_isolation(bool value) {
  set_has_snapshot_isolation();
  snapshot_isolation_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.CreateWorkSpace.snapshot_isolation)
}

// optional string libraries = 6;
inline bool CreateWorkSpace::has_libraries() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateWorkSpace::set_has_libraries() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateWorkSpace::clear_has_libraries() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateWorkSpace::clear_libraries() {
  if (libraries_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    libraries_->clear();
  }
  clear_has_libraries();
}
inline const ::std::string& CreateWorkSpace::libraries() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpace.libraries)
  return *libraries_;
}
inline void CreateWorkSpace::set_libraries(const ::std::string& value) {
  set_has_libraries();
  if (libraries_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    libraries_ = new ::std::string;
  }
  libraries_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CreateWorkSpace.libraries)
}
inline void CreateWorkSpace::set_libraries(const char* value) {
  set_has_libraries();
  if (libraries_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    libraries_ = new ::std::string;
  }
  libraries_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CreateWorkSpace.libraries)
}
inline void CreateWorkSpace::set_libraries(const char* value, size_t size) {
  set_has_libraries();
  if (libraries_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    libraries_ = new ::std::string;
  }
  libraries_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CreateWorkSpace.libraries)
}
inline ::std::string* CreateWorkSpace::mutable_libraries() {
  set_has_libraries();
  if (libraries_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    libraries_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateWorkSpace.libraries)
  return libraries_;
}
inline ::std::string* CreateWorkSpace::release_libraries() {
  clear_has_libraries();
  if (libraries_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = libraries_;
    libraries_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateWorkSpace::set_allocated_libraries(::std::string* libraries) {
  if (libraries_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete libraries_;
  }
  if (libraries) {
    set_has_libraries();
    libraries_ = libraries;
  } else {
    clear_has_libraries();
    libraries_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CreateWorkSpace.libraries)
}

// optional bool overwrite = 7;
inline bool CreateWorkSpace::has_overwrite() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateWorkSpace::set_has_overwrite() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateWorkSpace::clear_has_overwrite() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateWorkSpace::clear_overwrite() {
  overwrite_ = false;
  clear_has_overwrite();
}
inline bool CreateWorkSpace::overwrite() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpace.overwrite)
  return overwrite_;
}
inline void CreateWorkSpace::set_overwrite(bool value) {
  set_has_overwrite();
  overwrite_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.CreateWorkSpace.overwrite)
}

// optional bool unique = 8;
inline bool CreateWorkSpace::has_unique() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateWorkSpace::set_has_unique() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateWorkSpace::clear_has_unique() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateWorkSpace::clear_unique() {
  unique_ = false;
  clear_has_unique();
}
inline bool CreateWorkSpace::unique() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpace.unique)
  return unique_;
}
inline void CreateWorkSpace::set_unique(bool value) {
  set_has_unique();
  unique_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.CreateWorkSpace.unique)
}

// -------------------------------------------------------------------

// CreateWorkSpaceResponse

// required string name = 1;
inline bool CreateWorkSpaceResponse::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateWorkSpaceResponse::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateWorkSpaceResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateWorkSpaceResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateWorkSpaceResponse::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpaceResponse.name)
  return *name_;
}
inline void CreateWorkSpaceResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CreateWorkSpaceResponse.name)
}
inline void CreateWorkSpaceResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CreateWorkSpaceResponse.name)
}
inline void CreateWorkSpaceResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CreateWorkSpaceResponse.name)
}
inline ::std::string* CreateWorkSpaceResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateWorkSpaceResponse.name)
  return name_;
}
inline ::std::string* CreateWorkSpaceResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateWorkSpaceResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CreateWorkSpaceResponse.name)
}

// repeated .blox.connect.CommandResponse command = 2;
inline int CreateWorkSpaceResponse::command_size() const {
  return command_.size();
}
inline void CreateWorkSpaceResponse::clear_command() {
  command_.Clear();
}
inline const ::blox::connect::CommandResponse& CreateWorkSpaceResponse::command(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpaceResponse.command)
  return command_.Get(index);
}
inline ::blox::connect::CommandResponse* CreateWorkSpaceResponse::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateWorkSpaceResponse.command)
  return command_.Mutable(index);
}
inline ::blox::connect::CommandResponse* CreateWorkSpaceResponse::add_command() {
  // @@protoc_insertion_point(field_add:blox.connect.CreateWorkSpaceResponse.command)
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
CreateWorkSpaceResponse::command() const {
  // @@protoc_insertion_point(field_list:blox.connect.CreateWorkSpaceResponse.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
CreateWorkSpaceResponse::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.CreateWorkSpaceResponse.command)
  return &command_;
}

// repeated .blox.connect.CommandResponse command_after_fixpoint = 3;
inline int CreateWorkSpaceResponse::command_after_fixpoint_size() const {
  return command_after_fixpoint_.size();
}
inline void CreateWorkSpaceResponse::clear_command_after_fixpoint() {
  command_after_fixpoint_.Clear();
}
inline const ::blox::connect::CommandResponse& CreateWorkSpaceResponse::command_after_fixpoint(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.CreateWorkSpaceResponse.command_after_fixpoint)
  return command_after_fixpoint_.Get(index);
}
inline ::blox::connect::CommandResponse* CreateWorkSpaceResponse::mutable_command_after_fixpoint(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.CreateWorkSpaceResponse.command_after_fixpoint)
  return command_after_fixpoint_.Mutable(index);
}
inline ::blox::connect::CommandResponse* CreateWorkSpaceResponse::add_command_after_fixpoint() {
  // @@protoc_insertion_point(field_add:blox.connect.CreateWorkSpaceResponse.command_after_fixpoint)
  return command_after_fixpoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
CreateWorkSpaceResponse::command_after_fixpoint() const {
  // @@protoc_insertion_point(field_list:blox.connect.CreateWorkSpaceResponse.command_after_fixpoint)
  return command_after_fixpoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
CreateWorkSpaceResponse::mutable_command_after_fixpoint() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.CreateWorkSpaceResponse.command_after_fixpoint)
  return &command_after_fixpoint_;
}

// -------------------------------------------------------------------

// CopyWorkSpace

// required string path = 1;
inline bool CopyWorkSpace::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CopyWorkSpace::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CopyWorkSpace::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CopyWorkSpace::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& CopyWorkSpace::path() const {
  // @@protoc_insertion_point(field_get:blox.connect.CopyWorkSpace.path)
  return *path_;
}
inline void CopyWorkSpace::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CopyWorkSpace.path)
}
inline void CopyWorkSpace::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CopyWorkSpace.path)
}
inline void CopyWorkSpace::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CopyWorkSpace.path)
}
inline ::std::string* CopyWorkSpace::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CopyWorkSpace.path)
  return path_;
}
inline ::std::string* CopyWorkSpace::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CopyWorkSpace::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CopyWorkSpace.path)
}

// optional string new_path = 2;
inline bool CopyWorkSpace::has_new_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CopyWorkSpace::set_has_new_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CopyWorkSpace::clear_has_new_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CopyWorkSpace::clear_new_path() {
  if (new_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_path_->clear();
  }
  clear_has_new_path();
}
inline const ::std::string& CopyWorkSpace::new_path() const {
  // @@protoc_insertion_point(field_get:blox.connect.CopyWorkSpace.new_path)
  return *new_path_;
}
inline void CopyWorkSpace::set_new_path(const ::std::string& value) {
  set_has_new_path();
  if (new_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_path_ = new ::std::string;
  }
  new_path_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CopyWorkSpace.new_path)
}
inline void CopyWorkSpace::set_new_path(const char* value) {
  set_has_new_path();
  if (new_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_path_ = new ::std::string;
  }
  new_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CopyWorkSpace.new_path)
}
inline void CopyWorkSpace::set_new_path(const char* value, size_t size) {
  set_has_new_path();
  if (new_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_path_ = new ::std::string;
  }
  new_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CopyWorkSpace.new_path)
}
inline ::std::string* CopyWorkSpace::mutable_new_path() {
  set_has_new_path();
  if (new_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CopyWorkSpace.new_path)
  return new_path_;
}
inline ::std::string* CopyWorkSpace::release_new_path() {
  clear_has_new_path();
  if (new_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = new_path_;
    new_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CopyWorkSpace::set_allocated_new_path(::std::string* new_path) {
  if (new_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete new_path_;
  }
  if (new_path) {
    set_has_new_path();
    new_path_ = new_path;
  } else {
    clear_has_new_path();
    new_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CopyWorkSpace.new_path)
}

// -------------------------------------------------------------------

// CopyWorkSpaceResponse

// optional string path = 1;
inline bool CopyWorkSpaceResponse::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CopyWorkSpaceResponse::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CopyWorkSpaceResponse::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CopyWorkSpaceResponse::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& CopyWorkSpaceResponse::path() const {
  // @@protoc_insertion_point(field_get:blox.connect.CopyWorkSpaceResponse.path)
  return *path_;
}
inline void CopyWorkSpaceResponse::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CopyWorkSpaceResponse.path)
}
inline void CopyWorkSpaceResponse::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CopyWorkSpaceResponse.path)
}
inline void CopyWorkSpaceResponse::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CopyWorkSpaceResponse.path)
}
inline ::std::string* CopyWorkSpaceResponse::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CopyWorkSpaceResponse.path)
  return path_;
}
inline ::std::string* CopyWorkSpaceResponse::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CopyWorkSpaceResponse::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CopyWorkSpaceResponse.path)
}

// -------------------------------------------------------------------

// DeleteWorkSpace

// required string name = 1;
inline bool DeleteWorkSpace::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteWorkSpace::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteWorkSpace::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteWorkSpace::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DeleteWorkSpace::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.DeleteWorkSpace.name)
  return *name_;
}
inline void DeleteWorkSpace::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.DeleteWorkSpace.name)
}
inline void DeleteWorkSpace::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.DeleteWorkSpace.name)
}
inline void DeleteWorkSpace::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.DeleteWorkSpace.name)
}
inline ::std::string* DeleteWorkSpace::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.DeleteWorkSpace.name)
  return name_;
}
inline ::std::string* DeleteWorkSpace::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteWorkSpace::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.DeleteWorkSpace.name)
}

// optional bool ignore_nonexistent = 2;
inline bool DeleteWorkSpace::has_ignore_nonexistent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteWorkSpace::set_has_ignore_nonexistent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteWorkSpace::clear_has_ignore_nonexistent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteWorkSpace::clear_ignore_nonexistent() {
  ignore_nonexistent_ = false;
  clear_has_ignore_nonexistent();
}
inline bool DeleteWorkSpace::ignore_nonexistent() const {
  // @@protoc_insertion_point(field_get:blox.connect.DeleteWorkSpace.ignore_nonexistent)
  return ignore_nonexistent_;
}
inline void DeleteWorkSpace::set_ignore_nonexistent(bool value) {
  set_has_ignore_nonexistent();
  ignore_nonexistent_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.DeleteWorkSpace.ignore_nonexistent)
}

// -------------------------------------------------------------------

// DeleteWorkSpaceResponse

// -------------------------------------------------------------------

// ImportWorkSpace

// required string src_filepath = 1;
inline bool ImportWorkSpace::has_src_filepath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImportWorkSpace::set_has_src_filepath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImportWorkSpace::clear_has_src_filepath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImportWorkSpace::clear_src_filepath() {
  if (src_filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_filepath_->clear();
  }
  clear_has_src_filepath();
}
inline const ::std::string& ImportWorkSpace::src_filepath() const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpace.src_filepath)
  return *src_filepath_;
}
inline void ImportWorkSpace::set_src_filepath(const ::std::string& value) {
  set_has_src_filepath();
  if (src_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_filepath_ = new ::std::string;
  }
  src_filepath_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ImportWorkSpace.src_filepath)
}
inline void ImportWorkSpace::set_src_filepath(const char* value) {
  set_has_src_filepath();
  if (src_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_filepath_ = new ::std::string;
  }
  src_filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ImportWorkSpace.src_filepath)
}
inline void ImportWorkSpace::set_src_filepath(const char* value, size_t size) {
  set_has_src_filepath();
  if (src_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_filepath_ = new ::std::string;
  }
  src_filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ImportWorkSpace.src_filepath)
}
inline ::std::string* ImportWorkSpace::mutable_src_filepath() {
  set_has_src_filepath();
  if (src_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    src_filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportWorkSpace.src_filepath)
  return src_filepath_;
}
inline ::std::string* ImportWorkSpace::release_src_filepath() {
  clear_has_src_filepath();
  if (src_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = src_filepath_;
    src_filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImportWorkSpace::set_allocated_src_filepath(::std::string* src_filepath) {
  if (src_filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete src_filepath_;
  }
  if (src_filepath) {
    set_has_src_filepath();
    src_filepath_ = src_filepath;
  } else {
    clear_has_src_filepath();
    src_filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ImportWorkSpace.src_filepath)
}

// optional string name = 2;
inline bool ImportWorkSpace::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImportWorkSpace::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImportWorkSpace::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImportWorkSpace::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ImportWorkSpace::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpace.name)
  return *name_;
}
inline void ImportWorkSpace::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ImportWorkSpace.name)
}
inline void ImportWorkSpace::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ImportWorkSpace.name)
}
inline void ImportWorkSpace::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ImportWorkSpace.name)
}
inline ::std::string* ImportWorkSpace::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportWorkSpace.name)
  return name_;
}
inline ::std::string* ImportWorkSpace::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImportWorkSpace::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ImportWorkSpace.name)
}

// optional bool overwrite = 3;
inline bool ImportWorkSpace::has_overwrite() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImportWorkSpace::set_has_overwrite() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImportWorkSpace::clear_has_overwrite() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImportWorkSpace::clear_overwrite() {
  overwrite_ = false;
  clear_has_overwrite();
}
inline bool ImportWorkSpace::overwrite() const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpace.overwrite)
  return overwrite_;
}
inline void ImportWorkSpace::set_overwrite(bool value) {
  set_has_overwrite();
  overwrite_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.ImportWorkSpace.overwrite)
}

// optional bool unique = 4;
inline bool ImportWorkSpace::has_unique() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImportWorkSpace::set_has_unique() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImportWorkSpace::clear_has_unique() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImportWorkSpace::clear_unique() {
  unique_ = false;
  clear_has_unique();
}
inline bool ImportWorkSpace::unique() const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpace.unique)
  return unique_;
}
inline void ImportWorkSpace::set_unique(bool value) {
  set_has_unique();
  unique_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.ImportWorkSpace.unique)
}

// repeated .blox.connect.Command command = 5;
inline int ImportWorkSpace::command_size() const {
  return command_.size();
}
inline void ImportWorkSpace::clear_command() {
  command_.Clear();
}
inline const ::blox::connect::Command& ImportWorkSpace::command(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpace.command)
  return command_.Get(index);
}
inline ::blox::connect::Command* ImportWorkSpace::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportWorkSpace.command)
  return command_.Mutable(index);
}
inline ::blox::connect::Command* ImportWorkSpace::add_command() {
  // @@protoc_insertion_point(field_add:blox.connect.ImportWorkSpace.command)
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
ImportWorkSpace::command() const {
  // @@protoc_insertion_point(field_list:blox.connect.ImportWorkSpace.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
ImportWorkSpace::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ImportWorkSpace.command)
  return &command_;
}

// repeated .blox.connect.Command command_after_fixpoint = 6;
inline int ImportWorkSpace::command_after_fixpoint_size() const {
  return command_after_fixpoint_.size();
}
inline void ImportWorkSpace::clear_command_after_fixpoint() {
  command_after_fixpoint_.Clear();
}
inline const ::blox::connect::Command& ImportWorkSpace::command_after_fixpoint(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpace.command_after_fixpoint)
  return command_after_fixpoint_.Get(index);
}
inline ::blox::connect::Command* ImportWorkSpace::mutable_command_after_fixpoint(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportWorkSpace.command_after_fixpoint)
  return command_after_fixpoint_.Mutable(index);
}
inline ::blox::connect::Command* ImportWorkSpace::add_command_after_fixpoint() {
  // @@protoc_insertion_point(field_add:blox.connect.ImportWorkSpace.command_after_fixpoint)
  return command_after_fixpoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >&
ImportWorkSpace::command_after_fixpoint() const {
  // @@protoc_insertion_point(field_list:blox.connect.ImportWorkSpace.command_after_fixpoint)
  return command_after_fixpoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Command >*
ImportWorkSpace::mutable_command_after_fixpoint() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ImportWorkSpace.command_after_fixpoint)
  return &command_after_fixpoint_;
}

// -------------------------------------------------------------------

// ImportWorkSpaceResponse

// required string name = 1;
inline bool ImportWorkSpaceResponse::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImportWorkSpaceResponse::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImportWorkSpaceResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImportWorkSpaceResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ImportWorkSpaceResponse::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpaceResponse.name)
  return *name_;
}
inline void ImportWorkSpaceResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ImportWorkSpaceResponse.name)
}
inline void ImportWorkSpaceResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ImportWorkSpaceResponse.name)
}
inline void ImportWorkSpaceResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ImportWorkSpaceResponse.name)
}
inline ::std::string* ImportWorkSpaceResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportWorkSpaceResponse.name)
  return name_;
}
inline ::std::string* ImportWorkSpaceResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImportWorkSpaceResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ImportWorkSpaceResponse.name)
}

// required string filepath = 2;
inline bool ImportWorkSpaceResponse::has_filepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImportWorkSpaceResponse::set_has_filepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImportWorkSpaceResponse::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImportWorkSpaceResponse::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& ImportWorkSpaceResponse::filepath() const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpaceResponse.filepath)
  return *filepath_;
}
inline void ImportWorkSpaceResponse::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ImportWorkSpaceResponse.filepath)
}
inline void ImportWorkSpaceResponse::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ImportWorkSpaceResponse.filepath)
}
inline void ImportWorkSpaceResponse::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ImportWorkSpaceResponse.filepath)
}
inline ::std::string* ImportWorkSpaceResponse::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportWorkSpaceResponse.filepath)
  return filepath_;
}
inline ::std::string* ImportWorkSpaceResponse::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImportWorkSpaceResponse::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ImportWorkSpaceResponse.filepath)
}

// repeated .blox.connect.CommandResponse command = 3;
inline int ImportWorkSpaceResponse::command_size() const {
  return command_.size();
}
inline void ImportWorkSpaceResponse::clear_command() {
  command_.Clear();
}
inline const ::blox::connect::CommandResponse& ImportWorkSpaceResponse::command(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpaceResponse.command)
  return command_.Get(index);
}
inline ::blox::connect::CommandResponse* ImportWorkSpaceResponse::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportWorkSpaceResponse.command)
  return command_.Mutable(index);
}
inline ::blox::connect::CommandResponse* ImportWorkSpaceResponse::add_command() {
  // @@protoc_insertion_point(field_add:blox.connect.ImportWorkSpaceResponse.command)
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
ImportWorkSpaceResponse::command() const {
  // @@protoc_insertion_point(field_list:blox.connect.ImportWorkSpaceResponse.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
ImportWorkSpaceResponse::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ImportWorkSpaceResponse.command)
  return &command_;
}

// repeated .blox.connect.CommandResponse command_after_fixpoint = 4;
inline int ImportWorkSpaceResponse::command_after_fixpoint_size() const {
  return command_after_fixpoint_.size();
}
inline void ImportWorkSpaceResponse::clear_command_after_fixpoint() {
  command_after_fixpoint_.Clear();
}
inline const ::blox::connect::CommandResponse& ImportWorkSpaceResponse::command_after_fixpoint(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportWorkSpaceResponse.command_after_fixpoint)
  return command_after_fixpoint_.Get(index);
}
inline ::blox::connect::CommandResponse* ImportWorkSpaceResponse::mutable_command_after_fixpoint(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportWorkSpaceResponse.command_after_fixpoint)
  return command_after_fixpoint_.Mutable(index);
}
inline ::blox::connect::CommandResponse* ImportWorkSpaceResponse::add_command_after_fixpoint() {
  // @@protoc_insertion_point(field_add:blox.connect.ImportWorkSpaceResponse.command_after_fixpoint)
  return command_after_fixpoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >&
ImportWorkSpaceResponse::command_after_fixpoint() const {
  // @@protoc_insertion_point(field_list:blox.connect.ImportWorkSpaceResponse.command_after_fixpoint)
  return command_after_fixpoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::CommandResponse >*
ImportWorkSpaceResponse::mutable_command_after_fixpoint() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ImportWorkSpaceResponse.command_after_fixpoint)
  return &command_after_fixpoint_;
}

// -------------------------------------------------------------------

// ExportWorkSpace

// required string name = 1;
inline bool ExportWorkSpace::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExportWorkSpace::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExportWorkSpace::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExportWorkSpace::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ExportWorkSpace::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExportWorkSpace.name)
  return *name_;
}
inline void ExportWorkSpace::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExportWorkSpace.name)
}
inline void ExportWorkSpace::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExportWorkSpace.name)
}
inline void ExportWorkSpace::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExportWorkSpace.name)
}
inline ::std::string* ExportWorkSpace::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExportWorkSpace.name)
  return name_;
}
inline ::std::string* ExportWorkSpace::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExportWorkSpace::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExportWorkSpace.name)
}

// required string dest_filepath = 2;
inline bool ExportWorkSpace::has_dest_filepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExportWorkSpace::set_has_dest_filepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExportWorkSpace::clear_has_dest_filepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExportWorkSpace::clear_dest_filepath() {
  if (dest_filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_filepath_->clear();
  }
  clear_has_dest_filepath();
}
inline const ::std::string& ExportWorkSpace::dest_filepath() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExportWorkSpace.dest_filepath)
  return *dest_filepath_;
}
inline void ExportWorkSpace::set_dest_filepath(const ::std::string& value) {
  set_has_dest_filepath();
  if (dest_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_filepath_ = new ::std::string;
  }
  dest_filepath_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExportWorkSpace.dest_filepath)
}
inline void ExportWorkSpace::set_dest_filepath(const char* value) {
  set_has_dest_filepath();
  if (dest_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_filepath_ = new ::std::string;
  }
  dest_filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExportWorkSpace.dest_filepath)
}
inline void ExportWorkSpace::set_dest_filepath(const char* value, size_t size) {
  set_has_dest_filepath();
  if (dest_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_filepath_ = new ::std::string;
  }
  dest_filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExportWorkSpace.dest_filepath)
}
inline ::std::string* ExportWorkSpace::mutable_dest_filepath() {
  set_has_dest_filepath();
  if (dest_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExportWorkSpace.dest_filepath)
  return dest_filepath_;
}
inline ::std::string* ExportWorkSpace::release_dest_filepath() {
  clear_has_dest_filepath();
  if (dest_filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dest_filepath_;
    dest_filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExportWorkSpace::set_allocated_dest_filepath(::std::string* dest_filepath) {
  if (dest_filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dest_filepath_;
  }
  if (dest_filepath) {
    set_has_dest_filepath();
    dest_filepath_ = dest_filepath;
  } else {
    clear_has_dest_filepath();
    dest_filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExportWorkSpace.dest_filepath)
}

// optional bool overwrite = 5;
inline bool ExportWorkSpace::has_overwrite() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExportWorkSpace::set_has_overwrite() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExportWorkSpace::clear_has_overwrite() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExportWorkSpace::clear_overwrite() {
  overwrite_ = false;
  clear_has_overwrite();
}
inline bool ExportWorkSpace::overwrite() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExportWorkSpace.overwrite)
  return overwrite_;
}
inline void ExportWorkSpace::set_overwrite(bool value) {
  set_has_overwrite();
  overwrite_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.ExportWorkSpace.overwrite)
}

// -------------------------------------------------------------------

// ExportWorkSpaceResponse

// -------------------------------------------------------------------

// GetWorkSpacePath

// required string name = 1;
inline bool GetWorkSpacePath::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetWorkSpacePath::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetWorkSpacePath::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetWorkSpacePath::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GetWorkSpacePath::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkSpacePath.name)
  return *name_;
}
inline void GetWorkSpacePath::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkSpacePath.name)
}
inline void GetWorkSpacePath::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkSpacePath.name)
}
inline void GetWorkSpacePath::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkSpacePath.name)
}
inline ::std::string* GetWorkSpacePath::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkSpacePath.name)
  return name_;
}
inline ::std::string* GetWorkSpacePath::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkSpacePath::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkSpacePath.name)
}

// optional bool inverse = 2 [default = false];
inline bool GetWorkSpacePath::has_inverse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetWorkSpacePath::set_has_inverse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetWorkSpacePath::clear_has_inverse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetWorkSpacePath::clear_inverse() {
  inverse_ = false;
  clear_has_inverse();
}
inline bool GetWorkSpacePath::inverse() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkSpacePath.inverse)
  return inverse_;
}
inline void GetWorkSpacePath::set_inverse(bool value) {
  set_has_inverse();
  inverse_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkSpacePath.inverse)
}

// -------------------------------------------------------------------

// GetWorkSpacePathResponse

// required string filepath = 1;
inline bool GetWorkSpacePathResponse::has_filepath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetWorkSpacePathResponse::set_has_filepath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetWorkSpacePathResponse::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetWorkSpacePathResponse::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& GetWorkSpacePathResponse::filepath() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkSpacePathResponse.filepath)
  return *filepath_;
}
inline void GetWorkSpacePathResponse::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkSpacePathResponse.filepath)
}
inline void GetWorkSpacePathResponse::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkSpacePathResponse.filepath)
}
inline void GetWorkSpacePathResponse::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkSpacePathResponse.filepath)
}
inline ::std::string* GetWorkSpacePathResponse::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkSpacePathResponse.filepath)
  return filepath_;
}
inline ::std::string* GetWorkSpacePathResponse::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkSpacePathResponse::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkSpacePathResponse.filepath)
}

// -------------------------------------------------------------------

// GetWorkSpaceVersion

// required string name = 1;
inline bool GetWorkSpaceVersion::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetWorkSpaceVersion::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetWorkSpaceVersion::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetWorkSpaceVersion::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GetWorkSpaceVersion::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkSpaceVersion.name)
  return *name_;
}
inline void GetWorkSpaceVersion::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkSpaceVersion.name)
}
inline void GetWorkSpaceVersion::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkSpaceVersion.name)
}
inline void GetWorkSpaceVersion::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkSpaceVersion.name)
}
inline ::std::string* GetWorkSpaceVersion::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkSpaceVersion.name)
  return name_;
}
inline ::std::string* GetWorkSpaceVersion::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkSpaceVersion::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkSpaceVersion.name)
}

// -------------------------------------------------------------------

// GetWorkSpaceVersionResponse

// required string version = 2;
inline bool GetWorkSpaceVersionResponse::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetWorkSpaceVersionResponse::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetWorkSpaceVersionResponse::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetWorkSpaceVersionResponse::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GetWorkSpaceVersionResponse::version() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkSpaceVersionResponse.version)
  return *version_;
}
inline void GetWorkSpaceVersionResponse::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkSpaceVersionResponse.version)
}
inline void GetWorkSpaceVersionResponse::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkSpaceVersionResponse.version)
}
inline void GetWorkSpaceVersionResponse::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkSpaceVersionResponse.version)
}
inline ::std::string* GetWorkSpaceVersionResponse::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkSpaceVersionResponse.version)
  return version_;
}
inline ::std::string* GetWorkSpaceVersionResponse::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkSpaceVersionResponse::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkSpaceVersionResponse.version)
}

// optional string minor_version = 3;
inline bool GetWorkSpaceVersionResponse::has_minor_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetWorkSpaceVersionResponse::set_has_minor_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetWorkSpaceVersionResponse::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetWorkSpaceVersionResponse::clear_minor_version() {
  if (minor_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    minor_version_->clear();
  }
  clear_has_minor_version();
}
inline const ::std::string& GetWorkSpaceVersionResponse::minor_version() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkSpaceVersionResponse.minor_version)
  return *minor_version_;
}
inline void GetWorkSpaceVersionResponse::set_minor_version(const ::std::string& value) {
  set_has_minor_version();
  if (minor_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    minor_version_ = new ::std::string;
  }
  minor_version_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkSpaceVersionResponse.minor_version)
}
inline void GetWorkSpaceVersionResponse::set_minor_version(const char* value) {
  set_has_minor_version();
  if (minor_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    minor_version_ = new ::std::string;
  }
  minor_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkSpaceVersionResponse.minor_version)
}
inline void GetWorkSpaceVersionResponse::set_minor_version(const char* value, size_t size) {
  set_has_minor_version();
  if (minor_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    minor_version_ = new ::std::string;
  }
  minor_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkSpaceVersionResponse.minor_version)
}
inline ::std::string* GetWorkSpaceVersionResponse::mutable_minor_version() {
  set_has_minor_version();
  if (minor_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    minor_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkSpaceVersionResponse.minor_version)
  return minor_version_;
}
inline ::std::string* GetWorkSpaceVersionResponse::release_minor_version() {
  clear_has_minor_version();
  if (minor_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = minor_version_;
    minor_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkSpaceVersionResponse::set_allocated_minor_version(::std::string* minor_version) {
  if (minor_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete minor_version_;
  }
  if (minor_version) {
    set_has_minor_version();
    minor_version_ = minor_version;
  } else {
    clear_has_minor_version();
    minor_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkSpaceVersionResponse.minor_version)
}

// required string build_number = 1;
inline bool GetWorkSpaceVersionResponse::has_build_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetWorkSpaceVersionResponse::set_has_build_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetWorkSpaceVersionResponse::clear_has_build_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetWorkSpaceVersionResponse::clear_build_number() {
  if (build_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_number_->clear();
  }
  clear_has_build_number();
}
inline const ::std::string& GetWorkSpaceVersionResponse::build_number() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkSpaceVersionResponse.build_number)
  return *build_number_;
}
inline void GetWorkSpaceVersionResponse::set_build_number(const ::std::string& value) {
  set_has_build_number();
  if (build_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_number_ = new ::std::string;
  }
  build_number_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkSpaceVersionResponse.build_number)
}
inline void GetWorkSpaceVersionResponse::set_build_number(const char* value) {
  set_has_build_number();
  if (build_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_number_ = new ::std::string;
  }
  build_number_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkSpaceVersionResponse.build_number)
}
inline void GetWorkSpaceVersionResponse::set_build_number(const char* value, size_t size) {
  set_has_build_number();
  if (build_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_number_ = new ::std::string;
  }
  build_number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkSpaceVersionResponse.build_number)
}
inline ::std::string* GetWorkSpaceVersionResponse::mutable_build_number() {
  set_has_build_number();
  if (build_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkSpaceVersionResponse.build_number)
  return build_number_;
}
inline ::std::string* GetWorkSpaceVersionResponse::release_build_number() {
  clear_has_build_number();
  if (build_number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = build_number_;
    build_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkSpaceVersionResponse::set_allocated_build_number(::std::string* build_number) {
  if (build_number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete build_number_;
  }
  if (build_number) {
    set_has_build_number();
    build_number_ = build_number;
  } else {
    clear_has_build_number();
    build_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkSpaceVersionResponse.build_number)
}

// -------------------------------------------------------------------

// CancelRequests

// repeated string req_guid = 1;
inline int CancelRequests::req_guid_size() const {
  return req_guid_.size();
}
inline void CancelRequests::clear_req_guid() {
  req_guid_.Clear();
}
inline const ::std::string& CancelRequests::req_guid(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.CancelRequests.req_guid)
  return req_guid_.Get(index);
}
inline ::std::string* CancelRequests::mutable_req_guid(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.CancelRequests.req_guid)
  return req_guid_.Mutable(index);
}
inline void CancelRequests::set_req_guid(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.CancelRequests.req_guid)
  req_guid_.Mutable(index)->assign(value);
}
inline void CancelRequests::set_req_guid(int index, const char* value) {
  req_guid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CancelRequests.req_guid)
}
inline void CancelRequests::set_req_guid(int index, const char* value, size_t size) {
  req_guid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CancelRequests.req_guid)
}
inline ::std::string* CancelRequests::add_req_guid() {
  return req_guid_.Add();
}
inline void CancelRequests::add_req_guid(const ::std::string& value) {
  req_guid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.CancelRequests.req_guid)
}
inline void CancelRequests::add_req_guid(const char* value) {
  req_guid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.CancelRequests.req_guid)
}
inline void CancelRequests::add_req_guid(const char* value, size_t size) {
  req_guid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.CancelRequests.req_guid)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CancelRequests::req_guid() const {
  // @@protoc_insertion_point(field_list:blox.connect.CancelRequests.req_guid)
  return req_guid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CancelRequests::mutable_req_guid() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.CancelRequests.req_guid)
  return &req_guid_;
}

// -------------------------------------------------------------------

// CancelRequestsResponse

// repeated string unknown_guids = 4;
inline int CancelRequestsResponse::unknown_guids_size() const {
  return unknown_guids_.size();
}
inline void CancelRequestsResponse::clear_unknown_guids() {
  unknown_guids_.Clear();
}
inline const ::std::string& CancelRequestsResponse::unknown_guids(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.CancelRequestsResponse.unknown_guids)
  return unknown_guids_.Get(index);
}
inline ::std::string* CancelRequestsResponse::mutable_unknown_guids(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.CancelRequestsResponse.unknown_guids)
  return unknown_guids_.Mutable(index);
}
inline void CancelRequestsResponse::set_unknown_guids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.CancelRequestsResponse.unknown_guids)
  unknown_guids_.Mutable(index)->assign(value);
}
inline void CancelRequestsResponse::set_unknown_guids(int index, const char* value) {
  unknown_guids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CancelRequestsResponse.unknown_guids)
}
inline void CancelRequestsResponse::set_unknown_guids(int index, const char* value, size_t size) {
  unknown_guids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CancelRequestsResponse.unknown_guids)
}
inline ::std::string* CancelRequestsResponse::add_unknown_guids() {
  return unknown_guids_.Add();
}
inline void CancelRequestsResponse::add_unknown_guids(const ::std::string& value) {
  unknown_guids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.CancelRequestsResponse.unknown_guids)
}
inline void CancelRequestsResponse::add_unknown_guids(const char* value) {
  unknown_guids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.CancelRequestsResponse.unknown_guids)
}
inline void CancelRequestsResponse::add_unknown_guids(const char* value, size_t size) {
  unknown_guids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.CancelRequestsResponse.unknown_guids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CancelRequestsResponse::unknown_guids() const {
  // @@protoc_insertion_point(field_list:blox.connect.CancelRequestsResponse.unknown_guids)
  return unknown_guids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CancelRequestsResponse::mutable_unknown_guids() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.CancelRequestsResponse.unknown_guids)
  return &unknown_guids_;
}

// -------------------------------------------------------------------

// AdminRequest

// optional string client_id = 1;
inline bool AdminRequest::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminRequest::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminRequest::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminRequest::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& AdminRequest::client_id() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminRequest.client_id)
  return *client_id_;
}
inline void AdminRequest::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AdminRequest.client_id)
}
inline void AdminRequest::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AdminRequest.client_id)
}
inline void AdminRequest::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AdminRequest.client_id)
}
inline ::std::string* AdminRequest::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminRequest.client_id)
  return client_id_;
}
inline ::std::string* AdminRequest::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdminRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminRequest.client_id)
}

// optional .blox.connect.ShutdownServer shutdown_server = 2;
inline bool AdminRequest::has_shutdown_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminRequest::set_has_shutdown_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminRequest::clear_has_shutdown_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminRequest::clear_shutdown_server() {
  if (shutdown_server_ != NULL) shutdown_server_->::blox::connect::ShutdownServer::Clear();
  clear_has_shutdown_server();
}
inline const ::blox::connect::ShutdownServer& AdminRequest::shutdown_server() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminRequest.shutdown_server)
  return shutdown_server_ != NULL ? *shutdown_server_ : *default_instance_->shutdown_server_;
}
inline ::blox::connect::ShutdownServer* AdminRequest::mutable_shutdown_server() {
  set_has_shutdown_server();
  if (shutdown_server_ == NULL) shutdown_server_ = new ::blox::connect::ShutdownServer;
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminRequest.shutdown_server)
  return shutdown_server_;
}
inline ::blox::connect::ShutdownServer* AdminRequest::release_shutdown_server() {
  clear_has_shutdown_server();
  ::blox::connect::ShutdownServer* temp = shutdown_server_;
  shutdown_server_ = NULL;
  return temp;
}
inline void AdminRequest::set_allocated_shutdown_server(::blox::connect::ShutdownServer* shutdown_server) {
  delete shutdown_server_;
  shutdown_server_ = shutdown_server;
  if (shutdown_server) {
    set_has_shutdown_server();
  } else {
    clear_has_shutdown_server();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminRequest.shutdown_server)
}

// optional .blox.connect.AbortTransaction abort_transaction = 4;
inline bool AdminRequest::has_abort_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdminRequest::set_has_abort_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdminRequest::clear_has_abort_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdminRequest::clear_abort_transaction() {
  if (abort_transaction_ != NULL) abort_transaction_->::blox::connect::AbortTransaction::Clear();
  clear_has_abort_transaction();
}
inline const ::blox::connect::AbortTransaction& AdminRequest::abort_transaction() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminRequest.abort_transaction)
  return abort_transaction_ != NULL ? *abort_transaction_ : *default_instance_->abort_transaction_;
}
inline ::blox::connect::AbortTransaction* AdminRequest::mutable_abort_transaction() {
  set_has_abort_transaction();
  if (abort_transaction_ == NULL) abort_transaction_ = new ::blox::connect::AbortTransaction;
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminRequest.abort_transaction)
  return abort_transaction_;
}
inline ::blox::connect::AbortTransaction* AdminRequest::release_abort_transaction() {
  clear_has_abort_transaction();
  ::blox::connect::AbortTransaction* temp = abort_transaction_;
  abort_transaction_ = NULL;
  return temp;
}
inline void AdminRequest::set_allocated_abort_transaction(::blox::connect::AbortTransaction* abort_transaction) {
  delete abort_transaction_;
  abort_transaction_ = abort_transaction;
  if (abort_transaction) {
    set_has_abort_transaction();
  } else {
    clear_has_abort_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminRequest.abort_transaction)
}

// optional bool list_workspaces = 6;
inline bool AdminRequest::has_list_workspaces() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdminRequest::set_has_list_workspaces() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdminRequest::clear_has_list_workspaces() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdminRequest::clear_list_workspaces() {
  list_workspaces_ = false;
  clear_has_list_workspaces();
}
inline bool AdminRequest::list_workspaces() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminRequest.list_workspaces)
  return list_workspaces_;
}
inline void AdminRequest::set_list_workspaces(bool value) {
  set_has_list_workspaces();
  list_workspaces_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.AdminRequest.list_workspaces)
}

// optional .blox.connect.StatusRequest status = 7;
inline bool AdminRequest::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdminRequest::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdminRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdminRequest::clear_status() {
  if (status_ != NULL) status_->::blox::connect::StatusRequest::Clear();
  clear_has_status();
}
inline const ::blox::connect::StatusRequest& AdminRequest::status() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminRequest.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::blox::connect::StatusRequest* AdminRequest::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::blox::connect::StatusRequest;
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminRequest.status)
  return status_;
}
inline ::blox::connect::StatusRequest* AdminRequest::release_status() {
  clear_has_status();
  ::blox::connect::StatusRequest* temp = status_;
  status_ = NULL;
  return temp;
}
inline void AdminRequest::set_allocated_status(::blox::connect::StatusRequest* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminRequest.status)
}

// optional string command = 8;
inline bool AdminRequest::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdminRequest::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdminRequest::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdminRequest::clear_command() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& AdminRequest::command() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminRequest.command)
  return *command_;
}
inline void AdminRequest::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AdminRequest.command)
}
inline void AdminRequest::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AdminRequest.command)
}
inline void AdminRequest::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AdminRequest.command)
}
inline ::std::string* AdminRequest::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminRequest.command)
  return command_;
}
inline ::std::string* AdminRequest::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdminRequest::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminRequest.command)
}

// optional string loglevel = 9;
inline bool AdminRequest::has_loglevel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdminRequest::set_has_loglevel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdminRequest::clear_has_loglevel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdminRequest::clear_loglevel() {
  if (loglevel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loglevel_->clear();
  }
  clear_has_loglevel();
}
inline const ::std::string& AdminRequest::loglevel() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminRequest.loglevel)
  return *loglevel_;
}
inline void AdminRequest::set_loglevel(const ::std::string& value) {
  set_has_loglevel();
  if (loglevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loglevel_ = new ::std::string;
  }
  loglevel_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AdminRequest.loglevel)
}
inline void AdminRequest::set_loglevel(const char* value) {
  set_has_loglevel();
  if (loglevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loglevel_ = new ::std::string;
  }
  loglevel_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AdminRequest.loglevel)
}
inline void AdminRequest::set_loglevel(const char* value, size_t size) {
  set_has_loglevel();
  if (loglevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loglevel_ = new ::std::string;
  }
  loglevel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AdminRequest.loglevel)
}
inline ::std::string* AdminRequest::mutable_loglevel() {
  set_has_loglevel();
  if (loglevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loglevel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminRequest.loglevel)
  return loglevel_;
}
inline ::std::string* AdminRequest::release_loglevel() {
  clear_has_loglevel();
  if (loglevel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loglevel_;
    loglevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdminRequest::set_allocated_loglevel(::std::string* loglevel) {
  if (loglevel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loglevel_;
  }
  if (loglevel) {
    set_has_loglevel();
    loglevel_ = loglevel;
  } else {
    clear_has_loglevel();
    loglevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminRequest.loglevel)
}

// -------------------------------------------------------------------

// AdminResponse

// optional string client_id = 1;
inline bool AdminResponse::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminResponse::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminResponse::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminResponse::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& AdminResponse::client_id() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminResponse.client_id)
  return *client_id_;
}
inline void AdminResponse::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AdminResponse.client_id)
}
inline void AdminResponse::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AdminResponse.client_id)
}
inline void AdminResponse::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AdminResponse.client_id)
}
inline ::std::string* AdminResponse::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminResponse.client_id)
  return client_id_;
}
inline ::std::string* AdminResponse::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdminResponse::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminResponse.client_id)
}

// optional .blox.connect.ExceptionContainer exception = 2;
inline bool AdminResponse::has_exception() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminResponse::set_has_exception() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminResponse::clear_has_exception() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminResponse::clear_exception() {
  if (exception_ != NULL) exception_->::blox::connect::ExceptionContainer::Clear();
  clear_has_exception();
}
inline const ::blox::connect::ExceptionContainer& AdminResponse::exception() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminResponse.exception)
  return exception_ != NULL ? *exception_ : *default_instance_->exception_;
}
inline ::blox::connect::ExceptionContainer* AdminResponse::mutable_exception() {
  set_has_exception();
  if (exception_ == NULL) exception_ = new ::blox::connect::ExceptionContainer;
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminResponse.exception)
  return exception_;
}
inline ::blox::connect::ExceptionContainer* AdminResponse::release_exception() {
  clear_has_exception();
  ::blox::connect::ExceptionContainer* temp = exception_;
  exception_ = NULL;
  return temp;
}
inline void AdminResponse::set_allocated_exception(::blox::connect::ExceptionContainer* exception) {
  delete exception_;
  exception_ = exception;
  if (exception) {
    set_has_exception();
  } else {
    clear_has_exception();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminResponse.exception)
}

// optional .blox.connect.ShutdownServerResponse shutdown_server = 3;
inline bool AdminResponse::has_shutdown_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdminResponse::set_has_shutdown_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdminResponse::clear_has_shutdown_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdminResponse::clear_shutdown_server() {
  if (shutdown_server_ != NULL) shutdown_server_->::blox::connect::ShutdownServerResponse::Clear();
  clear_has_shutdown_server();
}
inline const ::blox::connect::ShutdownServerResponse& AdminResponse::shutdown_server() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminResponse.shutdown_server)
  return shutdown_server_ != NULL ? *shutdown_server_ : *default_instance_->shutdown_server_;
}
inline ::blox::connect::ShutdownServerResponse* AdminResponse::mutable_shutdown_server() {
  set_has_shutdown_server();
  if (shutdown_server_ == NULL) shutdown_server_ = new ::blox::connect::ShutdownServerResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminResponse.shutdown_server)
  return shutdown_server_;
}
inline ::blox::connect::ShutdownServerResponse* AdminResponse::release_shutdown_server() {
  clear_has_shutdown_server();
  ::blox::connect::ShutdownServerResponse* temp = shutdown_server_;
  shutdown_server_ = NULL;
  return temp;
}
inline void AdminResponse::set_allocated_shutdown_server(::blox::connect::ShutdownServerResponse* shutdown_server) {
  delete shutdown_server_;
  shutdown_server_ = shutdown_server;
  if (shutdown_server) {
    set_has_shutdown_server();
  } else {
    clear_has_shutdown_server();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminResponse.shutdown_server)
}

// optional .blox.connect.AbortTransactionResponse abort_transaction = 5;
inline bool AdminResponse::has_abort_transaction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdminResponse::set_has_abort_transaction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdminResponse::clear_has_abort_transaction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdminResponse::clear_abort_transaction() {
  if (abort_transaction_ != NULL) abort_transaction_->::blox::connect::AbortTransactionResponse::Clear();
  clear_has_abort_transaction();
}
inline const ::blox::connect::AbortTransactionResponse& AdminResponse::abort_transaction() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminResponse.abort_transaction)
  return abort_transaction_ != NULL ? *abort_transaction_ : *default_instance_->abort_transaction_;
}
inline ::blox::connect::AbortTransactionResponse* AdminResponse::mutable_abort_transaction() {
  set_has_abort_transaction();
  if (abort_transaction_ == NULL) abort_transaction_ = new ::blox::connect::AbortTransactionResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminResponse.abort_transaction)
  return abort_transaction_;
}
inline ::blox::connect::AbortTransactionResponse* AdminResponse::release_abort_transaction() {
  clear_has_abort_transaction();
  ::blox::connect::AbortTransactionResponse* temp = abort_transaction_;
  abort_transaction_ = NULL;
  return temp;
}
inline void AdminResponse::set_allocated_abort_transaction(::blox::connect::AbortTransactionResponse* abort_transaction) {
  delete abort_transaction_;
  abort_transaction_ = abort_transaction;
  if (abort_transaction) {
    set_has_abort_transaction();
  } else {
    clear_has_abort_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminResponse.abort_transaction)
}

// optional .blox.connect.ListWorkSpacesResponse list_workspaces = 7;
inline bool AdminResponse::has_list_workspaces() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdminResponse::set_has_list_workspaces() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdminResponse::clear_has_list_workspaces() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdminResponse::clear_list_workspaces() {
  if (list_workspaces_ != NULL) list_workspaces_->::blox::connect::ListWorkSpacesResponse::Clear();
  clear_has_list_workspaces();
}
inline const ::blox::connect::ListWorkSpacesResponse& AdminResponse::list_workspaces() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminResponse.list_workspaces)
  return list_workspaces_ != NULL ? *list_workspaces_ : *default_instance_->list_workspaces_;
}
inline ::blox::connect::ListWorkSpacesResponse* AdminResponse::mutable_list_workspaces() {
  set_has_list_workspaces();
  if (list_workspaces_ == NULL) list_workspaces_ = new ::blox::connect::ListWorkSpacesResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminResponse.list_workspaces)
  return list_workspaces_;
}
inline ::blox::connect::ListWorkSpacesResponse* AdminResponse::release_list_workspaces() {
  clear_has_list_workspaces();
  ::blox::connect::ListWorkSpacesResponse* temp = list_workspaces_;
  list_workspaces_ = NULL;
  return temp;
}
inline void AdminResponse::set_allocated_list_workspaces(::blox::connect::ListWorkSpacesResponse* list_workspaces) {
  delete list_workspaces_;
  list_workspaces_ = list_workspaces;
  if (list_workspaces) {
    set_has_list_workspaces();
  } else {
    clear_has_list_workspaces();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminResponse.list_workspaces)
}

// optional .blox.connect.StatusResponse status = 8;
inline bool AdminResponse::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdminResponse::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdminResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdminResponse::clear_status() {
  if (status_ != NULL) status_->::blox::connect::StatusResponse::Clear();
  clear_has_status();
}
inline const ::blox::connect::StatusResponse& AdminResponse::status() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::blox::connect::StatusResponse* AdminResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::blox::connect::StatusResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminResponse.status)
  return status_;
}
inline ::blox::connect::StatusResponse* AdminResponse::release_status() {
  clear_has_status();
  ::blox::connect::StatusResponse* temp = status_;
  status_ = NULL;
  return temp;
}
inline void AdminResponse::set_allocated_status(::blox::connect::StatusResponse* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminResponse.status)
}

// optional string message = 9;
inline bool AdminResponse::has_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdminResponse::set_has_message() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdminResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdminResponse::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& AdminResponse::message() const {
  // @@protoc_insertion_point(field_get:blox.connect.AdminResponse.message)
  return *message_;
}
inline void AdminResponse::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AdminResponse.message)
}
inline void AdminResponse::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AdminResponse.message)
}
inline void AdminResponse::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AdminResponse.message)
}
inline ::std::string* AdminResponse::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AdminResponse.message)
  return message_;
}
inline ::std::string* AdminResponse::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdminResponse::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AdminResponse.message)
}

// -------------------------------------------------------------------

// ShutdownServer

// optional bool waitForProcesses = 1;
inline bool ShutdownServer::has_waitforprocesses() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShutdownServer::set_has_waitforprocesses() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShutdownServer::clear_has_waitforprocesses() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShutdownServer::clear_waitforprocesses() {
  waitforprocesses_ = false;
  clear_has_waitforprocesses();
}
inline bool ShutdownServer::waitforprocesses() const {
  // @@protoc_insertion_point(field_get:blox.connect.ShutdownServer.waitForProcesses)
  return waitforprocesses_;
}
inline void ShutdownServer::set_waitforprocesses(bool value) {
  set_has_waitforprocesses();
  waitforprocesses_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.ShutdownServer.waitForProcesses)
}

// -------------------------------------------------------------------

// ShutdownServerResponse

// optional string message = 1;
inline bool ShutdownServerResponse::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShutdownServerResponse::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShutdownServerResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShutdownServerResponse::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ShutdownServerResponse::message() const {
  // @@protoc_insertion_point(field_get:blox.connect.ShutdownServerResponse.message)
  return *message_;
}
inline void ShutdownServerResponse::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ShutdownServerResponse.message)
}
inline void ShutdownServerResponse::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ShutdownServerResponse.message)
}
inline void ShutdownServerResponse::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ShutdownServerResponse.message)
}
inline ::std::string* ShutdownServerResponse::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ShutdownServerResponse.message)
  return message_;
}
inline ::std::string* ShutdownServerResponse::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShutdownServerResponse::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ShutdownServerResponse.message)
}

// -------------------------------------------------------------------

// AbortTransaction

// optional string workspace = 1;
inline bool AbortTransaction::has_workspace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AbortTransaction::set_has_workspace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AbortTransaction::clear_has_workspace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AbortTransaction::clear_workspace() {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_->clear();
  }
  clear_has_workspace();
}
inline const ::std::string& AbortTransaction::workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.AbortTransaction.workspace)
  return *workspace_;
}
inline void AbortTransaction::set_workspace(const ::std::string& value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AbortTransaction.workspace)
}
inline void AbortTransaction::set_workspace(const char* value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AbortTransaction.workspace)
}
inline void AbortTransaction::set_workspace(const char* value, size_t size) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AbortTransaction.workspace)
}
inline ::std::string* AbortTransaction::mutable_workspace() {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AbortTransaction.workspace)
  return workspace_;
}
inline ::std::string* AbortTransaction::release_workspace() {
  clear_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workspace_;
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AbortTransaction::set_allocated_workspace(::std::string* workspace) {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workspace_;
  }
  if (workspace) {
    set_has_workspace();
    workspace_ = workspace;
  } else {
    clear_has_workspace();
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AbortTransaction.workspace)
}

// required string tid = 2;
inline bool AbortTransaction::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AbortTransaction::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AbortTransaction::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AbortTransaction::clear_tid() {
  if (tid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tid_->clear();
  }
  clear_has_tid();
}
inline const ::std::string& AbortTransaction::tid() const {
  // @@protoc_insertion_point(field_get:blox.connect.AbortTransaction.tid)
  return *tid_;
}
inline void AbortTransaction::set_tid(const ::std::string& value) {
  set_has_tid();
  if (tid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tid_ = new ::std::string;
  }
  tid_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AbortTransaction.tid)
}
inline void AbortTransaction::set_tid(const char* value) {
  set_has_tid();
  if (tid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tid_ = new ::std::string;
  }
  tid_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AbortTransaction.tid)
}
inline void AbortTransaction::set_tid(const char* value, size_t size) {
  set_has_tid();
  if (tid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tid_ = new ::std::string;
  }
  tid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AbortTransaction.tid)
}
inline ::std::string* AbortTransaction::mutable_tid() {
  set_has_tid();
  if (tid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AbortTransaction.tid)
  return tid_;
}
inline ::std::string* AbortTransaction::release_tid() {
  clear_has_tid();
  if (tid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tid_;
    tid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AbortTransaction::set_allocated_tid(::std::string* tid) {
  if (tid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tid_;
  }
  if (tid) {
    set_has_tid();
    tid_ = tid;
  } else {
    clear_has_tid();
    tid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AbortTransaction.tid)
}

// -------------------------------------------------------------------

// AbortTransactionResponse

// optional string message = 1;
inline bool AbortTransactionResponse::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AbortTransactionResponse::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AbortTransactionResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AbortTransactionResponse::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& AbortTransactionResponse::message() const {
  // @@protoc_insertion_point(field_get:blox.connect.AbortTransactionResponse.message)
  return *message_;
}
inline void AbortTransactionResponse::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AbortTransactionResponse.message)
}
inline void AbortTransactionResponse::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AbortTransactionResponse.message)
}
inline void AbortTransactionResponse::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AbortTransactionResponse.message)
}
inline ::std::string* AbortTransactionResponse::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AbortTransactionResponse.message)
  return message_;
}
inline ::std::string* AbortTransactionResponse::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AbortTransactionResponse::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AbortTransactionResponse.message)
}

// -------------------------------------------------------------------

// ListWorkSpaces

// -------------------------------------------------------------------

// ListWorkSpacesResponse

// repeated string name = 1;
inline int ListWorkSpacesResponse::name_size() const {
  return name_.size();
}
inline void ListWorkSpacesResponse::clear_name() {
  name_.Clear();
}
inline const ::std::string& ListWorkSpacesResponse::name(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ListWorkSpacesResponse.name)
  return name_.Get(index);
}
inline ::std::string* ListWorkSpacesResponse::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ListWorkSpacesResponse.name)
  return name_.Mutable(index);
}
inline void ListWorkSpacesResponse::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.ListWorkSpacesResponse.name)
  name_.Mutable(index)->assign(value);
}
inline void ListWorkSpacesResponse::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ListWorkSpacesResponse.name)
}
inline void ListWorkSpacesResponse::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ListWorkSpacesResponse.name)
}
inline ::std::string* ListWorkSpacesResponse::add_name() {
  return name_.Add();
}
inline void ListWorkSpacesResponse::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.ListWorkSpacesResponse.name)
}
inline void ListWorkSpacesResponse::add_name(const char* value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.ListWorkSpacesResponse.name)
}
inline void ListWorkSpacesResponse::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.ListWorkSpacesResponse.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListWorkSpacesResponse::name() const {
  // @@protoc_insertion_point(field_list:blox.connect.ListWorkSpacesResponse.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListWorkSpacesResponse::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ListWorkSpacesResponse.name)
  return &name_;
}

// -------------------------------------------------------------------

// StatusRequest

// repeated string workspaces = 1;
inline int StatusRequest::workspaces_size() const {
  return workspaces_.size();
}
inline void StatusRequest::clear_workspaces() {
  workspaces_.Clear();
}
inline const ::std::string& StatusRequest::workspaces(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.StatusRequest.workspaces)
  return workspaces_.Get(index);
}
inline ::std::string* StatusRequest::mutable_workspaces(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.StatusRequest.workspaces)
  return workspaces_.Mutable(index);
}
inline void StatusRequest::set_workspaces(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.StatusRequest.workspaces)
  workspaces_.Mutable(index)->assign(value);
}
inline void StatusRequest::set_workspaces(int index, const char* value) {
  workspaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.StatusRequest.workspaces)
}
inline void StatusRequest::set_workspaces(int index, const char* value, size_t size) {
  workspaces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.StatusRequest.workspaces)
}
inline ::std::string* StatusRequest::add_workspaces() {
  return workspaces_.Add();
}
inline void StatusRequest::add_workspaces(const ::std::string& value) {
  workspaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.StatusRequest.workspaces)
}
inline void StatusRequest::add_workspaces(const char* value) {
  workspaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.StatusRequest.workspaces)
}
inline void StatusRequest::add_workspaces(const char* value, size_t size) {
  workspaces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.StatusRequest.workspaces)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StatusRequest::workspaces() const {
  // @@protoc_insertion_point(field_list:blox.connect.StatusRequest.workspaces)
  return workspaces_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StatusRequest::mutable_workspaces() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.StatusRequest.workspaces)
  return &workspaces_;
}

// optional bool show_active_requests = 2 [default = false];
inline bool StatusRequest::has_show_active_requests() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusRequest::set_has_show_active_requests() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusRequest::clear_has_show_active_requests() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusRequest::clear_show_active_requests() {
  show_active_requests_ = false;
  clear_has_show_active_requests();
}
inline bool StatusRequest::show_active_requests() const {
  // @@protoc_insertion_point(field_get:blox.connect.StatusRequest.show_active_requests)
  return show_active_requests_;
}
inline void StatusRequest::set_show_active_requests(bool value) {
  set_has_show_active_requests();
  show_active_requests_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.StatusRequest.show_active_requests)
}

// optional bool show_queued_requests = 3 [default = false];
inline bool StatusRequest::has_show_queued_requests() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusRequest::set_has_show_queued_requests() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusRequest::clear_has_show_queued_requests() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusRequest::clear_show_queued_requests() {
  show_queued_requests_ = false;
  clear_has_show_queued_requests();
}
inline bool StatusRequest::show_queued_requests() const {
  // @@protoc_insertion_point(field_get:blox.connect.StatusRequest.show_queued_requests)
  return show_queued_requests_;
}
inline void StatusRequest::set_show_queued_requests(bool value) {
  set_has_show_queued_requests();
  show_queued_requests_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.StatusRequest.show_queued_requests)
}

// optional bool add_debug_info = 99 [default = false];
inline bool StatusRequest::has_add_debug_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatusRequest::set_has_add_debug_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatusRequest::clear_has_add_debug_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatusRequest::clear_add_debug_info() {
  add_debug_info_ = false;
  clear_has_add_debug_info();
}
inline bool StatusRequest::add_debug_info() const {
  // @@protoc_insertion_point(field_get:blox.connect.StatusRequest.add_debug_info)
  return add_debug_info_;
}
inline void StatusRequest::set_add_debug_info(bool value) {
  set_has_add_debug_info();
  add_debug_info_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.StatusRequest.add_debug_info)
}

// -------------------------------------------------------------------

// StatusResponse

// repeated .blox.connect.WorkspaceStatus workspaces = 1;
inline int StatusResponse::workspaces_size() const {
  return workspaces_.size();
}
inline void StatusResponse::clear_workspaces() {
  workspaces_.Clear();
}
inline const ::blox::connect::WorkspaceStatus& StatusResponse::workspaces(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.StatusResponse.workspaces)
  return workspaces_.Get(index);
}
inline ::blox::connect::WorkspaceStatus* StatusResponse::mutable_workspaces(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.StatusResponse.workspaces)
  return workspaces_.Mutable(index);
}
inline ::blox::connect::WorkspaceStatus* StatusResponse::add_workspaces() {
  // @@protoc_insertion_point(field_add:blox.connect.StatusResponse.workspaces)
  return workspaces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkspaceStatus >&
StatusResponse::workspaces() const {
  // @@protoc_insertion_point(field_list:blox.connect.StatusResponse.workspaces)
  return workspaces_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkspaceStatus >*
StatusResponse::mutable_workspaces() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.StatusResponse.workspaces)
  return &workspaces_;
}

// repeated string debug_info = 99;
inline int StatusResponse::debug_info_size() const {
  return debug_info_.size();
}
inline void StatusResponse::clear_debug_info() {
  debug_info_.Clear();
}
inline const ::std::string& StatusResponse::debug_info(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.StatusResponse.debug_info)
  return debug_info_.Get(index);
}
inline ::std::string* StatusResponse::mutable_debug_info(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.StatusResponse.debug_info)
  return debug_info_.Mutable(index);
}
inline void StatusResponse::set_debug_info(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.StatusResponse.debug_info)
  debug_info_.Mutable(index)->assign(value);
}
inline void StatusResponse::set_debug_info(int index, const char* value) {
  debug_info_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.StatusResponse.debug_info)
}
inline void StatusResponse::set_debug_info(int index, const char* value, size_t size) {
  debug_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.StatusResponse.debug_info)
}
inline ::std::string* StatusResponse::add_debug_info() {
  return debug_info_.Add();
}
inline void StatusResponse::add_debug_info(const ::std::string& value) {
  debug_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.StatusResponse.debug_info)
}
inline void StatusResponse::add_debug_info(const char* value) {
  debug_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.StatusResponse.debug_info)
}
inline void StatusResponse::add_debug_info(const char* value, size_t size) {
  debug_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.StatusResponse.debug_info)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StatusResponse::debug_info() const {
  // @@protoc_insertion_point(field_list:blox.connect.StatusResponse.debug_info)
  return debug_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StatusResponse::mutable_debug_info() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.StatusResponse.debug_info)
  return &debug_info_;
}

// -------------------------------------------------------------------

// WorkspaceStatus

// required string name = 1 [default = ""];
inline bool WorkspaceStatus::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkspaceStatus::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkspaceStatus::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkspaceStatus::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WorkspaceStatus::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.WorkspaceStatus.name)
  return *name_;
}
inline void WorkspaceStatus::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.WorkspaceStatus.name)
}
inline void WorkspaceStatus::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.WorkspaceStatus.name)
}
inline void WorkspaceStatus::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.WorkspaceStatus.name)
}
inline ::std::string* WorkspaceStatus::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.WorkspaceStatus.name)
  return name_;
}
inline ::std::string* WorkspaceStatus::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WorkspaceStatus::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.WorkspaceStatus.name)
}

// optional int32 num_requests = 2;
inline bool WorkspaceStatus::has_num_requests() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkspaceStatus::set_has_num_requests() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkspaceStatus::clear_has_num_requests() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkspaceStatus::clear_num_requests() {
  num_requests_ = 0;
  clear_has_num_requests();
}
inline ::google::protobuf::int32 WorkspaceStatus::num_requests() const {
  // @@protoc_insertion_point(field_get:blox.connect.WorkspaceStatus.num_requests)
  return num_requests_;
}
inline void WorkspaceStatus::set_num_requests(::google::protobuf::int32 value) {
  set_has_num_requests();
  num_requests_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.WorkspaceStatus.num_requests)
}

// repeated .blox.connect.RequestStatus requests = 3;
inline int WorkspaceStatus::requests_size() const {
  return requests_.size();
}
inline void WorkspaceStatus::clear_requests() {
  requests_.Clear();
}
inline const ::blox::connect::RequestStatus& WorkspaceStatus::requests(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.WorkspaceStatus.requests)
  return requests_.Get(index);
}
inline ::blox::connect::RequestStatus* WorkspaceStatus::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.WorkspaceStatus.requests)
  return requests_.Mutable(index);
}
inline ::blox::connect::RequestStatus* WorkspaceStatus::add_requests() {
  // @@protoc_insertion_point(field_add:blox.connect.WorkspaceStatus.requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::RequestStatus >&
WorkspaceStatus::requests() const {
  // @@protoc_insertion_point(field_list:blox.connect.WorkspaceStatus.requests)
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::RequestStatus >*
WorkspaceStatus::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.WorkspaceStatus.requests)
  return &requests_;
}

// repeated string debug_info = 99;
inline int WorkspaceStatus::debug_info_size() const {
  return debug_info_.size();
}
inline void WorkspaceStatus::clear_debug_info() {
  debug_info_.Clear();
}
inline const ::std::string& WorkspaceStatus::debug_info(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.WorkspaceStatus.debug_info)
  return debug_info_.Get(index);
}
inline ::std::string* WorkspaceStatus::mutable_debug_info(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.WorkspaceStatus.debug_info)
  return debug_info_.Mutable(index);
}
inline void WorkspaceStatus::set_debug_info(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.WorkspaceStatus.debug_info)
  debug_info_.Mutable(index)->assign(value);
}
inline void WorkspaceStatus::set_debug_info(int index, const char* value) {
  debug_info_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.WorkspaceStatus.debug_info)
}
inline void WorkspaceStatus::set_debug_info(int index, const char* value, size_t size) {
  debug_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.WorkspaceStatus.debug_info)
}
inline ::std::string* WorkspaceStatus::add_debug_info() {
  return debug_info_.Add();
}
inline void WorkspaceStatus::add_debug_info(const ::std::string& value) {
  debug_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.WorkspaceStatus.debug_info)
}
inline void WorkspaceStatus::add_debug_info(const char* value) {
  debug_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.WorkspaceStatus.debug_info)
}
inline void WorkspaceStatus::add_debug_info(const char* value, size_t size) {
  debug_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.WorkspaceStatus.debug_info)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WorkspaceStatus::debug_info() const {
  // @@protoc_insertion_point(field_list:blox.connect.WorkspaceStatus.debug_info)
  return debug_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WorkspaceStatus::mutable_debug_info() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.WorkspaceStatus.debug_info)
  return &debug_info_;
}

// -------------------------------------------------------------------

// RequestStatus

// optional .blox.connect.Request request = 1;
inline bool RequestStatus::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStatus::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStatus::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStatus::clear_request() {
  if (request_ != NULL) request_->::blox::connect::Request::Clear();
  clear_has_request();
}
inline const ::blox::connect::Request& RequestStatus::request() const {
  // @@protoc_insertion_point(field_get:blox.connect.RequestStatus.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::blox::connect::Request* RequestStatus::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::blox::connect::Request;
  // @@protoc_insertion_point(field_mutable:blox.connect.RequestStatus.request)
  return request_;
}
inline ::blox::connect::Request* RequestStatus::release_request() {
  clear_has_request();
  ::blox::connect::Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline void RequestStatus::set_allocated_request(::blox::connect::Request* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.RequestStatus.request)
}

// optional .blox.connect.RequestStatusEnum state = 2;
inline bool RequestStatus::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestStatus::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestStatus::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::blox::connect::RequestStatusEnum RequestStatus::state() const {
  // @@protoc_insertion_point(field_get:blox.connect.RequestStatus.state)
  return static_cast< ::blox::connect::RequestStatusEnum >(state_);
}
inline void RequestStatus::set_state(::blox::connect::RequestStatusEnum value) {
  assert(::blox::connect::RequestStatusEnum_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.RequestStatus.state)
}

// optional int64 request_id = 3;
inline bool RequestStatus::has_request_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestStatus::set_has_request_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestStatus::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestStatus::clear_request_id() {
  request_id_ = GOOGLE_LONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::int64 RequestStatus::request_id() const {
  // @@protoc_insertion_point(field_get:blox.connect.RequestStatus.request_id)
  return request_id_;
}
inline void RequestStatus::set_request_id(::google::protobuf::int64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.RequestStatus.request_id)
}

// repeated string debug_info = 99;
inline int RequestStatus::debug_info_size() const {
  return debug_info_.size();
}
inline void RequestStatus::clear_debug_info() {
  debug_info_.Clear();
}
inline const ::std::string& RequestStatus::debug_info(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.RequestStatus.debug_info)
  return debug_info_.Get(index);
}
inline ::std::string* RequestStatus::mutable_debug_info(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.RequestStatus.debug_info)
  return debug_info_.Mutable(index);
}
inline void RequestStatus::set_debug_info(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.RequestStatus.debug_info)
  debug_info_.Mutable(index)->assign(value);
}
inline void RequestStatus::set_debug_info(int index, const char* value) {
  debug_info_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.RequestStatus.debug_info)
}
inline void RequestStatus::set_debug_info(int index, const char* value, size_t size) {
  debug_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.RequestStatus.debug_info)
}
inline ::std::string* RequestStatus::add_debug_info() {
  return debug_info_.Add();
}
inline void RequestStatus::add_debug_info(const ::std::string& value) {
  debug_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.RequestStatus.debug_info)
}
inline void RequestStatus::add_debug_info(const char* value) {
  debug_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.RequestStatus.debug_info)
}
inline void RequestStatus::add_debug_info(const char* value, size_t size) {
  debug_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.RequestStatus.debug_info)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RequestStatus::debug_info() const {
  // @@protoc_insertion_point(field_list:blox.connect.RequestStatus.debug_info)
  return debug_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RequestStatus::mutable_debug_info() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.RequestStatus.debug_info)
  return &debug_info_;
}

// -------------------------------------------------------------------

// AddReplicator

// required string workspace_name = 1;
inline bool AddReplicator::has_workspace_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddReplicator::set_has_workspace_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddReplicator::clear_has_workspace_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddReplicator::clear_workspace_name() {
  if (workspace_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_name_->clear();
  }
  clear_has_workspace_name();
}
inline const ::std::string& AddReplicator::workspace_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddReplicator.workspace_name)
  return *workspace_name_;
}
inline void AddReplicator::set_workspace_name(const ::std::string& value) {
  set_has_workspace_name();
  if (workspace_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_name_ = new ::std::string;
  }
  workspace_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AddReplicator.workspace_name)
}
inline void AddReplicator::set_workspace_name(const char* value) {
  set_has_workspace_name();
  if (workspace_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_name_ = new ::std::string;
  }
  workspace_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AddReplicator.workspace_name)
}
inline void AddReplicator::set_workspace_name(const char* value, size_t size) {
  set_has_workspace_name();
  if (workspace_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_name_ = new ::std::string;
  }
  workspace_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AddReplicator.workspace_name)
}
inline ::std::string* AddReplicator::mutable_workspace_name() {
  set_has_workspace_name();
  if (workspace_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AddReplicator.workspace_name)
  return workspace_name_;
}
inline ::std::string* AddReplicator::release_workspace_name() {
  clear_has_workspace_name();
  if (workspace_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workspace_name_;
    workspace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddReplicator::set_allocated_workspace_name(::std::string* workspace_name) {
  if (workspace_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workspace_name_;
  }
  if (workspace_name) {
    set_has_workspace_name();
    workspace_name_ = workspace_name;
  } else {
    clear_has_workspace_name();
    workspace_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AddReplicator.workspace_name)
}

// required uint64 prev_version = 2;
inline bool AddReplicator::has_prev_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddReplicator::set_has_prev_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddReplicator::clear_has_prev_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddReplicator::clear_prev_version() {
  prev_version_ = GOOGLE_ULONGLONG(0);
  clear_has_prev_version();
}
inline ::google::protobuf::uint64 AddReplicator::prev_version() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddReplicator.prev_version)
  return prev_version_;
}
inline void AddReplicator::set_prev_version(::google::protobuf::uint64 value) {
  set_has_prev_version();
  prev_version_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.AddReplicator.prev_version)
}

// optional bool replicate_once = 3 [default = false];
inline bool AddReplicator::has_replicate_once() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddReplicator::set_has_replicate_once() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddReplicator::clear_has_replicate_once() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddReplicator::clear_replicate_once() {
  replicate_once_ = false;
  clear_has_replicate_once();
}
inline bool AddReplicator::replicate_once() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddReplicator.replicate_once)
  return replicate_once_;
}
inline void AddReplicator::set_replicate_once(bool value) {
  set_has_replicate_once();
  replicate_once_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.AddReplicator.replicate_once)
}

// required uint64 prev_version_timestamp = 4;
inline bool AddReplicator::has_prev_version_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddReplicator::set_has_prev_version_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddReplicator::clear_has_prev_version_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddReplicator::clear_prev_version_timestamp() {
  prev_version_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_prev_version_timestamp();
}
inline ::google::protobuf::uint64 AddReplicator::prev_version_timestamp() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddReplicator.prev_version_timestamp)
  return prev_version_timestamp_;
}
inline void AddReplicator::set_prev_version_timestamp(::google::protobuf::uint64 value) {
  set_has_prev_version_timestamp();
  prev_version_timestamp_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.AddReplicator.prev_version_timestamp)
}

// -------------------------------------------------------------------

// AddReplicatorResponse

// required string uuid = 1;
inline bool AddReplicatorResponse::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddReplicatorResponse::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddReplicatorResponse::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddReplicatorResponse::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& AddReplicatorResponse::uuid() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddReplicatorResponse.uuid)
  return *uuid_;
}
inline void AddReplicatorResponse::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AddReplicatorResponse.uuid)
}
inline void AddReplicatorResponse::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AddReplicatorResponse.uuid)
}
inline void AddReplicatorResponse::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AddReplicatorResponse.uuid)
}
inline ::std::string* AddReplicatorResponse::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AddReplicatorResponse.uuid)
  return uuid_;
}
inline ::std::string* AddReplicatorResponse::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddReplicatorResponse::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AddReplicatorResponse.uuid)
}

// required string schema_version = 2;
inline bool AddReplicatorResponse::has_schema_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddReplicatorResponse::set_has_schema_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddReplicatorResponse::clear_has_schema_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddReplicatorResponse::clear_schema_version() {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_->clear();
  }
  clear_has_schema_version();
}
inline const ::std::string& AddReplicatorResponse::schema_version() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddReplicatorResponse.schema_version)
  return *schema_version_;
}
inline void AddReplicatorResponse::set_schema_version(const ::std::string& value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AddReplicatorResponse.schema_version)
}
inline void AddReplicatorResponse::set_schema_version(const char* value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AddReplicatorResponse.schema_version)
}
inline void AddReplicatorResponse::set_schema_version(const char* value, size_t size) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AddReplicatorResponse.schema_version)
}
inline ::std::string* AddReplicatorResponse::mutable_schema_version() {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AddReplicatorResponse.schema_version)
  return schema_version_;
}
inline ::std::string* AddReplicatorResponse::release_schema_version() {
  clear_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_version_;
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddReplicatorResponse::set_allocated_schema_version(::std::string* schema_version) {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_version_;
  }
  if (schema_version) {
    set_has_schema_version();
    schema_version_ = schema_version;
  } else {
    clear_has_schema_version();
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AddReplicatorResponse.schema_version)
}

// -------------------------------------------------------------------

// GetWorkspaceInfo

// required string name = 1;
inline bool GetWorkspaceInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetWorkspaceInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetWorkspaceInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetWorkspaceInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GetWorkspaceInfo::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfo.name)
  return *name_;
}
inline void GetWorkspaceInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfo.name)
}
inline void GetWorkspaceInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkspaceInfo.name)
}
inline void GetWorkspaceInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkspaceInfo.name)
}
inline ::std::string* GetWorkspaceInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkspaceInfo.name)
  return name_;
}
inline ::std::string* GetWorkspaceInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkspaceInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkspaceInfo.name)
}

// -------------------------------------------------------------------

// GetWorkspaceInfoResponse

// optional string path = 1;
inline bool GetWorkspaceInfoResponse::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetWorkspaceInfoResponse::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetWorkspaceInfoResponse::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& GetWorkspaceInfoResponse::path() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.path)
  return *path_;
}
inline void GetWorkspaceInfoResponse::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.path)
}
inline void GetWorkspaceInfoResponse::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkspaceInfoResponse.path)
}
inline void GetWorkspaceInfoResponse::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkspaceInfoResponse.path)
}
inline ::std::string* GetWorkspaceInfoResponse::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkspaceInfoResponse.path)
  return path_;
}
inline ::std::string* GetWorkspaceInfoResponse::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkspaceInfoResponse::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkspaceInfoResponse.path)
}

// optional uint64 commit_version = 2;
inline bool GetWorkspaceInfoResponse::has_commit_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_commit_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetWorkspaceInfoResponse::clear_has_commit_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetWorkspaceInfoResponse::clear_commit_version() {
  commit_version_ = GOOGLE_ULONGLONG(0);
  clear_has_commit_version();
}
inline ::google::protobuf::uint64 GetWorkspaceInfoResponse::commit_version() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.commit_version)
  return commit_version_;
}
inline void GetWorkspaceInfoResponse::set_commit_version(::google::protobuf::uint64 value) {
  set_has_commit_version();
  commit_version_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.commit_version)
}

// repeated .blox.connect.WorkSpaceOption option = 3;
inline int GetWorkspaceInfoResponse::option_size() const {
  return option_.size();
}
inline void GetWorkspaceInfoResponse::clear_option() {
  option_.Clear();
}
inline const ::blox::connect::WorkSpaceOption& GetWorkspaceInfoResponse::option(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.option)
  return option_.Get(index);
}
inline ::blox::connect::WorkSpaceOption* GetWorkspaceInfoResponse::mutable_option(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkspaceInfoResponse.option)
  return option_.Mutable(index);
}
inline ::blox::connect::WorkSpaceOption* GetWorkspaceInfoResponse::add_option() {
  // @@protoc_insertion_point(field_add:blox.connect.GetWorkspaceInfoResponse.option)
  return option_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkSpaceOption >&
GetWorkspaceInfoResponse::option() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetWorkspaceInfoResponse.option)
  return option_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::WorkSpaceOption >*
GetWorkspaceInfoResponse::mutable_option() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetWorkspaceInfoResponse.option)
  return &option_;
}

// required bool is_mirror = 4;
inline bool GetWorkspaceInfoResponse::has_is_mirror() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_is_mirror() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetWorkspaceInfoResponse::clear_has_is_mirror() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetWorkspaceInfoResponse::clear_is_mirror() {
  is_mirror_ = false;
  clear_has_is_mirror();
}
inline bool GetWorkspaceInfoResponse::is_mirror() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.is_mirror)
  return is_mirror_;
}
inline void GetWorkspaceInfoResponse::set_is_mirror(bool value) {
  set_has_is_mirror();
  is_mirror_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.is_mirror)
}

// optional bool is_mirroring = 5;
inline bool GetWorkspaceInfoResponse::has_is_mirroring() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_is_mirroring() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetWorkspaceInfoResponse::clear_has_is_mirroring() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetWorkspaceInfoResponse::clear_is_mirroring() {
  is_mirroring_ = false;
  clear_has_is_mirroring();
}
inline bool GetWorkspaceInfoResponse::is_mirroring() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.is_mirroring)
  return is_mirroring_;
}
inline void GetWorkspaceInfoResponse::set_is_mirroring(bool value) {
  set_has_is_mirroring();
  is_mirroring_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.is_mirroring)
}

// optional uint64 mirroring_since = 6;
inline bool GetWorkspaceInfoResponse::has_mirroring_since() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_mirroring_since() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetWorkspaceInfoResponse::clear_has_mirroring_since() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetWorkspaceInfoResponse::clear_mirroring_since() {
  mirroring_since_ = GOOGLE_ULONGLONG(0);
  clear_has_mirroring_since();
}
inline ::google::protobuf::uint64 GetWorkspaceInfoResponse::mirroring_since() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.mirroring_since)
  return mirroring_since_;
}
inline void GetWorkspaceInfoResponse::set_mirroring_since(::google::protobuf::uint64 value) {
  set_has_mirroring_since();
  mirroring_since_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.mirroring_since)
}

// optional uint64 pages_received = 7;
inline bool GetWorkspaceInfoResponse::has_pages_received() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_pages_received() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetWorkspaceInfoResponse::clear_has_pages_received() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetWorkspaceInfoResponse::clear_pages_received() {
  pages_received_ = GOOGLE_ULONGLONG(0);
  clear_has_pages_received();
}
inline ::google::protobuf::uint64 GetWorkspaceInfoResponse::pages_received() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.pages_received)
  return pages_received_;
}
inline void GetWorkspaceInfoResponse::set_pages_received(::google::protobuf::uint64 value) {
  set_has_pages_received();
  pages_received_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.pages_received)
}

// optional uint64 versions_received = 8;
inline bool GetWorkspaceInfoResponse::has_versions_received() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_versions_received() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetWorkspaceInfoResponse::clear_has_versions_received() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetWorkspaceInfoResponse::clear_versions_received() {
  versions_received_ = GOOGLE_ULONGLONG(0);
  clear_has_versions_received();
}
inline ::google::protobuf::uint64 GetWorkspaceInfoResponse::versions_received() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.versions_received)
  return versions_received_;
}
inline void GetWorkspaceInfoResponse::set_versions_received(::google::protobuf::uint64 value) {
  set_has_versions_received();
  versions_received_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.versions_received)
}

// optional uint64 used_disk_space = 9;
inline bool GetWorkspaceInfoResponse::has_used_disk_space() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_used_disk_space() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetWorkspaceInfoResponse::clear_has_used_disk_space() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetWorkspaceInfoResponse::clear_used_disk_space() {
  used_disk_space_ = GOOGLE_ULONGLONG(0);
  clear_has_used_disk_space();
}
inline ::google::protobuf::uint64 GetWorkspaceInfoResponse::used_disk_space() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.used_disk_space)
  return used_disk_space_;
}
inline void GetWorkspaceInfoResponse::set_used_disk_space(::google::protobuf::uint64 value) {
  set_has_used_disk_space();
  used_disk_space_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.used_disk_space)
}

// optional uint64 active_mirror_count = 10;
inline bool GetWorkspaceInfoResponse::has_active_mirror_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_active_mirror_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetWorkspaceInfoResponse::clear_has_active_mirror_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetWorkspaceInfoResponse::clear_active_mirror_count() {
  active_mirror_count_ = GOOGLE_ULONGLONG(0);
  clear_has_active_mirror_count();
}
inline ::google::protobuf::uint64 GetWorkspaceInfoResponse::active_mirror_count() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.active_mirror_count)
  return active_mirror_count_;
}
inline void GetWorkspaceInfoResponse::set_active_mirror_count(::google::protobuf::uint64 value) {
  set_has_active_mirror_count();
  active_mirror_count_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.active_mirror_count)
}

// required string uuid = 11;
inline bool GetWorkspaceInfoResponse::has_uuid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_uuid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetWorkspaceInfoResponse::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetWorkspaceInfoResponse::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& GetWorkspaceInfoResponse::uuid() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.uuid)
  return *uuid_;
}
inline void GetWorkspaceInfoResponse::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.uuid)
}
inline void GetWorkspaceInfoResponse::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkspaceInfoResponse.uuid)
}
inline void GetWorkspaceInfoResponse::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkspaceInfoResponse.uuid)
}
inline ::std::string* GetWorkspaceInfoResponse::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkspaceInfoResponse.uuid)
  return uuid_;
}
inline ::std::string* GetWorkspaceInfoResponse::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkspaceInfoResponse::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkspaceInfoResponse.uuid)
}

// optional string schema_version = 12;
inline bool GetWorkspaceInfoResponse::has_schema_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_schema_version() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GetWorkspaceInfoResponse::clear_has_schema_version() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GetWorkspaceInfoResponse::clear_schema_version() {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_->clear();
  }
  clear_has_schema_version();
}
inline const ::std::string& GetWorkspaceInfoResponse::schema_version() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.schema_version)
  return *schema_version_;
}
inline void GetWorkspaceInfoResponse::set_schema_version(const ::std::string& value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.schema_version)
}
inline void GetWorkspaceInfoResponse::set_schema_version(const char* value) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkspaceInfoResponse.schema_version)
}
inline void GetWorkspaceInfoResponse::set_schema_version(const char* value, size_t size) {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  schema_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkspaceInfoResponse.schema_version)
}
inline ::std::string* GetWorkspaceInfoResponse::mutable_schema_version() {
  set_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    schema_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkspaceInfoResponse.schema_version)
  return schema_version_;
}
inline ::std::string* GetWorkspaceInfoResponse::release_schema_version() {
  clear_has_schema_version();
  if (schema_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = schema_version_;
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetWorkspaceInfoResponse::set_allocated_schema_version(::std::string* schema_version) {
  if (schema_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete schema_version_;
  }
  if (schema_version) {
    set_has_schema_version();
    schema_version_ = schema_version;
  } else {
    clear_has_schema_version();
    schema_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetWorkspaceInfoResponse.schema_version)
}

// repeated string active_mirrors = 13;
inline int GetWorkspaceInfoResponse::active_mirrors_size() const {
  return active_mirrors_.size();
}
inline void GetWorkspaceInfoResponse::clear_active_mirrors() {
  active_mirrors_.Clear();
}
inline const ::std::string& GetWorkspaceInfoResponse::active_mirrors(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
  return active_mirrors_.Get(index);
}
inline ::std::string* GetWorkspaceInfoResponse::mutable_active_mirrors(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
  return active_mirrors_.Mutable(index);
}
inline void GetWorkspaceInfoResponse::set_active_mirrors(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
  active_mirrors_.Mutable(index)->assign(value);
}
inline void GetWorkspaceInfoResponse::set_active_mirrors(int index, const char* value) {
  active_mirrors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
}
inline void GetWorkspaceInfoResponse::set_active_mirrors(int index, const char* value, size_t size) {
  active_mirrors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
}
inline ::std::string* GetWorkspaceInfoResponse::add_active_mirrors() {
  return active_mirrors_.Add();
}
inline void GetWorkspaceInfoResponse::add_active_mirrors(const ::std::string& value) {
  active_mirrors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
}
inline void GetWorkspaceInfoResponse::add_active_mirrors(const char* value) {
  active_mirrors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
}
inline void GetWorkspaceInfoResponse::add_active_mirrors(const char* value, size_t size) {
  active_mirrors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetWorkspaceInfoResponse::active_mirrors() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
  return active_mirrors_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetWorkspaceInfoResponse::mutable_active_mirrors() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetWorkspaceInfoResponse.active_mirrors)
  return &active_mirrors_;
}

// optional uint64 pages_in_incoming_version = 14;
inline bool GetWorkspaceInfoResponse::has_pages_in_incoming_version() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_pages_in_incoming_version() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GetWorkspaceInfoResponse::clear_has_pages_in_incoming_version() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GetWorkspaceInfoResponse::clear_pages_in_incoming_version() {
  pages_in_incoming_version_ = GOOGLE_ULONGLONG(0);
  clear_has_pages_in_incoming_version();
}
inline ::google::protobuf::uint64 GetWorkspaceInfoResponse::pages_in_incoming_version() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.pages_in_incoming_version)
  return pages_in_incoming_version_;
}
inline void GetWorkspaceInfoResponse::set_pages_in_incoming_version(::google::protobuf::uint64 value) {
  set_has_pages_in_incoming_version();
  pages_in_incoming_version_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.pages_in_incoming_version)
}

// optional uint64 pages_received_in_incoming_version = 15;
inline bool GetWorkspaceInfoResponse::has_pages_received_in_incoming_version() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_pages_received_in_incoming_version() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GetWorkspaceInfoResponse::clear_has_pages_received_in_incoming_version() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GetWorkspaceInfoResponse::clear_pages_received_in_incoming_version() {
  pages_received_in_incoming_version_ = GOOGLE_ULONGLONG(0);
  clear_has_pages_received_in_incoming_version();
}
inline ::google::protobuf::uint64 GetWorkspaceInfoResponse::pages_received_in_incoming_version() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.pages_received_in_incoming_version)
  return pages_received_in_incoming_version_;
}
inline void GetWorkspaceInfoResponse::set_pages_received_in_incoming_version(::google::protobuf::uint64 value) {
  set_has_pages_received_in_incoming_version();
  pages_received_in_incoming_version_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.pages_received_in_incoming_version)
}

// required .blox.connect.GetWorkspaceInfoResponse.State state = 16;
inline bool GetWorkspaceInfoResponse::has_state() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_state() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GetWorkspaceInfoResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GetWorkspaceInfoResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::blox::connect::GetWorkspaceInfoResponse_State GetWorkspaceInfoResponse::state() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.state)
  return static_cast< ::blox::connect::GetWorkspaceInfoResponse_State >(state_);
}
inline void GetWorkspaceInfoResponse::set_state(::blox::connect::GetWorkspaceInfoResponse_State value) {
  assert(::blox::connect::GetWorkspaceInfoResponse_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.state)
}

// optional uint64 commit_timestamp = 17;
inline bool GetWorkspaceInfoResponse::has_commit_timestamp() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GetWorkspaceInfoResponse::set_has_commit_timestamp() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GetWorkspaceInfoResponse::clear_has_commit_timestamp() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GetWorkspaceInfoResponse::clear_commit_timestamp() {
  commit_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_commit_timestamp();
}
inline ::google::protobuf::uint64 GetWorkspaceInfoResponse::commit_timestamp() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetWorkspaceInfoResponse.commit_timestamp)
  return commit_timestamp_;
}
inline void GetWorkspaceInfoResponse::set_commit_timestamp(::google::protobuf::uint64 value) {
  set_has_commit_timestamp();
  commit_timestamp_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetWorkspaceInfoResponse.commit_timestamp)
}

// -------------------------------------------------------------------

// WorkSpaceOption

// required string name = 1;
inline bool WorkSpaceOption::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkSpaceOption::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkSpaceOption::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkSpaceOption::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WorkSpaceOption::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.WorkSpaceOption.name)
  return *name_;
}
inline void WorkSpaceOption::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.WorkSpaceOption.name)
}
inline void WorkSpaceOption::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.WorkSpaceOption.name)
}
inline void WorkSpaceOption::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.WorkSpaceOption.name)
}
inline ::std::string* WorkSpaceOption::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.WorkSpaceOption.name)
  return name_;
}
inline ::std::string* WorkSpaceOption::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WorkSpaceOption::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.WorkSpaceOption.name)
}

// required string value = 2;
inline bool WorkSpaceOption::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkSpaceOption::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkSpaceOption::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkSpaceOption::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& WorkSpaceOption::value() const {
  // @@protoc_insertion_point(field_get:blox.connect.WorkSpaceOption.value)
  return *value_;
}
inline void WorkSpaceOption::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.WorkSpaceOption.value)
}
inline void WorkSpaceOption::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.WorkSpaceOption.value)
}
inline void WorkSpaceOption::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.WorkSpaceOption.value)
}
inline ::std::string* WorkSpaceOption::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.WorkSpaceOption.value)
  return value_;
}
inline ::std::string* WorkSpaceOption::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WorkSpaceOption::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.WorkSpaceOption.value)
}

// -------------------------------------------------------------------

// StartMirror

// required string name = 1;
inline bool StartMirror::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartMirror::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartMirror::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartMirror::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StartMirror::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.StartMirror.name)
  return *name_;
}
inline void StartMirror::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.StartMirror.name)
}
inline void StartMirror::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.StartMirror.name)
}
inline void StartMirror::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.StartMirror.name)
}
inline ::std::string* StartMirror::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.StartMirror.name)
  return name_;
}
inline ::std::string* StartMirror::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartMirror::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.StartMirror.name)
}

// required string remote_host = 2;
inline bool StartMirror::has_remote_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartMirror::set_has_remote_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartMirror::clear_has_remote_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartMirror::clear_remote_host() {
  if (remote_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_->clear();
  }
  clear_has_remote_host();
}
inline const ::std::string& StartMirror::remote_host() const {
  // @@protoc_insertion_point(field_get:blox.connect.StartMirror.remote_host)
  return *remote_host_;
}
inline void StartMirror::set_remote_host(const ::std::string& value) {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  remote_host_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.StartMirror.remote_host)
}
inline void StartMirror::set_remote_host(const char* value) {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  remote_host_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.StartMirror.remote_host)
}
inline void StartMirror::set_remote_host(const char* value, size_t size) {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  remote_host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.StartMirror.remote_host)
}
inline ::std::string* StartMirror::mutable_remote_host() {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.StartMirror.remote_host)
  return remote_host_;
}
inline ::std::string* StartMirror::release_remote_host() {
  clear_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remote_host_;
    remote_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartMirror::set_allocated_remote_host(::std::string* remote_host) {
  if (remote_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remote_host_;
  }
  if (remote_host) {
    set_has_remote_host();
    remote_host_ = remote_host;
  } else {
    clear_has_remote_host();
    remote_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.StartMirror.remote_host)
}

// required uint32 remote_port = 3;
inline bool StartMirror::has_remote_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartMirror::set_has_remote_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartMirror::clear_has_remote_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartMirror::clear_remote_port() {
  remote_port_ = 0u;
  clear_has_remote_port();
}
inline ::google::protobuf::uint32 StartMirror::remote_port() const {
  // @@protoc_insertion_point(field_get:blox.connect.StartMirror.remote_port)
  return remote_port_;
}
inline void StartMirror::set_remote_port(::google::protobuf::uint32 value) {
  set_has_remote_port();
  remote_port_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.StartMirror.remote_port)
}

// required string remote_workspace = 4;
inline bool StartMirror::has_remote_workspace() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartMirror::set_has_remote_workspace() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartMirror::clear_has_remote_workspace() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartMirror::clear_remote_workspace() {
  if (remote_workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_->clear();
  }
  clear_has_remote_workspace();
}
inline const ::std::string& StartMirror::remote_workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.StartMirror.remote_workspace)
  return *remote_workspace_;
}
inline void StartMirror::set_remote_workspace(const ::std::string& value) {
  set_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_ = new ::std::string;
  }
  remote_workspace_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.StartMirror.remote_workspace)
}
inline void StartMirror::set_remote_workspace(const char* value) {
  set_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_ = new ::std::string;
  }
  remote_workspace_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.StartMirror.remote_workspace)
}
inline void StartMirror::set_remote_workspace(const char* value, size_t size) {
  set_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_ = new ::std::string;
  }
  remote_workspace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.StartMirror.remote_workspace)
}
inline ::std::string* StartMirror::mutable_remote_workspace() {
  set_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.StartMirror.remote_workspace)
  return remote_workspace_;
}
inline ::std::string* StartMirror::release_remote_workspace() {
  clear_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remote_workspace_;
    remote_workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StartMirror::set_allocated_remote_workspace(::std::string* remote_workspace) {
  if (remote_workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remote_workspace_;
  }
  if (remote_workspace) {
    set_has_remote_workspace();
    remote_workspace_ = remote_workspace;
  } else {
    clear_has_remote_workspace();
    remote_workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.StartMirror.remote_workspace)
}

// -------------------------------------------------------------------

// StartMirrorResponse

// -------------------------------------------------------------------

// StopMirror

// required string name = 1;
inline bool StopMirror::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopMirror::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopMirror::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopMirror::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StopMirror::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.StopMirror.name)
  return *name_;
}
inline void StopMirror::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.StopMirror.name)
}
inline void StopMirror::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.StopMirror.name)
}
inline void StopMirror::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.StopMirror.name)
}
inline ::std::string* StopMirror::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.StopMirror.name)
  return name_;
}
inline ::std::string* StopMirror::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StopMirror::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.StopMirror.name)
}

// -------------------------------------------------------------------

// StopMirrorResponse

// -------------------------------------------------------------------

// PromoteMirror

// required string name = 1;
inline bool PromoteMirror::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PromoteMirror::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PromoteMirror::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PromoteMirror::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PromoteMirror::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.PromoteMirror.name)
  return *name_;
}
inline void PromoteMirror::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.PromoteMirror.name)
}
inline void PromoteMirror::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.PromoteMirror.name)
}
inline void PromoteMirror::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.PromoteMirror.name)
}
inline ::std::string* PromoteMirror::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.PromoteMirror.name)
  return name_;
}
inline ::std::string* PromoteMirror::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PromoteMirror::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.PromoteMirror.name)
}

// -------------------------------------------------------------------

// PromoteMirrorResponse

// -------------------------------------------------------------------

// CopyRemoteWorkSpace

// required string name = 1;
inline bool CopyRemoteWorkSpace::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CopyRemoteWorkSpace::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CopyRemoteWorkSpace::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CopyRemoteWorkSpace::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CopyRemoteWorkSpace::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.CopyRemoteWorkSpace.name)
  return *name_;
}
inline void CopyRemoteWorkSpace::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CopyRemoteWorkSpace.name)
}
inline void CopyRemoteWorkSpace::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CopyRemoteWorkSpace.name)
}
inline void CopyRemoteWorkSpace::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CopyRemoteWorkSpace.name)
}
inline ::std::string* CopyRemoteWorkSpace::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CopyRemoteWorkSpace.name)
  return name_;
}
inline ::std::string* CopyRemoteWorkSpace::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CopyRemoteWorkSpace::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CopyRemoteWorkSpace.name)
}

// required string remote_host = 2;
inline bool CopyRemoteWorkSpace::has_remote_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CopyRemoteWorkSpace::set_has_remote_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CopyRemoteWorkSpace::clear_has_remote_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CopyRemoteWorkSpace::clear_remote_host() {
  if (remote_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_->clear();
  }
  clear_has_remote_host();
}
inline const ::std::string& CopyRemoteWorkSpace::remote_host() const {
  // @@protoc_insertion_point(field_get:blox.connect.CopyRemoteWorkSpace.remote_host)
  return *remote_host_;
}
inline void CopyRemoteWorkSpace::set_remote_host(const ::std::string& value) {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  remote_host_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CopyRemoteWorkSpace.remote_host)
}
inline void CopyRemoteWorkSpace::set_remote_host(const char* value) {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  remote_host_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CopyRemoteWorkSpace.remote_host)
}
inline void CopyRemoteWorkSpace::set_remote_host(const char* value, size_t size) {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  remote_host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CopyRemoteWorkSpace.remote_host)
}
inline ::std::string* CopyRemoteWorkSpace::mutable_remote_host() {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CopyRemoteWorkSpace.remote_host)
  return remote_host_;
}
inline ::std::string* CopyRemoteWorkSpace::release_remote_host() {
  clear_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remote_host_;
    remote_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CopyRemoteWorkSpace::set_allocated_remote_host(::std::string* remote_host) {
  if (remote_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remote_host_;
  }
  if (remote_host) {
    set_has_remote_host();
    remote_host_ = remote_host;
  } else {
    clear_has_remote_host();
    remote_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CopyRemoteWorkSpace.remote_host)
}

// required uint32 remote_port = 3;
inline bool CopyRemoteWorkSpace::has_remote_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CopyRemoteWorkSpace::set_has_remote_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CopyRemoteWorkSpace::clear_has_remote_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CopyRemoteWorkSpace::clear_remote_port() {
  remote_port_ = 0u;
  clear_has_remote_port();
}
inline ::google::protobuf::uint32 CopyRemoteWorkSpace::remote_port() const {
  // @@protoc_insertion_point(field_get:blox.connect.CopyRemoteWorkSpace.remote_port)
  return remote_port_;
}
inline void CopyRemoteWorkSpace::set_remote_port(::google::protobuf::uint32 value) {
  set_has_remote_port();
  remote_port_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.CopyRemoteWorkSpace.remote_port)
}

// required string remote_workspace = 4;
inline bool CopyRemoteWorkSpace::has_remote_workspace() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CopyRemoteWorkSpace::set_has_remote_workspace() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CopyRemoteWorkSpace::clear_has_remote_workspace() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CopyRemoteWorkSpace::clear_remote_workspace() {
  if (remote_workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_->clear();
  }
  clear_has_remote_workspace();
}
inline const ::std::string& CopyRemoteWorkSpace::remote_workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.CopyRemoteWorkSpace.remote_workspace)
  return *remote_workspace_;
}
inline void CopyRemoteWorkSpace::set_remote_workspace(const ::std::string& value) {
  set_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_ = new ::std::string;
  }
  remote_workspace_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CopyRemoteWorkSpace.remote_workspace)
}
inline void CopyRemoteWorkSpace::set_remote_workspace(const char* value) {
  set_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_ = new ::std::string;
  }
  remote_workspace_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CopyRemoteWorkSpace.remote_workspace)
}
inline void CopyRemoteWorkSpace::set_remote_workspace(const char* value, size_t size) {
  set_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_ = new ::std::string;
  }
  remote_workspace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CopyRemoteWorkSpace.remote_workspace)
}
inline ::std::string* CopyRemoteWorkSpace::mutable_remote_workspace() {
  set_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_workspace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CopyRemoteWorkSpace.remote_workspace)
  return remote_workspace_;
}
inline ::std::string* CopyRemoteWorkSpace::release_remote_workspace() {
  clear_has_remote_workspace();
  if (remote_workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remote_workspace_;
    remote_workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CopyRemoteWorkSpace::set_allocated_remote_workspace(::std::string* remote_workspace) {
  if (remote_workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remote_workspace_;
  }
  if (remote_workspace) {
    set_has_remote_workspace();
    remote_workspace_ = remote_workspace;
  } else {
    clear_has_remote_workspace();
    remote_workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CopyRemoteWorkSpace.remote_workspace)
}

// -------------------------------------------------------------------

// CopyRemoteWorkSpaceResponse

// -------------------------------------------------------------------

// ExecuteBatchScript

// required string script = 1;
inline bool ExecuteBatchScript::has_script() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteBatchScript::set_has_script() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteBatchScript::clear_has_script() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteBatchScript::clear_script() {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& ExecuteBatchScript::script() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecuteBatchScript.script)
  return *script_;
}
inline void ExecuteBatchScript::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExecuteBatchScript.script)
}
inline void ExecuteBatchScript::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExecuteBatchScript.script)
}
inline void ExecuteBatchScript::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExecuteBatchScript.script)
}
inline ::std::string* ExecuteBatchScript::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecuteBatchScript.script)
  return script_;
}
inline ::std::string* ExecuteBatchScript::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecuteBatchScript::set_allocated_script(::std::string* script) {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_;
  }
  if (script) {
    set_has_script();
    script_ = script;
  } else {
    clear_has_script();
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExecuteBatchScript.script)
}

// required string workspace = 2;
inline bool ExecuteBatchScript::has_workspace() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecuteBatchScript::set_has_workspace() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecuteBatchScript::clear_has_workspace() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecuteBatchScript::clear_workspace() {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_->clear();
  }
  clear_has_workspace();
}
inline const ::std::string& ExecuteBatchScript::workspace() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecuteBatchScript.workspace)
  return *workspace_;
}
inline void ExecuteBatchScript::set_workspace(const ::std::string& value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExecuteBatchScript.workspace)
}
inline void ExecuteBatchScript::set_workspace(const char* value) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExecuteBatchScript.workspace)
}
inline void ExecuteBatchScript::set_workspace(const char* value, size_t size) {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  workspace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExecuteBatchScript.workspace)
}
inline ::std::string* ExecuteBatchScript::mutable_workspace() {
  set_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    workspace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecuteBatchScript.workspace)
  return workspace_;
}
inline ::std::string* ExecuteBatchScript::release_workspace() {
  clear_has_workspace();
  if (workspace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = workspace_;
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecuteBatchScript::set_allocated_workspace(::std::string* workspace) {
  if (workspace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete workspace_;
  }
  if (workspace) {
    set_has_workspace();
    workspace_ = workspace;
  } else {
    clear_has_workspace();
    workspace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExecuteBatchScript.workspace)
}

// required bool transactional = 3;
inline bool ExecuteBatchScript::has_transactional() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecuteBatchScript::set_has_transactional() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecuteBatchScript::clear_has_transactional() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecuteBatchScript::clear_transactional() {
  transactional_ = false;
  clear_has_transactional();
}
inline bool ExecuteBatchScript::transactional() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecuteBatchScript.transactional)
  return transactional_;
}
inline void ExecuteBatchScript::set_transactional(bool value) {
  set_has_transactional();
  transactional_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.ExecuteBatchScript.transactional)
}

// optional bool return_data = 4;
inline bool ExecuteBatchScript::has_return_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecuteBatchScript::set_has_return_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecuteBatchScript::clear_has_return_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecuteBatchScript::clear_return_data() {
  return_data_ = false;
  clear_has_return_data();
}
inline bool ExecuteBatchScript::return_data() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecuteBatchScript.return_data)
  return return_data_;
}
inline void ExecuteBatchScript::set_return_data(bool value) {
  set_has_return_data();
  return_data_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.ExecuteBatchScript.return_data)
}

// -------------------------------------------------------------------

// ExecuteBatchScriptResponse

// required string output = 1;
inline bool ExecuteBatchScriptResponse::has_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteBatchScriptResponse::set_has_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteBatchScriptResponse::clear_has_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteBatchScriptResponse::clear_output() {
  if (output_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_->clear();
  }
  clear_has_output();
}
inline const ::std::string& ExecuteBatchScriptResponse::output() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecuteBatchScriptResponse.output)
  return *output_;
}
inline void ExecuteBatchScriptResponse::set_output(const ::std::string& value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_ = new ::std::string;
  }
  output_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExecuteBatchScriptResponse.output)
}
inline void ExecuteBatchScriptResponse::set_output(const char* value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_ = new ::std::string;
  }
  output_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExecuteBatchScriptResponse.output)
}
inline void ExecuteBatchScriptResponse::set_output(const char* value, size_t size) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_ = new ::std::string;
  }
  output_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExecuteBatchScriptResponse.output)
}
inline ::std::string* ExecuteBatchScriptResponse::mutable_output() {
  set_has_output();
  if (output_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    output_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecuteBatchScriptResponse.output)
  return output_;
}
inline ::std::string* ExecuteBatchScriptResponse::release_output() {
  clear_has_output();
  if (output_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = output_;
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecuteBatchScriptResponse::set_allocated_output(::std::string* output) {
  if (output_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete output_;
  }
  if (output) {
    set_has_output();
    output_ = output;
  } else {
    clear_has_output();
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExecuteBatchScriptResponse.output)
}

// repeated .blox.connect.Relation returned_data = 2;
inline int ExecuteBatchScriptResponse::returned_data_size() const {
  return returned_data_.size();
}
inline void ExecuteBatchScriptResponse::clear_returned_data() {
  returned_data_.Clear();
}
inline const ::blox::connect::Relation& ExecuteBatchScriptResponse::returned_data(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecuteBatchScriptResponse.returned_data)
  return returned_data_.Get(index);
}
inline ::blox::connect::Relation* ExecuteBatchScriptResponse::mutable_returned_data(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecuteBatchScriptResponse.returned_data)
  return returned_data_.Mutable(index);
}
inline ::blox::connect::Relation* ExecuteBatchScriptResponse::add_returned_data() {
  // @@protoc_insertion_point(field_add:blox.connect.ExecuteBatchScriptResponse.returned_data)
  return returned_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >&
ExecuteBatchScriptResponse::returned_data() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecuteBatchScriptResponse.returned_data)
  return returned_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >*
ExecuteBatchScriptResponse::mutable_returned_data() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecuteBatchScriptResponse.returned_data)
  return &returned_data_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace connect
}  // namespace blox

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::blox::connect::GetWorkspaceInfoResponse_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::connect::GetWorkspaceInfoResponse_State>() {
  return ::blox::connect::GetWorkspaceInfoResponse_State_descriptor();
}
template <> struct is_proto_enum< ::blox::connect::Priority> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::connect::Priority>() {
  return ::blox::connect::Priority_descriptor();
}
template <> struct is_proto_enum< ::blox::connect::RequestStatusEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::connect::RequestStatusEnum>() {
  return ::blox::connect::RequestStatusEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_blox_2fconnect_2fConnectBlox_2eproto__INCLUDED
