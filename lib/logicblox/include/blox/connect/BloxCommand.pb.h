// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: blox/connect/BloxCommand.proto

#ifndef PROTOBUF_blox_2fconnect_2fBloxCommand_2eproto__INCLUDED
#define PROTOBUF_blox_2fconnect_2fBloxCommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "blox/common/Common.pb.h"
#include "blox/connect/Exception.pb.h"
// @@protoc_insertion_point(includes)

namespace blox {
namespace connect {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

class Command;
class CommandResponse;
class AddBlock;
class AddBlockResponse;
class RemoveBlock;
class RemoveBlockResponse;
class CompileBlock;
class CompileBlockResponse;
class InstallLibrary;
class InstallLibraryResponse;
class InstallProject;
class InstallProjectResponse;
class ExecInactiveBlock;
class ExecInactiveBlockResponse;
class ReturnLocalProtoBuf;
class ReturnLocalProtoBufResponse;
class ExecBlock;
class ExecBlockResponse;
class QueryPredicate;
class QueryPredicateResponse;
class UpdatePredicate;
class UpdatePredicateResponse;
class GetPredicateInfo;
class GetPredicateInfoResponse;
class GetPredicateInfoBulk;
class GetPredicateInfoBulkResponse;
class GetPredicatePopcount;
class GetPredicatePopcountResponse;
class GetProtocolDescriptors;
class GetProtocolDescriptorsResponse;
class ProtocolDescriptor;
class ImportProtoBuf;
class ImportProtoBufResponse;
class ExportProtoBuf;
class ExportProtoBufResponse;
class LogMessage;
class LogMessageResponse;
class ProtoAddSpec;
class ProtoAddSpecResponse;
class BindBranchAlias;
class BindBranchAliasResponse;
class GenerateFullUpdateDeltas;
class GenerateFullUpdateDeltasResponse;
class ExecuteImportScript;
class ExecuteImportScriptResponse;
class FaultInjection;
class InputBinding;
class Relation;
class Column;
class BoolColumn;
class Int64Column;
class UInt64Column;
class Float64Column;
class DateTimeColumn;
class StringColumn;
class Decimal128Column;
class Int128Column;
class EntityColumn;
class PredicateName;
class LocalPredicateName;
class GlobalPredicateName;

enum FaultKind {
  ABNORMAL_PROGRAM_TERMINATION = 1,
  SLEEP = 2,
  HANG = 3
};
bool FaultKind_IsValid(int value);
const FaultKind FaultKind_MIN = ABNORMAL_PROGRAM_TERMINATION;
const FaultKind FaultKind_MAX = HANG;
const int FaultKind_ARRAYSIZE = FaultKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* FaultKind_descriptor();
inline const ::std::string& FaultKind_Name(FaultKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    FaultKind_descriptor(), value);
}
inline bool FaultKind_Parse(
    const ::std::string& name, FaultKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FaultKind>(
    FaultKind_descriptor(), name, value);
}
enum Language {
  LB = 1,
  LB0 = 2,
  MEASURE = 3
};
bool Language_IsValid(int value);
const Language Language_MIN = LB;
const Language Language_MAX = MEASURE;
const int Language_ARRAYSIZE = Language_MAX + 1;

const ::google::protobuf::EnumDescriptor* Language_descriptor();
inline const ::std::string& Language_Name(Language value) {
  return ::google::protobuf::internal::NameOfEnum(
    Language_descriptor(), value);
}
inline bool Language_Parse(
    const ::std::string& name, Language* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
enum DeltaModifier {
  ASSERTIONS = 1,
  RETRACTIONS = 2,
  UPSERT = 3,
  FULL = 4
};
bool DeltaModifier_IsValid(int value);
const DeltaModifier DeltaModifier_MIN = ASSERTIONS;
const DeltaModifier DeltaModifier_MAX = FULL;
const int DeltaModifier_ARRAYSIZE = DeltaModifier_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeltaModifier_descriptor();
inline const ::std::string& DeltaModifier_Name(DeltaModifier value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeltaModifier_descriptor(), value);
}
inline bool DeltaModifier_Parse(
    const ::std::string& name, DeltaModifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeltaModifier>(
    DeltaModifier_descriptor(), name, value);
}
enum EntityMode {
  MISSING_SKIP = 1,
  MISSING_CREATE = 2,
  MISSING_ERROR = 3
};
bool EntityMode_IsValid(int value);
const EntityMode EntityMode_MIN = MISSING_SKIP;
const EntityMode EntityMode_MAX = MISSING_ERROR;
const int EntityMode_ARRAYSIZE = EntityMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityMode_descriptor();
inline const ::std::string& EntityMode_Name(EntityMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityMode_descriptor(), value);
}
inline bool EntityMode_Parse(
    const ::std::string& name, EntityMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityMode>(
    EntityMode_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .blox.connect.AddBlock add_block = 1;
  inline bool has_add_block() const;
  inline void clear_add_block();
  static const int kAddBlockFieldNumber = 1;
  inline const ::blox::connect::AddBlock& add_block() const;
  inline ::blox::connect::AddBlock* mutable_add_block();
  inline ::blox::connect::AddBlock* release_add_block();
  inline void set_allocated_add_block(::blox::connect::AddBlock* add_block);

  // optional .blox.connect.InstallLibrary install_library = 2;
  inline bool has_install_library() const;
  inline void clear_install_library();
  static const int kInstallLibraryFieldNumber = 2;
  inline const ::blox::connect::InstallLibrary& install_library() const;
  inline ::blox::connect::InstallLibrary* mutable_install_library();
  inline ::blox::connect::InstallLibrary* release_install_library();
  inline void set_allocated_install_library(::blox::connect::InstallLibrary* install_library);

  // optional .blox.connect.ExecInactiveBlock exec_inactive = 3;
  inline bool has_exec_inactive() const;
  inline void clear_exec_inactive();
  static const int kExecInactiveFieldNumber = 3;
  inline const ::blox::connect::ExecInactiveBlock& exec_inactive() const;
  inline ::blox::connect::ExecInactiveBlock* mutable_exec_inactive();
  inline ::blox::connect::ExecInactiveBlock* release_exec_inactive();
  inline void set_allocated_exec_inactive(::blox::connect::ExecInactiveBlock* exec_inactive);

  // optional .blox.connect.ExecBlock exec = 4;
  inline bool has_exec() const;
  inline void clear_exec();
  static const int kExecFieldNumber = 4;
  inline const ::blox::connect::ExecBlock& exec() const;
  inline ::blox::connect::ExecBlock* mutable_exec();
  inline ::blox::connect::ExecBlock* release_exec();
  inline void set_allocated_exec(::blox::connect::ExecBlock* exec);

  // optional .blox.connect.QueryPredicate query_predicate = 5;
  inline bool has_query_predicate() const;
  inline void clear_query_predicate();
  static const int kQueryPredicateFieldNumber = 5;
  inline const ::blox::connect::QueryPredicate& query_predicate() const;
  inline ::blox::connect::QueryPredicate* mutable_query_predicate();
  inline ::blox::connect::QueryPredicate* release_query_predicate();
  inline void set_allocated_query_predicate(::blox::connect::QueryPredicate* query_predicate);

  // optional .blox.connect.UpdatePredicate update_predicate = 6;
  inline bool has_update_predicate() const;
  inline void clear_update_predicate();
  static const int kUpdatePredicateFieldNumber = 6;
  inline const ::blox::connect::UpdatePredicate& update_predicate() const;
  inline ::blox::connect::UpdatePredicate* mutable_update_predicate();
  inline ::blox::connect::UpdatePredicate* release_update_predicate();
  inline void set_allocated_update_predicate(::blox::connect::UpdatePredicate* update_predicate);

  // optional .blox.connect.GetPredicateInfo pred_info = 7;
  inline bool has_pred_info() const;
  inline void clear_pred_info();
  static const int kPredInfoFieldNumber = 7;
  inline const ::blox::connect::GetPredicateInfo& pred_info() const;
  inline ::blox::connect::GetPredicateInfo* mutable_pred_info();
  inline ::blox::connect::GetPredicateInfo* release_pred_info();
  inline void set_allocated_pred_info(::blox::connect::GetPredicateInfo* pred_info);

  // optional .blox.connect.ImportProtoBuf import_protobuf = 8;
  inline bool has_import_protobuf() const;
  inline void clear_import_protobuf();
  static const int kImportProtobufFieldNumber = 8;
  inline const ::blox::connect::ImportProtoBuf& import_protobuf() const;
  inline ::blox::connect::ImportProtoBuf* mutable_import_protobuf();
  inline ::blox::connect::ImportProtoBuf* release_import_protobuf();
  inline void set_allocated_import_protobuf(::blox::connect::ImportProtoBuf* import_protobuf);

  // optional .blox.connect.CompileBlock compile_block = 9;
  inline bool has_compile_block() const;
  inline void clear_compile_block();
  static const int kCompileBlockFieldNumber = 9;
  inline const ::blox::connect::CompileBlock& compile_block() const;
  inline ::blox::connect::CompileBlock* mutable_compile_block();
  inline ::blox::connect::CompileBlock* release_compile_block();
  inline void set_allocated_compile_block(::blox::connect::CompileBlock* compile_block);

  // optional .blox.connect.InstallProject install_project = 10;
  inline bool has_install_project() const;
  inline void clear_install_project();
  static const int kInstallProjectFieldNumber = 10;
  inline const ::blox::connect::InstallProject& install_project() const;
  inline ::blox::connect::InstallProject* mutable_install_project();
  inline ::blox::connect::InstallProject* release_install_project();
  inline void set_allocated_install_project(::blox::connect::InstallProject* install_project);

  // optional .blox.connect.RemoveBlock remove_block = 11;
  inline bool has_remove_block() const;
  inline void clear_remove_block();
  static const int kRemoveBlockFieldNumber = 11;
  inline const ::blox::connect::RemoveBlock& remove_block() const;
  inline ::blox::connect::RemoveBlock* mutable_remove_block();
  inline ::blox::connect::RemoveBlock* release_remove_block();
  inline void set_allocated_remove_block(::blox::connect::RemoveBlock* remove_block);

  // optional .blox.connect.LogMessage log_message = 12;
  inline bool has_log_message() const;
  inline void clear_log_message();
  static const int kLogMessageFieldNumber = 12;
  inline const ::blox::connect::LogMessage& log_message() const;
  inline ::blox::connect::LogMessage* mutable_log_message();
  inline ::blox::connect::LogMessage* release_log_message();
  inline void set_allocated_log_message(::blox::connect::LogMessage* log_message);

  // optional .blox.connect.ExportProtoBuf export_protobuf = 14;
  inline bool has_export_protobuf() const;
  inline void clear_export_protobuf();
  static const int kExportProtobufFieldNumber = 14;
  inline const ::blox::connect::ExportProtoBuf& export_protobuf() const;
  inline ::blox::connect::ExportProtoBuf* mutable_export_protobuf();
  inline ::blox::connect::ExportProtoBuf* release_export_protobuf();
  inline void set_allocated_export_protobuf(::blox::connect::ExportProtoBuf* export_protobuf);

  // optional .blox.connect.ProtoAddSpec proto_add_spec = 15;
  inline bool has_proto_add_spec() const;
  inline void clear_proto_add_spec();
  static const int kProtoAddSpecFieldNumber = 15;
  inline const ::blox::connect::ProtoAddSpec& proto_add_spec() const;
  inline ::blox::connect::ProtoAddSpec* mutable_proto_add_spec();
  inline ::blox::connect::ProtoAddSpec* release_proto_add_spec();
  inline void set_allocated_proto_add_spec(::blox::connect::ProtoAddSpec* proto_add_spec);

  // optional .blox.connect.FaultInjection fault = 16;
  inline bool has_fault() const;
  inline void clear_fault();
  static const int kFaultFieldNumber = 16;
  inline const ::blox::connect::FaultInjection& fault() const;
  inline ::blox::connect::FaultInjection* mutable_fault();
  inline ::blox::connect::FaultInjection* release_fault();
  inline void set_allocated_fault(::blox::connect::FaultInjection* fault);

  // optional .blox.connect.GetPredicateInfoBulk pred_info_bulk = 17;
  inline bool has_pred_info_bulk() const;
  inline void clear_pred_info_bulk();
  static const int kPredInfoBulkFieldNumber = 17;
  inline const ::blox::connect::GetPredicateInfoBulk& pred_info_bulk() const;
  inline ::blox::connect::GetPredicateInfoBulk* mutable_pred_info_bulk();
  inline ::blox::connect::GetPredicateInfoBulk* release_pred_info_bulk();
  inline void set_allocated_pred_info_bulk(::blox::connect::GetPredicateInfoBulk* pred_info_bulk);

  // optional .blox.connect.GetPredicatePopcount pred_popcount = 20;
  inline bool has_pred_popcount() const;
  inline void clear_pred_popcount();
  static const int kPredPopcountFieldNumber = 20;
  inline const ::blox::connect::GetPredicatePopcount& pred_popcount() const;
  inline ::blox::connect::GetPredicatePopcount* mutable_pred_popcount();
  inline ::blox::connect::GetPredicatePopcount* release_pred_popcount();
  inline void set_allocated_pred_popcount(::blox::connect::GetPredicatePopcount* pred_popcount);

  // optional .blox.connect.GenerateFullUpdateDeltas pred_full_update_deltas = 21;
  inline bool has_pred_full_update_deltas() const;
  inline void clear_pred_full_update_deltas();
  static const int kPredFullUpdateDeltasFieldNumber = 21;
  inline const ::blox::connect::GenerateFullUpdateDeltas& pred_full_update_deltas() const;
  inline ::blox::connect::GenerateFullUpdateDeltas* mutable_pred_full_update_deltas();
  inline ::blox::connect::GenerateFullUpdateDeltas* release_pred_full_update_deltas();
  inline void set_allocated_pred_full_update_deltas(::blox::connect::GenerateFullUpdateDeltas* pred_full_update_deltas);

  // optional .blox.connect.ExecuteImportScript exec_import_script = 22;
  inline bool has_exec_import_script() const;
  inline void clear_exec_import_script();
  static const int kExecImportScriptFieldNumber = 22;
  inline const ::blox::connect::ExecuteImportScript& exec_import_script() const;
  inline ::blox::connect::ExecuteImportScript* mutable_exec_import_script();
  inline ::blox::connect::ExecuteImportScript* release_exec_import_script();
  inline void set_allocated_exec_import_script(::blox::connect::ExecuteImportScript* exec_import_script);

  // optional .blox.connect.GetProtocolDescriptors proto_get_descriptors = 23;
  inline bool has_proto_get_descriptors() const;
  inline void clear_proto_get_descriptors();
  static const int kProtoGetDescriptorsFieldNumber = 23;
  inline const ::blox::connect::GetProtocolDescriptors& proto_get_descriptors() const;
  inline ::blox::connect::GetProtocolDescriptors* mutable_proto_get_descriptors();
  inline ::blox::connect::GetProtocolDescriptors* release_proto_get_descriptors();
  inline void set_allocated_proto_get_descriptors(::blox::connect::GetProtocolDescriptors* proto_get_descriptors);

  // optional .blox.connect.BindBranchAlias bind_branch_alias = 24;
  inline bool has_bind_branch_alias() const;
  inline void clear_bind_branch_alias();
  static const int kBindBranchAliasFieldNumber = 24;
  inline const ::blox::connect::BindBranchAlias& bind_branch_alias() const;
  inline ::blox::connect::BindBranchAlias* mutable_bind_branch_alias();
  inline ::blox::connect::BindBranchAlias* release_bind_branch_alias();
  inline void set_allocated_bind_branch_alias(::blox::connect::BindBranchAlias* bind_branch_alias);

  // @@protoc_insertion_point(class_scope:blox.connect.Command)
 private:
  inline void set_has_add_block();
  inline void clear_has_add_block();
  inline void set_has_install_library();
  inline void clear_has_install_library();
  inline void set_has_exec_inactive();
  inline void clear_has_exec_inactive();
  inline void set_has_exec();
  inline void clear_has_exec();
  inline void set_has_query_predicate();
  inline void clear_has_query_predicate();
  inline void set_has_update_predicate();
  inline void clear_has_update_predicate();
  inline void set_has_pred_info();
  inline void clear_has_pred_info();
  inline void set_has_import_protobuf();
  inline void clear_has_import_protobuf();
  inline void set_has_compile_block();
  inline void clear_has_compile_block();
  inline void set_has_install_project();
  inline void clear_has_install_project();
  inline void set_has_remove_block();
  inline void clear_has_remove_block();
  inline void set_has_log_message();
  inline void clear_has_log_message();
  inline void set_has_export_protobuf();
  inline void clear_has_export_protobuf();
  inline void set_has_proto_add_spec();
  inline void clear_has_proto_add_spec();
  inline void set_has_fault();
  inline void clear_has_fault();
  inline void set_has_pred_info_bulk();
  inline void clear_has_pred_info_bulk();
  inline void set_has_pred_popcount();
  inline void clear_has_pred_popcount();
  inline void set_has_pred_full_update_deltas();
  inline void clear_has_pred_full_update_deltas();
  inline void set_has_exec_import_script();
  inline void clear_has_exec_import_script();
  inline void set_has_proto_get_descriptors();
  inline void clear_has_proto_get_descriptors();
  inline void set_has_bind_branch_alias();
  inline void clear_has_bind_branch_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::AddBlock* add_block_;
  ::blox::connect::InstallLibrary* install_library_;
  ::blox::connect::ExecInactiveBlock* exec_inactive_;
  ::blox::connect::ExecBlock* exec_;
  ::blox::connect::QueryPredicate* query_predicate_;
  ::blox::connect::UpdatePredicate* update_predicate_;
  ::blox::connect::GetPredicateInfo* pred_info_;
  ::blox::connect::ImportProtoBuf* import_protobuf_;
  ::blox::connect::CompileBlock* compile_block_;
  ::blox::connect::InstallProject* install_project_;
  ::blox::connect::RemoveBlock* remove_block_;
  ::blox::connect::LogMessage* log_message_;
  ::blox::connect::ExportProtoBuf* export_protobuf_;
  ::blox::connect::ProtoAddSpec* proto_add_spec_;
  ::blox::connect::FaultInjection* fault_;
  ::blox::connect::GetPredicateInfoBulk* pred_info_bulk_;
  ::blox::connect::GetPredicatePopcount* pred_popcount_;
  ::blox::connect::GenerateFullUpdateDeltas* pred_full_update_deltas_;
  ::blox::connect::ExecuteImportScript* exec_import_script_;
  ::blox::connect::GetProtocolDescriptors* proto_get_descriptors_;
  ::blox::connect::BindBranchAlias* bind_branch_alias_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class CommandResponse : public ::google::protobuf::Message {
 public:
  CommandResponse();
  virtual ~CommandResponse();

  CommandResponse(const CommandResponse& from);

  inline CommandResponse& operator=(const CommandResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandResponse& default_instance();

  void Swap(CommandResponse* other);

  // implements Message ----------------------------------------------

  CommandResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandResponse& from);
  void MergeFrom(const CommandResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .blox.connect.ExceptionContainer exception = 1;
  inline bool has_exception() const;
  inline void clear_exception();
  static const int kExceptionFieldNumber = 1;
  inline const ::blox::connect::ExceptionContainer& exception() const;
  inline ::blox::connect::ExceptionContainer* mutable_exception();
  inline ::blox::connect::ExceptionContainer* release_exception();
  inline void set_allocated_exception(::blox::connect::ExceptionContainer* exception);

  // optional .blox.connect.AddBlockResponse add_block = 2;
  inline bool has_add_block() const;
  inline void clear_add_block();
  static const int kAddBlockFieldNumber = 2;
  inline const ::blox::connect::AddBlockResponse& add_block() const;
  inline ::blox::connect::AddBlockResponse* mutable_add_block();
  inline ::blox::connect::AddBlockResponse* release_add_block();
  inline void set_allocated_add_block(::blox::connect::AddBlockResponse* add_block);

  // optional .blox.connect.InstallLibraryResponse install_library = 3;
  inline bool has_install_library() const;
  inline void clear_install_library();
  static const int kInstallLibraryFieldNumber = 3;
  inline const ::blox::connect::InstallLibraryResponse& install_library() const;
  inline ::blox::connect::InstallLibraryResponse* mutable_install_library();
  inline ::blox::connect::InstallLibraryResponse* release_install_library();
  inline void set_allocated_install_library(::blox::connect::InstallLibraryResponse* install_library);

  // optional .blox.connect.ExecInactiveBlockResponse exec_inactive = 4;
  inline bool has_exec_inactive() const;
  inline void clear_exec_inactive();
  static const int kExecInactiveFieldNumber = 4;
  inline const ::blox::connect::ExecInactiveBlockResponse& exec_inactive() const;
  inline ::blox::connect::ExecInactiveBlockResponse* mutable_exec_inactive();
  inline ::blox::connect::ExecInactiveBlockResponse* release_exec_inactive();
  inline void set_allocated_exec_inactive(::blox::connect::ExecInactiveBlockResponse* exec_inactive);

  // optional .blox.connect.ExecBlockResponse exec = 5;
  inline bool has_exec() const;
  inline void clear_exec();
  static const int kExecFieldNumber = 5;
  inline const ::blox::connect::ExecBlockResponse& exec() const;
  inline ::blox::connect::ExecBlockResponse* mutable_exec();
  inline ::blox::connect::ExecBlockResponse* release_exec();
  inline void set_allocated_exec(::blox::connect::ExecBlockResponse* exec);

  // optional .blox.connect.QueryPredicateResponse query_predicate = 6;
  inline bool has_query_predicate() const;
  inline void clear_query_predicate();
  static const int kQueryPredicateFieldNumber = 6;
  inline const ::blox::connect::QueryPredicateResponse& query_predicate() const;
  inline ::blox::connect::QueryPredicateResponse* mutable_query_predicate();
  inline ::blox::connect::QueryPredicateResponse* release_query_predicate();
  inline void set_allocated_query_predicate(::blox::connect::QueryPredicateResponse* query_predicate);

  // optional .blox.connect.UpdatePredicateResponse update_predicate = 7;
  inline bool has_update_predicate() const;
  inline void clear_update_predicate();
  static const int kUpdatePredicateFieldNumber = 7;
  inline const ::blox::connect::UpdatePredicateResponse& update_predicate() const;
  inline ::blox::connect::UpdatePredicateResponse* mutable_update_predicate();
  inline ::blox::connect::UpdatePredicateResponse* release_update_predicate();
  inline void set_allocated_update_predicate(::blox::connect::UpdatePredicateResponse* update_predicate);

  // optional .blox.connect.GetPredicateInfoResponse pred_info = 8;
  inline bool has_pred_info() const;
  inline void clear_pred_info();
  static const int kPredInfoFieldNumber = 8;
  inline const ::blox::connect::GetPredicateInfoResponse& pred_info() const;
  inline ::blox::connect::GetPredicateInfoResponse* mutable_pred_info();
  inline ::blox::connect::GetPredicateInfoResponse* release_pred_info();
  inline void set_allocated_pred_info(::blox::connect::GetPredicateInfoResponse* pred_info);

  // optional .blox.connect.ImportProtoBufResponse import_protobuf = 9;
  inline bool has_import_protobuf() const;
  inline void clear_import_protobuf();
  static const int kImportProtobufFieldNumber = 9;
  inline const ::blox::connect::ImportProtoBufResponse& import_protobuf() const;
  inline ::blox::connect::ImportProtoBufResponse* mutable_import_protobuf();
  inline ::blox::connect::ImportProtoBufResponse* release_import_protobuf();
  inline void set_allocated_import_protobuf(::blox::connect::ImportProtoBufResponse* import_protobuf);

  // optional .blox.connect.CompileBlockResponse compile_block = 10;
  inline bool has_compile_block() const;
  inline void clear_compile_block();
  static const int kCompileBlockFieldNumber = 10;
  inline const ::blox::connect::CompileBlockResponse& compile_block() const;
  inline ::blox::connect::CompileBlockResponse* mutable_compile_block();
  inline ::blox::connect::CompileBlockResponse* release_compile_block();
  inline void set_allocated_compile_block(::blox::connect::CompileBlockResponse* compile_block);

  // optional .blox.connect.InstallProjectResponse install_project = 11;
  inline bool has_install_project() const;
  inline void clear_install_project();
  static const int kInstallProjectFieldNumber = 11;
  inline const ::blox::connect::InstallProjectResponse& install_project() const;
  inline ::blox::connect::InstallProjectResponse* mutable_install_project();
  inline ::blox::connect::InstallProjectResponse* release_install_project();
  inline void set_allocated_install_project(::blox::connect::InstallProjectResponse* install_project);

  // optional .blox.connect.RemoveBlockResponse remove_block = 12;
  inline bool has_remove_block() const;
  inline void clear_remove_block();
  static const int kRemoveBlockFieldNumber = 12;
  inline const ::blox::connect::RemoveBlockResponse& remove_block() const;
  inline ::blox::connect::RemoveBlockResponse* mutable_remove_block();
  inline ::blox::connect::RemoveBlockResponse* release_remove_block();
  inline void set_allocated_remove_block(::blox::connect::RemoveBlockResponse* remove_block);

  // optional .blox.connect.LogMessageResponse log_message = 13;
  inline bool has_log_message() const;
  inline void clear_log_message();
  static const int kLogMessageFieldNumber = 13;
  inline const ::blox::connect::LogMessageResponse& log_message() const;
  inline ::blox::connect::LogMessageResponse* mutable_log_message();
  inline ::blox::connect::LogMessageResponse* release_log_message();
  inline void set_allocated_log_message(::blox::connect::LogMessageResponse* log_message);

  // optional .blox.connect.ExportProtoBufResponse export_protobuf = 15;
  inline bool has_export_protobuf() const;
  inline void clear_export_protobuf();
  static const int kExportProtobufFieldNumber = 15;
  inline const ::blox::connect::ExportProtoBufResponse& export_protobuf() const;
  inline ::blox::connect::ExportProtoBufResponse* mutable_export_protobuf();
  inline ::blox::connect::ExportProtoBufResponse* release_export_protobuf();
  inline void set_allocated_export_protobuf(::blox::connect::ExportProtoBufResponse* export_protobuf);

  // optional .blox.connect.ProtoAddSpecResponse proto_add_spec = 16;
  inline bool has_proto_add_spec() const;
  inline void clear_proto_add_spec();
  static const int kProtoAddSpecFieldNumber = 16;
  inline const ::blox::connect::ProtoAddSpecResponse& proto_add_spec() const;
  inline ::blox::connect::ProtoAddSpecResponse* mutable_proto_add_spec();
  inline ::blox::connect::ProtoAddSpecResponse* release_proto_add_spec();
  inline void set_allocated_proto_add_spec(::blox::connect::ProtoAddSpecResponse* proto_add_spec);

  // optional .blox.connect.FaultInjection fault = 17;
  inline bool has_fault() const;
  inline void clear_fault();
  static const int kFaultFieldNumber = 17;
  inline const ::blox::connect::FaultInjection& fault() const;
  inline ::blox::connect::FaultInjection* mutable_fault();
  inline ::blox::connect::FaultInjection* release_fault();
  inline void set_allocated_fault(::blox::connect::FaultInjection* fault);

  // optional .blox.connect.GetPredicateInfoBulkResponse pred_info_bulk = 18;
  inline bool has_pred_info_bulk() const;
  inline void clear_pred_info_bulk();
  static const int kPredInfoBulkFieldNumber = 18;
  inline const ::blox::connect::GetPredicateInfoBulkResponse& pred_info_bulk() const;
  inline ::blox::connect::GetPredicateInfoBulkResponse* mutable_pred_info_bulk();
  inline ::blox::connect::GetPredicateInfoBulkResponse* release_pred_info_bulk();
  inline void set_allocated_pred_info_bulk(::blox::connect::GetPredicateInfoBulkResponse* pred_info_bulk);

  // optional .blox.connect.GetPredicatePopcountResponse pred_popcount = 21;
  inline bool has_pred_popcount() const;
  inline void clear_pred_popcount();
  static const int kPredPopcountFieldNumber = 21;
  inline const ::blox::connect::GetPredicatePopcountResponse& pred_popcount() const;
  inline ::blox::connect::GetPredicatePopcountResponse* mutable_pred_popcount();
  inline ::blox::connect::GetPredicatePopcountResponse* release_pred_popcount();
  inline void set_allocated_pred_popcount(::blox::connect::GetPredicatePopcountResponse* pred_popcount);

  // optional .blox.connect.GenerateFullUpdateDeltasResponse pred_full_update_deltas = 22;
  inline bool has_pred_full_update_deltas() const;
  inline void clear_pred_full_update_deltas();
  static const int kPredFullUpdateDeltasFieldNumber = 22;
  inline const ::blox::connect::GenerateFullUpdateDeltasResponse& pred_full_update_deltas() const;
  inline ::blox::connect::GenerateFullUpdateDeltasResponse* mutable_pred_full_update_deltas();
  inline ::blox::connect::GenerateFullUpdateDeltasResponse* release_pred_full_update_deltas();
  inline void set_allocated_pred_full_update_deltas(::blox::connect::GenerateFullUpdateDeltasResponse* pred_full_update_deltas);

  // optional .blox.connect.ExecuteImportScriptResponse exec_import_script = 23;
  inline bool has_exec_import_script() const;
  inline void clear_exec_import_script();
  static const int kExecImportScriptFieldNumber = 23;
  inline const ::blox::connect::ExecuteImportScriptResponse& exec_import_script() const;
  inline ::blox::connect::ExecuteImportScriptResponse* mutable_exec_import_script();
  inline ::blox::connect::ExecuteImportScriptResponse* release_exec_import_script();
  inline void set_allocated_exec_import_script(::blox::connect::ExecuteImportScriptResponse* exec_import_script);

  // optional .blox.connect.GetProtocolDescriptorsResponse proto_get_descriptors = 24;
  inline bool has_proto_get_descriptors() const;
  inline void clear_proto_get_descriptors();
  static const int kProtoGetDescriptorsFieldNumber = 24;
  inline const ::blox::connect::GetProtocolDescriptorsResponse& proto_get_descriptors() const;
  inline ::blox::connect::GetProtocolDescriptorsResponse* mutable_proto_get_descriptors();
  inline ::blox::connect::GetProtocolDescriptorsResponse* release_proto_get_descriptors();
  inline void set_allocated_proto_get_descriptors(::blox::connect::GetProtocolDescriptorsResponse* proto_get_descriptors);

  // optional .blox.connect.BindBranchAliasResponse bind_branch_alias = 25;
  inline bool has_bind_branch_alias() const;
  inline void clear_bind_branch_alias();
  static const int kBindBranchAliasFieldNumber = 25;
  inline const ::blox::connect::BindBranchAliasResponse& bind_branch_alias() const;
  inline ::blox::connect::BindBranchAliasResponse* mutable_bind_branch_alias();
  inline ::blox::connect::BindBranchAliasResponse* release_bind_branch_alias();
  inline void set_allocated_bind_branch_alias(::blox::connect::BindBranchAliasResponse* bind_branch_alias);

  // @@protoc_insertion_point(class_scope:blox.connect.CommandResponse)
 private:
  inline void set_has_exception();
  inline void clear_has_exception();
  inline void set_has_add_block();
  inline void clear_has_add_block();
  inline void set_has_install_library();
  inline void clear_has_install_library();
  inline void set_has_exec_inactive();
  inline void clear_has_exec_inactive();
  inline void set_has_exec();
  inline void clear_has_exec();
  inline void set_has_query_predicate();
  inline void clear_has_query_predicate();
  inline void set_has_update_predicate();
  inline void clear_has_update_predicate();
  inline void set_has_pred_info();
  inline void clear_has_pred_info();
  inline void set_has_import_protobuf();
  inline void clear_has_import_protobuf();
  inline void set_has_compile_block();
  inline void clear_has_compile_block();
  inline void set_has_install_project();
  inline void clear_has_install_project();
  inline void set_has_remove_block();
  inline void clear_has_remove_block();
  inline void set_has_log_message();
  inline void clear_has_log_message();
  inline void set_has_export_protobuf();
  inline void clear_has_export_protobuf();
  inline void set_has_proto_add_spec();
  inline void clear_has_proto_add_spec();
  inline void set_has_fault();
  inline void clear_has_fault();
  inline void set_has_pred_info_bulk();
  inline void clear_has_pred_info_bulk();
  inline void set_has_pred_popcount();
  inline void clear_has_pred_popcount();
  inline void set_has_pred_full_update_deltas();
  inline void clear_has_pred_full_update_deltas();
  inline void set_has_exec_import_script();
  inline void clear_has_exec_import_script();
  inline void set_has_proto_get_descriptors();
  inline void clear_has_proto_get_descriptors();
  inline void set_has_bind_branch_alias();
  inline void clear_has_bind_branch_alias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::ExceptionContainer* exception_;
  ::blox::connect::AddBlockResponse* add_block_;
  ::blox::connect::InstallLibraryResponse* install_library_;
  ::blox::connect::ExecInactiveBlockResponse* exec_inactive_;
  ::blox::connect::ExecBlockResponse* exec_;
  ::blox::connect::QueryPredicateResponse* query_predicate_;
  ::blox::connect::UpdatePredicateResponse* update_predicate_;
  ::blox::connect::GetPredicateInfoResponse* pred_info_;
  ::blox::connect::ImportProtoBufResponse* import_protobuf_;
  ::blox::connect::CompileBlockResponse* compile_block_;
  ::blox::connect::InstallProjectResponse* install_project_;
  ::blox::connect::RemoveBlockResponse* remove_block_;
  ::blox::connect::LogMessageResponse* log_message_;
  ::blox::connect::ExportProtoBufResponse* export_protobuf_;
  ::blox::connect::ProtoAddSpecResponse* proto_add_spec_;
  ::blox::connect::FaultInjection* fault_;
  ::blox::connect::GetPredicateInfoBulkResponse* pred_info_bulk_;
  ::blox::connect::GetPredicatePopcountResponse* pred_popcount_;
  ::blox::connect::GenerateFullUpdateDeltasResponse* pred_full_update_deltas_;
  ::blox::connect::ExecuteImportScriptResponse* exec_import_script_;
  ::blox::connect::GetProtocolDescriptorsResponse* proto_get_descriptors_;
  ::blox::connect::BindBranchAliasResponse* bind_branch_alias_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static CommandResponse* default_instance_;
};
// -------------------------------------------------------------------

class AddBlock : public ::google::protobuf::Message {
 public:
  AddBlock();
  virtual ~AddBlock();

  AddBlock(const AddBlock& from);

  inline AddBlock& operator=(const AddBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddBlock& default_instance();

  void Swap(AddBlock* other);

  // implements Message ----------------------------------------------

  AddBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddBlock& from);
  void MergeFrom(const AddBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string block_name = 1;
  inline bool has_block_name() const;
  inline void clear_block_name();
  static const int kBlockNameFieldNumber = 1;
  inline const ::std::string& block_name() const;
  inline void set_block_name(const ::std::string& value);
  inline void set_block_name(const char* value);
  inline void set_block_name(const char* value, size_t size);
  inline ::std::string* mutable_block_name();
  inline ::std::string* release_block_name();
  inline void set_allocated_block_name(::std::string* block_name);

  // optional bool active = 2;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 2;
  inline bool active() const;
  inline void set_active(bool value);

  // required bytes logic = 3;
  inline bool has_logic() const;
  inline void clear_logic();
  static const int kLogicFieldNumber = 3;
  inline const ::std::string& logic() const;
  inline void set_logic(const ::std::string& value);
  inline void set_logic(const char* value);
  inline void set_logic(const void* value, size_t size);
  inline ::std::string* mutable_logic();
  inline ::std::string* release_logic();
  inline void set_allocated_logic(::std::string* logic);

  // optional .blox.connect.Language language = 4;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 4;
  inline ::blox::connect::Language language() const;
  inline void set_language(::blox::connect::Language value);

  // optional bool after_fixpoint = 5;
  inline bool has_after_fixpoint() const;
  inline void clear_after_fixpoint();
  static const int kAfterFixpointFieldNumber = 5;
  inline bool after_fixpoint() const;
  inline void set_after_fixpoint(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.AddBlock)
 private:
  inline void set_has_block_name();
  inline void clear_has_block_name();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_logic();
  inline void clear_has_logic();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_after_fixpoint();
  inline void clear_has_after_fixpoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* block_name_;
  ::std::string* logic_;
  bool active_;
  bool after_fixpoint_;
  int language_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static AddBlock* default_instance_;
};
// -------------------------------------------------------------------

class AddBlockResponse : public ::google::protobuf::Message {
 public:
  AddBlockResponse();
  virtual ~AddBlockResponse();

  AddBlockResponse(const AddBlockResponse& from);

  inline AddBlockResponse& operator=(const AddBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddBlockResponse& default_instance();

  void Swap(AddBlockResponse* other);

  // implements Message ----------------------------------------------

  AddBlockResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddBlockResponse& from);
  void MergeFrom(const AddBlockResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string block_name = 1;
  inline bool has_block_name() const;
  inline void clear_block_name();
  static const int kBlockNameFieldNumber = 1;
  inline const ::std::string& block_name() const;
  inline void set_block_name(const ::std::string& value);
  inline void set_block_name(const char* value);
  inline void set_block_name(const char* value, size_t size);
  inline ::std::string* mutable_block_name();
  inline ::std::string* release_block_name();
  inline void set_allocated_block_name(::std::string* block_name);

  // optional .blox.common.protocol.CompilationProblems problems = 2;
  inline bool has_problems() const;
  inline void clear_problems();
  static const int kProblemsFieldNumber = 2;
  inline const ::blox::common::protocol::CompilationProblems& problems() const;
  inline ::blox::common::protocol::CompilationProblems* mutable_problems();
  inline ::blox::common::protocol::CompilationProblems* release_problems();
  inline void set_allocated_problems(::blox::common::protocol::CompilationProblems* problems);

  // @@protoc_insertion_point(class_scope:blox.connect.AddBlockResponse)
 private:
  inline void set_has_block_name();
  inline void clear_has_block_name();
  inline void set_has_problems();
  inline void clear_has_problems();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* block_name_;
  ::blox::common::protocol::CompilationProblems* problems_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static AddBlockResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoveBlock : public ::google::protobuf::Message {
 public:
  RemoveBlock();
  virtual ~RemoveBlock();

  RemoveBlock(const RemoveBlock& from);

  inline RemoveBlock& operator=(const RemoveBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveBlock& default_instance();

  void Swap(RemoveBlock* other);

  // implements Message ----------------------------------------------

  RemoveBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveBlock& from);
  void MergeFrom(const RemoveBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string block_name = 1;
  inline int block_name_size() const;
  inline void clear_block_name();
  static const int kBlockNameFieldNumber = 1;
  inline const ::std::string& block_name(int index) const;
  inline ::std::string* mutable_block_name(int index);
  inline void set_block_name(int index, const ::std::string& value);
  inline void set_block_name(int index, const char* value);
  inline void set_block_name(int index, const char* value, size_t size);
  inline ::std::string* add_block_name();
  inline void add_block_name(const ::std::string& value);
  inline void add_block_name(const char* value);
  inline void add_block_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& block_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_block_name();

  // @@protoc_insertion_point(class_scope:blox.connect.RemoveBlock)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> block_name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static RemoveBlock* default_instance_;
};
// -------------------------------------------------------------------

class RemoveBlockResponse : public ::google::protobuf::Message {
 public:
  RemoveBlockResponse();
  virtual ~RemoveBlockResponse();

  RemoveBlockResponse(const RemoveBlockResponse& from);

  inline RemoveBlockResponse& operator=(const RemoveBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveBlockResponse& default_instance();

  void Swap(RemoveBlockResponse* other);

  // implements Message ----------------------------------------------

  RemoveBlockResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveBlockResponse& from);
  void MergeFrom(const RemoveBlockResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .blox.common.protocol.CompilationProblems problems = 2;
  inline bool has_problems() const;
  inline void clear_problems();
  static const int kProblemsFieldNumber = 2;
  inline const ::blox::common::protocol::CompilationProblems& problems() const;
  inline ::blox::common::protocol::CompilationProblems* mutable_problems();
  inline ::blox::common::protocol::CompilationProblems* release_problems();
  inline void set_allocated_problems(::blox::common::protocol::CompilationProblems* problems);

  // @@protoc_insertion_point(class_scope:blox.connect.RemoveBlockResponse)
 private:
  inline void set_has_problems();
  inline void clear_has_problems();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::common::protocol::CompilationProblems* problems_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static RemoveBlockResponse* default_instance_;
};
// -------------------------------------------------------------------

class CompileBlock : public ::google::protobuf::Message {
 public:
  CompileBlock();
  virtual ~CompileBlock();

  CompileBlock(const CompileBlock& from);

  inline CompileBlock& operator=(const CompileBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompileBlock& default_instance();

  void Swap(CompileBlock* other);

  // implements Message ----------------------------------------------

  CompileBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompileBlock& from);
  void MergeFrom(const CompileBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string block_name = 1;
  inline bool has_block_name() const;
  inline void clear_block_name();
  static const int kBlockNameFieldNumber = 1;
  inline const ::std::string& block_name() const;
  inline void set_block_name(const ::std::string& value);
  inline void set_block_name(const char* value);
  inline void set_block_name(const char* value, size_t size);
  inline ::std::string* mutable_block_name();
  inline ::std::string* release_block_name();
  inline void set_allocated_block_name(::std::string* block_name);

  // required .blox.common.protocol.LogicSort sort = 2;
  inline bool has_sort() const;
  inline void clear_sort();
  static const int kSortFieldNumber = 2;
  inline ::blox::common::protocol::LogicSort sort() const;
  inline void set_sort(::blox::common::protocol::LogicSort value);

  // required string logic = 3;
  inline bool has_logic() const;
  inline void clear_logic();
  static const int kLogicFieldNumber = 3;
  inline const ::std::string& logic() const;
  inline void set_logic(const ::std::string& value);
  inline void set_logic(const char* value);
  inline void set_logic(const char* value, size_t size);
  inline ::std::string* mutable_logic();
  inline ::std::string* release_logic();
  inline void set_allocated_logic(::std::string* logic);

  // @@protoc_insertion_point(class_scope:blox.connect.CompileBlock)
 private:
  inline void set_has_block_name();
  inline void clear_has_block_name();
  inline void set_has_sort();
  inline void clear_has_sort();
  inline void set_has_logic();
  inline void clear_has_logic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* block_name_;
  ::std::string* logic_;
  int sort_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static CompileBlock* default_instance_;
};
// -------------------------------------------------------------------

class CompileBlockResponse : public ::google::protobuf::Message {
 public:
  CompileBlockResponse();
  virtual ~CompileBlockResponse();

  CompileBlockResponse(const CompileBlockResponse& from);

  inline CompileBlockResponse& operator=(const CompileBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompileBlockResponse& default_instance();

  void Swap(CompileBlockResponse* other);

  // implements Message ----------------------------------------------

  CompileBlockResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompileBlockResponse& from);
  void MergeFrom(const CompileBlockResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .blox.common.protocol.CompilationProblems problems = 1;
  inline bool has_problems() const;
  inline void clear_problems();
  static const int kProblemsFieldNumber = 1;
  inline const ::blox::common::protocol::CompilationProblems& problems() const;
  inline ::blox::common::protocol::CompilationProblems* mutable_problems();
  inline ::blox::common::protocol::CompilationProblems* release_problems();
  inline void set_allocated_problems(::blox::common::protocol::CompilationProblems* problems);

  // optional bytes result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  inline void set_allocated_result(::std::string* result);

  // @@protoc_insertion_point(class_scope:blox.connect.CompileBlockResponse)
 private:
  inline void set_has_problems();
  inline void clear_has_problems();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::common::protocol::CompilationProblems* problems_;
  ::std::string* result_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static CompileBlockResponse* default_instance_;
};
// -------------------------------------------------------------------

class InstallLibrary : public ::google::protobuf::Message {
 public:
  InstallLibrary();
  virtual ~InstallLibrary();

  InstallLibrary(const InstallLibrary& from);

  inline InstallLibrary& operator=(const InstallLibrary& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallLibrary& default_instance();

  void Swap(InstallLibrary* other);

  // implements Message ----------------------------------------------

  InstallLibrary* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstallLibrary& from);
  void MergeFrom(const InstallLibrary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:blox.connect.InstallLibrary)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static InstallLibrary* default_instance_;
};
// -------------------------------------------------------------------

class InstallLibraryResponse : public ::google::protobuf::Message {
 public:
  InstallLibraryResponse();
  virtual ~InstallLibraryResponse();

  InstallLibraryResponse(const InstallLibraryResponse& from);

  inline InstallLibraryResponse& operator=(const InstallLibraryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallLibraryResponse& default_instance();

  void Swap(InstallLibraryResponse* other);

  // implements Message ----------------------------------------------

  InstallLibraryResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstallLibraryResponse& from);
  void MergeFrom(const InstallLibraryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.InstallLibraryResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static InstallLibraryResponse* default_instance_;
};
// -------------------------------------------------------------------

class InstallProject : public ::google::protobuf::Message {
 public:
  InstallProject();
  virtual ~InstallProject();

  InstallProject(const InstallProject& from);

  inline InstallProject& operator=(const InstallProject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallProject& default_instance();

  void Swap(InstallProject* other);

  // implements Message ----------------------------------------------

  InstallProject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstallProject& from);
  void MergeFrom(const InstallProject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string projDir = 1;
  inline bool has_projdir() const;
  inline void clear_projdir();
  static const int kProjDirFieldNumber = 1;
  inline const ::std::string& projdir() const;
  inline void set_projdir(const ::std::string& value);
  inline void set_projdir(const char* value);
  inline void set_projdir(const char* value, size_t size);
  inline ::std::string* mutable_projdir();
  inline ::std::string* release_projdir();
  inline void set_allocated_projdir(::std::string* projdir);

  // optional bool recurse = 2 [default = true];
  inline bool has_recurse() const;
  inline void clear_recurse();
  static const int kRecurseFieldNumber = 2;
  inline bool recurse() const;
  inline void set_recurse(bool value);

  // optional bool copy = 3 [default = true];
  inline bool has_copy() const;
  inline void clear_copy();
  static const int kCopyFieldNumber = 3;
  inline bool copy() const;
  inline void set_copy(bool value);

  // optional string lib_path = 4;
  inline bool has_lib_path() const;
  inline void clear_lib_path();
  static const int kLibPathFieldNumber = 4;
  inline const ::std::string& lib_path() const;
  inline void set_lib_path(const ::std::string& value);
  inline void set_lib_path(const char* value);
  inline void set_lib_path(const char* value, size_t size);
  inline ::std::string* mutable_lib_path();
  inline ::std::string* release_lib_path();
  inline void set_allocated_lib_path(::std::string* lib_path);

  // @@protoc_insertion_point(class_scope:blox.connect.InstallProject)
 private:
  inline void set_has_projdir();
  inline void clear_has_projdir();
  inline void set_has_recurse();
  inline void clear_has_recurse();
  inline void set_has_copy();
  inline void clear_has_copy();
  inline void set_has_lib_path();
  inline void clear_has_lib_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* projdir_;
  ::std::string* lib_path_;
  bool recurse_;
  bool copy_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static InstallProject* default_instance_;
};
// -------------------------------------------------------------------

class InstallProjectResponse : public ::google::protobuf::Message {
 public:
  InstallProjectResponse();
  virtual ~InstallProjectResponse();

  InstallProjectResponse(const InstallProjectResponse& from);

  inline InstallProjectResponse& operator=(const InstallProjectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallProjectResponse& default_instance();

  void Swap(InstallProjectResponse* other);

  // implements Message ----------------------------------------------

  InstallProjectResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstallProjectResponse& from);
  void MergeFrom(const InstallProjectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.InstallProjectResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static InstallProjectResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExecInactiveBlock : public ::google::protobuf::Message {
 public:
  ExecInactiveBlock();
  virtual ~ExecInactiveBlock();

  ExecInactiveBlock(const ExecInactiveBlock& from);

  inline ExecInactiveBlock& operator=(const ExecInactiveBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecInactiveBlock& default_instance();

  void Swap(ExecInactiveBlock* other);

  // implements Message ----------------------------------------------

  ExecInactiveBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecInactiveBlock& from);
  void MergeFrom(const ExecInactiveBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string block_name = 1;
  inline bool has_block_name() const;
  inline void clear_block_name();
  static const int kBlockNameFieldNumber = 1;
  inline const ::std::string& block_name() const;
  inline void set_block_name(const ::std::string& value);
  inline void set_block_name(const char* value);
  inline void set_block_name(const char* value, size_t size);
  inline ::std::string* mutable_block_name();
  inline ::std::string* release_block_name();
  inline void set_allocated_block_name(::std::string* block_name);

  // repeated .blox.connect.InputBinding input = 2;
  inline int input_size() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::blox::connect::InputBinding& input(int index) const;
  inline ::blox::connect::InputBinding* mutable_input(int index);
  inline ::blox::connect::InputBinding* add_input();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding >&
      input() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding >*
      mutable_input();

  // repeated string return_local = 3;
  inline int return_local_size() const;
  inline void clear_return_local();
  static const int kReturnLocalFieldNumber = 3;
  inline const ::std::string& return_local(int index) const;
  inline ::std::string* mutable_return_local(int index);
  inline void set_return_local(int index, const ::std::string& value);
  inline void set_return_local(int index, const char* value);
  inline void set_return_local(int index, const char* value, size_t size);
  inline ::std::string* add_return_local();
  inline void add_return_local(const ::std::string& value);
  inline void add_return_local(const char* value);
  inline void add_return_local(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& return_local() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_return_local();

  // repeated .blox.connect.ReturnLocalProtoBuf return_protobuf = 4;
  inline int return_protobuf_size() const;
  inline void clear_return_protobuf();
  static const int kReturnProtobufFieldNumber = 4;
  inline const ::blox::connect::ReturnLocalProtoBuf& return_protobuf(int index) const;
  inline ::blox::connect::ReturnLocalProtoBuf* mutable_return_protobuf(int index);
  inline ::blox::connect::ReturnLocalProtoBuf* add_return_protobuf();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf >&
      return_protobuf() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf >*
      mutable_return_protobuf();

  // @@protoc_insertion_point(class_scope:blox.connect.ExecInactiveBlock)
 private:
  inline void set_has_block_name();
  inline void clear_has_block_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* block_name_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding > input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> return_local_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf > return_protobuf_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ExecInactiveBlock* default_instance_;
};
// -------------------------------------------------------------------

class ExecInactiveBlockResponse : public ::google::protobuf::Message {
 public:
  ExecInactiveBlockResponse();
  virtual ~ExecInactiveBlockResponse();

  ExecInactiveBlockResponse(const ExecInactiveBlockResponse& from);

  inline ExecInactiveBlockResponse& operator=(const ExecInactiveBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecInactiveBlockResponse& default_instance();

  void Swap(ExecInactiveBlockResponse* other);

  // implements Message ----------------------------------------------

  ExecInactiveBlockResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecInactiveBlockResponse& from);
  void MergeFrom(const ExecInactiveBlockResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox.connect.Relation return_local = 1;
  inline int return_local_size() const;
  inline void clear_return_local();
  static const int kReturnLocalFieldNumber = 1;
  inline const ::blox::connect::Relation& return_local(int index) const;
  inline ::blox::connect::Relation* mutable_return_local(int index);
  inline ::blox::connect::Relation* add_return_local();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >&
      return_local() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >*
      mutable_return_local();

  // repeated .blox.connect.ReturnLocalProtoBufResponse return_protobuf = 2;
  inline int return_protobuf_size() const;
  inline void clear_return_protobuf();
  static const int kReturnProtobufFieldNumber = 2;
  inline const ::blox::connect::ReturnLocalProtoBufResponse& return_protobuf(int index) const;
  inline ::blox::connect::ReturnLocalProtoBufResponse* mutable_return_protobuf(int index);
  inline ::blox::connect::ReturnLocalProtoBufResponse* add_return_protobuf();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse >&
      return_protobuf() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse >*
      mutable_return_protobuf();

  // @@protoc_insertion_point(class_scope:blox.connect.ExecInactiveBlockResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation > return_local_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse > return_protobuf_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ExecInactiveBlockResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReturnLocalProtoBuf : public ::google::protobuf::Message {
 public:
  ReturnLocalProtoBuf();
  virtual ~ReturnLocalProtoBuf();

  ReturnLocalProtoBuf(const ReturnLocalProtoBuf& from);

  inline ReturnLocalProtoBuf& operator=(const ReturnLocalProtoBuf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReturnLocalProtoBuf& default_instance();

  void Swap(ReturnLocalProtoBuf* other);

  // implements Message ----------------------------------------------

  ReturnLocalProtoBuf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReturnLocalProtoBuf& from);
  void MergeFrom(const ReturnLocalProtoBuf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string predicate = 1;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::std::string& predicate() const;
  inline void set_predicate(const ::std::string& value);
  inline void set_predicate(const char* value);
  inline void set_predicate(const char* value, size_t size);
  inline ::std::string* mutable_predicate();
  inline ::std::string* release_predicate();
  inline void set_allocated_predicate(::std::string* predicate);

  // required string protocol = 2;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 2;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // @@protoc_insertion_point(class_scope:blox.connect.ReturnLocalProtoBuf)
 private:
  inline void set_has_predicate();
  inline void clear_has_predicate();
  inline void set_has_protocol();
  inline void clear_has_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* predicate_;
  ::std::string* protocol_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ReturnLocalProtoBuf* default_instance_;
};
// -------------------------------------------------------------------

class ReturnLocalProtoBufResponse : public ::google::protobuf::Message {
 public:
  ReturnLocalProtoBufResponse();
  virtual ~ReturnLocalProtoBufResponse();

  ReturnLocalProtoBufResponse(const ReturnLocalProtoBufResponse& from);

  inline ReturnLocalProtoBufResponse& operator=(const ReturnLocalProtoBufResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReturnLocalProtoBufResponse& default_instance();

  void Swap(ReturnLocalProtoBufResponse* other);

  // implements Message ----------------------------------------------

  ReturnLocalProtoBufResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReturnLocalProtoBufResponse& from);
  void MergeFrom(const ReturnLocalProtoBufResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string predicate = 1;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::std::string& predicate() const;
  inline void set_predicate(const ::std::string& value);
  inline void set_predicate(const char* value);
  inline void set_predicate(const char* value, size_t size);
  inline ::std::string* mutable_predicate();
  inline ::std::string* release_predicate();
  inline void set_allocated_predicate(::std::string* predicate);

  // repeated bytes message = 2;
  inline int message_size() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message(int index) const;
  inline ::std::string* mutable_message(int index);
  inline void set_message(int index, const ::std::string& value);
  inline void set_message(int index, const char* value);
  inline void set_message(int index, const void* value, size_t size);
  inline ::std::string* add_message();
  inline void add_message(const ::std::string& value);
  inline void add_message(const char* value);
  inline void add_message(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& message() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_message();

  // @@protoc_insertion_point(class_scope:blox.connect.ReturnLocalProtoBufResponse)
 private:
  inline void set_has_predicate();
  inline void clear_has_predicate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* predicate_;
  ::google::protobuf::RepeatedPtrField< ::std::string> message_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ReturnLocalProtoBufResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExecBlock : public ::google::protobuf::Message {
 public:
  ExecBlock();
  virtual ~ExecBlock();

  ExecBlock(const ExecBlock& from);

  inline ExecBlock& operator=(const ExecBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecBlock& default_instance();

  void Swap(ExecBlock* other);

  // implements Message ----------------------------------------------

  ExecBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecBlock& from);
  void MergeFrom(const ExecBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string block_name = 1;
  inline bool has_block_name() const;
  inline void clear_block_name();
  static const int kBlockNameFieldNumber = 1;
  inline const ::std::string& block_name() const;
  inline void set_block_name(const ::std::string& value);
  inline void set_block_name(const char* value);
  inline void set_block_name(const char* value, size_t size);
  inline ::std::string* mutable_block_name();
  inline ::std::string* release_block_name();
  inline void set_allocated_block_name(::std::string* block_name);

  // required bytes logic = 2;
  inline bool has_logic() const;
  inline void clear_logic();
  static const int kLogicFieldNumber = 2;
  inline const ::std::string& logic() const;
  inline void set_logic(const ::std::string& value);
  inline void set_logic(const char* value);
  inline void set_logic(const void* value, size_t size);
  inline ::std::string* mutable_logic();
  inline ::std::string* release_logic();
  inline void set_allocated_logic(::std::string* logic);

  // optional .blox.connect.Language language = 3;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 3;
  inline ::blox::connect::Language language() const;
  inline void set_language(::blox::connect::Language value);

  // repeated .blox.connect.InputBinding input = 4;
  inline int input_size() const;
  inline void clear_input();
  static const int kInputFieldNumber = 4;
  inline const ::blox::connect::InputBinding& input(int index) const;
  inline ::blox::connect::InputBinding* mutable_input(int index);
  inline ::blox::connect::InputBinding* add_input();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding >&
      input() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding >*
      mutable_input();

  // repeated string return_local = 5;
  inline int return_local_size() const;
  inline void clear_return_local();
  static const int kReturnLocalFieldNumber = 5;
  inline const ::std::string& return_local(int index) const;
  inline ::std::string* mutable_return_local(int index);
  inline void set_return_local(int index, const ::std::string& value);
  inline void set_return_local(int index, const char* value);
  inline void set_return_local(int index, const char* value, size_t size);
  inline ::std::string* add_return_local();
  inline void add_return_local(const ::std::string& value);
  inline void add_return_local(const char* value);
  inline void add_return_local(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& return_local() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_return_local();

  // repeated .blox.connect.ReturnLocalProtoBuf return_protobuf = 6;
  inline int return_protobuf_size() const;
  inline void clear_return_protobuf();
  static const int kReturnProtobufFieldNumber = 6;
  inline const ::blox::connect::ReturnLocalProtoBuf& return_protobuf(int index) const;
  inline ::blox::connect::ReturnLocalProtoBuf* mutable_return_protobuf(int index);
  inline ::blox::connect::ReturnLocalProtoBuf* add_return_protobuf();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf >&
      return_protobuf() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf >*
      mutable_return_protobuf();

  // @@protoc_insertion_point(class_scope:blox.connect.ExecBlock)
 private:
  inline void set_has_block_name();
  inline void clear_has_block_name();
  inline void set_has_logic();
  inline void clear_has_logic();
  inline void set_has_language();
  inline void clear_has_language();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* block_name_;
  ::std::string* logic_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding > input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> return_local_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf > return_protobuf_;
  int language_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ExecBlock* default_instance_;
};
// -------------------------------------------------------------------

class ExecBlockResponse : public ::google::protobuf::Message {
 public:
  ExecBlockResponse();
  virtual ~ExecBlockResponse();

  ExecBlockResponse(const ExecBlockResponse& from);

  inline ExecBlockResponse& operator=(const ExecBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecBlockResponse& default_instance();

  void Swap(ExecBlockResponse* other);

  // implements Message ----------------------------------------------

  ExecBlockResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecBlockResponse& from);
  void MergeFrom(const ExecBlockResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .blox.common.protocol.CompilationProblems problems = 1;
  inline bool has_problems() const;
  inline void clear_problems();
  static const int kProblemsFieldNumber = 1;
  inline const ::blox::common::protocol::CompilationProblems& problems() const;
  inline ::blox::common::protocol::CompilationProblems* mutable_problems();
  inline ::blox::common::protocol::CompilationProblems* release_problems();
  inline void set_allocated_problems(::blox::common::protocol::CompilationProblems* problems);

  // repeated .blox.connect.Relation return_local = 2;
  inline int return_local_size() const;
  inline void clear_return_local();
  static const int kReturnLocalFieldNumber = 2;
  inline const ::blox::connect::Relation& return_local(int index) const;
  inline ::blox::connect::Relation* mutable_return_local(int index);
  inline ::blox::connect::Relation* add_return_local();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >&
      return_local() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >*
      mutable_return_local();

  // repeated .blox.connect.ReturnLocalProtoBufResponse return_protobuf = 3;
  inline int return_protobuf_size() const;
  inline void clear_return_protobuf();
  static const int kReturnProtobufFieldNumber = 3;
  inline const ::blox::connect::ReturnLocalProtoBufResponse& return_protobuf(int index) const;
  inline ::blox::connect::ReturnLocalProtoBufResponse* mutable_return_protobuf(int index);
  inline ::blox::connect::ReturnLocalProtoBufResponse* add_return_protobuf();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse >&
      return_protobuf() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse >*
      mutable_return_protobuf();

  // @@protoc_insertion_point(class_scope:blox.connect.ExecBlockResponse)
 private:
  inline void set_has_problems();
  inline void clear_has_problems();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::common::protocol::CompilationProblems* problems_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation > return_local_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse > return_protobuf_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ExecBlockResponse* default_instance_;
};
// -------------------------------------------------------------------

class QueryPredicate : public ::google::protobuf::Message {
 public:
  QueryPredicate();
  virtual ~QueryPredicate();

  QueryPredicate(const QueryPredicate& from);

  inline QueryPredicate& operator=(const QueryPredicate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPredicate& default_instance();

  void Swap(QueryPredicate* other);

  // implements Message ----------------------------------------------

  QueryPredicate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPredicate& from);
  void MergeFrom(const QueryPredicate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .blox.connect.PredicateName predicate = 1;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::blox::connect::PredicateName& predicate() const;
  inline ::blox::connect::PredicateName* mutable_predicate();
  inline ::blox::connect::PredicateName* release_predicate();
  inline void set_allocated_predicate(::blox::connect::PredicateName* predicate);

  // optional .blox.connect.DeltaModifier delta = 2;
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 2;
  inline ::blox::connect::DeltaModifier delta() const;
  inline void set_delta(::blox::connect::DeltaModifier value);

  // optional bool return_refmodes = 3 [default = true];
  inline bool has_return_refmodes() const;
  inline void clear_return_refmodes();
  static const int kReturnRefmodesFieldNumber = 3;
  inline bool return_refmodes() const;
  inline void set_return_refmodes(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.QueryPredicate)
 private:
  inline void set_has_predicate();
  inline void clear_has_predicate();
  inline void set_has_delta();
  inline void clear_has_delta();
  inline void set_has_return_refmodes();
  inline void clear_has_return_refmodes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::PredicateName* predicate_;
  int delta_;
  bool return_refmodes_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static QueryPredicate* default_instance_;
};
// -------------------------------------------------------------------

class QueryPredicateResponse : public ::google::protobuf::Message {
 public:
  QueryPredicateResponse();
  virtual ~QueryPredicateResponse();

  QueryPredicateResponse(const QueryPredicateResponse& from);

  inline QueryPredicateResponse& operator=(const QueryPredicateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPredicateResponse& default_instance();

  void Swap(QueryPredicateResponse* other);

  // implements Message ----------------------------------------------

  QueryPredicateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPredicateResponse& from);
  void MergeFrom(const QueryPredicateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .blox.connect.Relation relation = 1;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 1;
  inline const ::blox::connect::Relation& relation() const;
  inline ::blox::connect::Relation* mutable_relation();
  inline ::blox::connect::Relation* release_relation();
  inline void set_allocated_relation(::blox::connect::Relation* relation);

  // @@protoc_insertion_point(class_scope:blox.connect.QueryPredicateResponse)
 private:
  inline void set_has_relation();
  inline void clear_has_relation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::Relation* relation_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static QueryPredicateResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdatePredicate : public ::google::protobuf::Message {
 public:
  UpdatePredicate();
  virtual ~UpdatePredicate();

  UpdatePredicate(const UpdatePredicate& from);

  inline UpdatePredicate& operator=(const UpdatePredicate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePredicate& default_instance();

  void Swap(UpdatePredicate* other);

  // implements Message ----------------------------------------------

  UpdatePredicate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdatePredicate& from);
  void MergeFrom(const UpdatePredicate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .blox.connect.PredicateName predicate = 1;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::blox::connect::PredicateName& predicate() const;
  inline ::blox::connect::PredicateName* mutable_predicate();
  inline ::blox::connect::PredicateName* release_predicate();
  inline void set_allocated_predicate(::blox::connect::PredicateName* predicate);

  // required .blox.connect.Relation relation = 2;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 2;
  inline const ::blox::connect::Relation& relation() const;
  inline ::blox::connect::Relation* mutable_relation();
  inline ::blox::connect::Relation* release_relation();
  inline void set_allocated_relation(::blox::connect::Relation* relation);

  // required .blox.connect.DeltaModifier delta = 3;
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 3;
  inline ::blox::connect::DeltaModifier delta() const;
  inline void set_delta(::blox::connect::DeltaModifier value);

  // optional .blox.connect.EntityMode entity_mode = 4;
  inline bool has_entity_mode() const;
  inline void clear_entity_mode();
  static const int kEntityModeFieldNumber = 4;
  inline ::blox::connect::EntityMode entity_mode() const;
  inline void set_entity_mode(::blox::connect::EntityMode value);

  // @@protoc_insertion_point(class_scope:blox.connect.UpdatePredicate)
 private:
  inline void set_has_predicate();
  inline void clear_has_predicate();
  inline void set_has_relation();
  inline void clear_has_relation();
  inline void set_has_delta();
  inline void clear_has_delta();
  inline void set_has_entity_mode();
  inline void clear_has_entity_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::PredicateName* predicate_;
  ::blox::connect::Relation* relation_;
  int delta_;
  int entity_mode_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static UpdatePredicate* default_instance_;
};
// -------------------------------------------------------------------

class UpdatePredicateResponse : public ::google::protobuf::Message {
 public:
  UpdatePredicateResponse();
  virtual ~UpdatePredicateResponse();

  UpdatePredicateResponse(const UpdatePredicateResponse& from);

  inline UpdatePredicateResponse& operator=(const UpdatePredicateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePredicateResponse& default_instance();

  void Swap(UpdatePredicateResponse* other);

  // implements Message ----------------------------------------------

  UpdatePredicateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdatePredicateResponse& from);
  void MergeFrom(const UpdatePredicateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.UpdatePredicateResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static UpdatePredicateResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetPredicateInfo : public ::google::protobuf::Message {
 public:
  GetPredicateInfo();
  virtual ~GetPredicateInfo();

  GetPredicateInfo(const GetPredicateInfo& from);

  inline GetPredicateInfo& operator=(const GetPredicateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPredicateInfo& default_instance();

  void Swap(GetPredicateInfo* other);

  // implements Message ----------------------------------------------

  GetPredicateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPredicateInfo& from);
  void MergeFrom(const GetPredicateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .blox.connect.PredicateName predicate = 1;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::blox::connect::PredicateName& predicate() const;
  inline ::blox::connect::PredicateName* mutable_predicate();
  inline ::blox::connect::PredicateName* release_predicate();
  inline void set_allocated_predicate(::blox::connect::PredicateName* predicate);

  // @@protoc_insertion_point(class_scope:blox.connect.GetPredicateInfo)
 private:
  inline void set_has_predicate();
  inline void clear_has_predicate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::PredicateName* predicate_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GetPredicateInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetPredicateInfoResponse : public ::google::protobuf::Message {
 public:
  GetPredicateInfoResponse();
  virtual ~GetPredicateInfoResponse();

  GetPredicateInfoResponse(const GetPredicateInfoResponse& from);

  inline GetPredicateInfoResponse& operator=(const GetPredicateInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPredicateInfoResponse& default_instance();

  void Swap(GetPredicateInfoResponse* other);

  // implements Message ----------------------------------------------

  GetPredicateInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPredicateInfoResponse& from);
  void MergeFrom(const GetPredicateInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .blox.common.protocol.PredicateInfo info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::blox::common::protocol::PredicateInfo& info() const;
  inline ::blox::common::protocol::PredicateInfo* mutable_info();
  inline ::blox::common::protocol::PredicateInfo* release_info();
  inline void set_allocated_info(::blox::common::protocol::PredicateInfo* info);

  // @@protoc_insertion_point(class_scope:blox.connect.GetPredicateInfoResponse)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::common::protocol::PredicateInfo* info_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GetPredicateInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetPredicateInfoBulk : public ::google::protobuf::Message {
 public:
  GetPredicateInfoBulk();
  virtual ~GetPredicateInfoBulk();

  GetPredicateInfoBulk(const GetPredicateInfoBulk& from);

  inline GetPredicateInfoBulk& operator=(const GetPredicateInfoBulk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPredicateInfoBulk& default_instance();

  void Swap(GetPredicateInfoBulk* other);

  // implements Message ----------------------------------------------

  GetPredicateInfoBulk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPredicateInfoBulk& from);
  void MergeFrom(const GetPredicateInfoBulk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox.connect.PredicateName predicate = 1;
  inline int predicate_size() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::blox::connect::PredicateName& predicate(int index) const;
  inline ::blox::connect::PredicateName* mutable_predicate(int index);
  inline ::blox::connect::PredicateName* add_predicate();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >&
      predicate() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >*
      mutable_predicate();

  // repeated .blox.connect.PredicateName omit = 2;
  inline int omit_size() const;
  inline void clear_omit();
  static const int kOmitFieldNumber = 2;
  inline const ::blox::connect::PredicateName& omit(int index) const;
  inline ::blox::connect::PredicateName* mutable_omit(int index);
  inline ::blox::connect::PredicateName* add_omit();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >&
      omit() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >*
      mutable_omit();

  // @@protoc_insertion_point(class_scope:blox.connect.GetPredicateInfoBulk)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName > predicate_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName > omit_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GetPredicateInfoBulk* default_instance_;
};
// -------------------------------------------------------------------

class GetPredicateInfoBulkResponse : public ::google::protobuf::Message {
 public:
  GetPredicateInfoBulkResponse();
  virtual ~GetPredicateInfoBulkResponse();

  GetPredicateInfoBulkResponse(const GetPredicateInfoBulkResponse& from);

  inline GetPredicateInfoBulkResponse& operator=(const GetPredicateInfoBulkResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPredicateInfoBulkResponse& default_instance();

  void Swap(GetPredicateInfoBulkResponse* other);

  // implements Message ----------------------------------------------

  GetPredicateInfoBulkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPredicateInfoBulkResponse& from);
  void MergeFrom(const GetPredicateInfoBulkResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox.common.protocol.PredicateInfo info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::blox::common::protocol::PredicateInfo& info(int index) const;
  inline ::blox::common::protocol::PredicateInfo* mutable_info(int index);
  inline ::blox::common::protocol::PredicateInfo* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicateInfo >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicateInfo >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:blox.connect.GetPredicateInfoBulkResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicateInfo > info_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GetPredicateInfoBulkResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetPredicatePopcount : public ::google::protobuf::Message {
 public:
  GetPredicatePopcount();
  virtual ~GetPredicatePopcount();

  GetPredicatePopcount(const GetPredicatePopcount& from);

  inline GetPredicatePopcount& operator=(const GetPredicatePopcount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPredicatePopcount& default_instance();

  void Swap(GetPredicatePopcount* other);

  // implements Message ----------------------------------------------

  GetPredicatePopcount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPredicatePopcount& from);
  void MergeFrom(const GetPredicatePopcount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool all = 1 [default = true];
  inline bool has_all() const;
  inline void clear_all();
  static const int kAllFieldNumber = 1;
  inline bool all() const;
  inline void set_all(bool value);

  // repeated .blox.connect.PredicateName predicate = 2;
  inline int predicate_size() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 2;
  inline const ::blox::connect::PredicateName& predicate(int index) const;
  inline ::blox::connect::PredicateName* mutable_predicate(int index);
  inline ::blox::connect::PredicateName* add_predicate();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >&
      predicate() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >*
      mutable_predicate();

  // optional string include_regexp = 3;
  inline bool has_include_regexp() const;
  inline void clear_include_regexp();
  static const int kIncludeRegexpFieldNumber = 3;
  inline const ::std::string& include_regexp() const;
  inline void set_include_regexp(const ::std::string& value);
  inline void set_include_regexp(const char* value);
  inline void set_include_regexp(const char* value, size_t size);
  inline ::std::string* mutable_include_regexp();
  inline ::std::string* release_include_regexp();
  inline void set_allocated_include_regexp(::std::string* include_regexp);

  // optional string exclude_regexp = 4;
  inline bool has_exclude_regexp() const;
  inline void clear_exclude_regexp();
  static const int kExcludeRegexpFieldNumber = 4;
  inline const ::std::string& exclude_regexp() const;
  inline void set_exclude_regexp(const ::std::string& value);
  inline void set_exclude_regexp(const char* value);
  inline void set_exclude_regexp(const char* value, size_t size);
  inline ::std::string* mutable_exclude_regexp();
  inline ::std::string* release_exclude_regexp();
  inline void set_allocated_exclude_regexp(::std::string* exclude_regexp);

  // optional bool only_predicate_names = 5 [default = false];
  inline bool has_only_predicate_names() const;
  inline void clear_only_predicate_names();
  static const int kOnlyPredicateNamesFieldNumber = 5;
  inline bool only_predicate_names() const;
  inline void set_only_predicate_names(bool value);

  // optional bool estimated = 6 [default = false];
  inline bool has_estimated() const;
  inline void clear_estimated();
  static const int kEstimatedFieldNumber = 6;
  inline bool estimated() const;
  inline void set_estimated(bool value);

  // optional bool include_default = 7 [default = false];
  inline bool has_include_default() const;
  inline void clear_include_default();
  static const int kIncludeDefaultFieldNumber = 7;
  inline bool include_default() const;
  inline void set_include_default(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.GetPredicatePopcount)
 private:
  inline void set_has_all();
  inline void clear_has_all();
  inline void set_has_include_regexp();
  inline void clear_has_include_regexp();
  inline void set_has_exclude_regexp();
  inline void clear_has_exclude_regexp();
  inline void set_has_only_predicate_names();
  inline void clear_has_only_predicate_names();
  inline void set_has_estimated();
  inline void clear_has_estimated();
  inline void set_has_include_default();
  inline void clear_has_include_default();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName > predicate_;
  ::std::string* include_regexp_;
  ::std::string* exclude_regexp_;
  bool all_;
  bool only_predicate_names_;
  bool estimated_;
  bool include_default_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GetPredicatePopcount* default_instance_;
};
// -------------------------------------------------------------------

class GetPredicatePopcountResponse : public ::google::protobuf::Message {
 public:
  GetPredicatePopcountResponse();
  virtual ~GetPredicatePopcountResponse();

  GetPredicatePopcountResponse(const GetPredicatePopcountResponse& from);

  inline GetPredicatePopcountResponse& operator=(const GetPredicatePopcountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPredicatePopcountResponse& default_instance();

  void Swap(GetPredicatePopcountResponse* other);

  // implements Message ----------------------------------------------

  GetPredicatePopcountResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPredicatePopcountResponse& from);
  void MergeFrom(const GetPredicatePopcountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox.common.protocol.PredicatePopcount popcount = 1;
  inline int popcount_size() const;
  inline void clear_popcount();
  static const int kPopcountFieldNumber = 1;
  inline const ::blox::common::protocol::PredicatePopcount& popcount(int index) const;
  inline ::blox::common::protocol::PredicatePopcount* mutable_popcount(int index);
  inline ::blox::common::protocol::PredicatePopcount* add_popcount();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicatePopcount >&
      popcount() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicatePopcount >*
      mutable_popcount();

  // @@protoc_insertion_point(class_scope:blox.connect.GetPredicatePopcountResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicatePopcount > popcount_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GetPredicatePopcountResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetProtocolDescriptors : public ::google::protobuf::Message {
 public:
  GetProtocolDescriptors();
  virtual ~GetProtocolDescriptors();

  GetProtocolDescriptors(const GetProtocolDescriptors& from);

  inline GetProtocolDescriptors& operator=(const GetProtocolDescriptors& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetProtocolDescriptors& default_instance();

  void Swap(GetProtocolDescriptors* other);

  // implements Message ----------------------------------------------

  GetProtocolDescriptors* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetProtocolDescriptors& from);
  void MergeFrom(const GetProtocolDescriptors& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool all = 1;
  inline bool has_all() const;
  inline void clear_all();
  static const int kAllFieldNumber = 1;
  inline bool all() const;
  inline void set_all(bool value);

  // repeated string protocol_name = 2;
  inline int protocol_name_size() const;
  inline void clear_protocol_name();
  static const int kProtocolNameFieldNumber = 2;
  inline const ::std::string& protocol_name(int index) const;
  inline ::std::string* mutable_protocol_name(int index);
  inline void set_protocol_name(int index, const ::std::string& value);
  inline void set_protocol_name(int index, const char* value);
  inline void set_protocol_name(int index, const char* value, size_t size);
  inline ::std::string* add_protocol_name();
  inline void add_protocol_name(const ::std::string& value);
  inline void add_protocol_name(const char* value);
  inline void add_protocol_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& protocol_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_protocol_name();

  // optional string include_regexp = 3;
  inline bool has_include_regexp() const;
  inline void clear_include_regexp();
  static const int kIncludeRegexpFieldNumber = 3;
  inline const ::std::string& include_regexp() const;
  inline void set_include_regexp(const ::std::string& value);
  inline void set_include_regexp(const char* value);
  inline void set_include_regexp(const char* value, size_t size);
  inline ::std::string* mutable_include_regexp();
  inline ::std::string* release_include_regexp();
  inline void set_allocated_include_regexp(::std::string* include_regexp);

  // optional string exclude_regexp = 4;
  inline bool has_exclude_regexp() const;
  inline void clear_exclude_regexp();
  static const int kExcludeRegexpFieldNumber = 4;
  inline const ::std::string& exclude_regexp() const;
  inline void set_exclude_regexp(const ::std::string& value);
  inline void set_exclude_regexp(const char* value);
  inline void set_exclude_regexp(const char* value, size_t size);
  inline ::std::string* mutable_exclude_regexp();
  inline ::std::string* release_exclude_regexp();
  inline void set_allocated_exclude_regexp(::std::string* exclude_regexp);

  // @@protoc_insertion_point(class_scope:blox.connect.GetProtocolDescriptors)
 private:
  inline void set_has_all();
  inline void clear_has_all();
  inline void set_has_include_regexp();
  inline void clear_has_include_regexp();
  inline void set_has_exclude_regexp();
  inline void clear_has_exclude_regexp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> protocol_name_;
  ::std::string* include_regexp_;
  ::std::string* exclude_regexp_;
  bool all_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GetProtocolDescriptors* default_instance_;
};
// -------------------------------------------------------------------

class GetProtocolDescriptorsResponse : public ::google::protobuf::Message {
 public:
  GetProtocolDescriptorsResponse();
  virtual ~GetProtocolDescriptorsResponse();

  GetProtocolDescriptorsResponse(const GetProtocolDescriptorsResponse& from);

  inline GetProtocolDescriptorsResponse& operator=(const GetProtocolDescriptorsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetProtocolDescriptorsResponse& default_instance();

  void Swap(GetProtocolDescriptorsResponse* other);

  // implements Message ----------------------------------------------

  GetProtocolDescriptorsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetProtocolDescriptorsResponse& from);
  void MergeFrom(const GetProtocolDescriptorsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox.connect.ProtocolDescriptor protocols = 1;
  inline int protocols_size() const;
  inline void clear_protocols();
  static const int kProtocolsFieldNumber = 1;
  inline const ::blox::connect::ProtocolDescriptor& protocols(int index) const;
  inline ::blox::connect::ProtocolDescriptor* mutable_protocols(int index);
  inline ::blox::connect::ProtocolDescriptor* add_protocols();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ProtocolDescriptor >&
      protocols() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ProtocolDescriptor >*
      mutable_protocols();

  // @@protoc_insertion_point(class_scope:blox.connect.GetProtocolDescriptorsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::ProtocolDescriptor > protocols_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GetProtocolDescriptorsResponse* default_instance_;
};
// -------------------------------------------------------------------

class ProtocolDescriptor : public ::google::protobuf::Message {
 public:
  ProtocolDescriptor();
  virtual ~ProtocolDescriptor();

  ProtocolDescriptor(const ProtocolDescriptor& from);

  inline ProtocolDescriptor& operator=(const ProtocolDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolDescriptor& default_instance();

  void Swap(ProtocolDescriptor* other);

  // implements Message ----------------------------------------------

  ProtocolDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtocolDescriptor& from);
  void MergeFrom(const ProtocolDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bytes descriptor_data = 2;
  inline bool has_descriptor_data() const;
  inline void clear_descriptor_data();
  static const int kDescriptorDataFieldNumber = 2;
  inline const ::std::string& descriptor_data() const;
  inline void set_descriptor_data(const ::std::string& value);
  inline void set_descriptor_data(const char* value);
  inline void set_descriptor_data(const void* value, size_t size);
  inline ::std::string* mutable_descriptor_data();
  inline ::std::string* release_descriptor_data();
  inline void set_allocated_descriptor_data(::std::string* descriptor_data);

  // @@protoc_insertion_point(class_scope:blox.connect.ProtocolDescriptor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_descriptor_data();
  inline void clear_has_descriptor_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* descriptor_data_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ProtocolDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class ImportProtoBuf : public ::google::protobuf::Message {
 public:
  ImportProtoBuf();
  virtual ~ImportProtoBuf();

  ImportProtoBuf(const ImportProtoBuf& from);

  inline ImportProtoBuf& operator=(const ImportProtoBuf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportProtoBuf& default_instance();

  void Swap(ImportProtoBuf* other);

  // implements Message ----------------------------------------------

  ImportProtoBuf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImportProtoBuf& from);
  void MergeFrom(const ImportProtoBuf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string protocol = 1;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // required string type_name = 2;
  inline bool has_type_name() const;
  inline void clear_type_name();
  static const int kTypeNameFieldNumber = 2;
  inline const ::std::string& type_name() const;
  inline void set_type_name(const ::std::string& value);
  inline void set_type_name(const char* value);
  inline void set_type_name(const char* value, size_t size);
  inline ::std::string* mutable_type_name();
  inline ::std::string* release_type_name();
  inline void set_allocated_type_name(::std::string* type_name);

  // required bytes message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:blox.connect.ImportProtoBuf)
 private:
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_type_name();
  inline void clear_has_type_name();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* protocol_;
  ::std::string* type_name_;
  ::std::string* message_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ImportProtoBuf* default_instance_;
};
// -------------------------------------------------------------------

class ImportProtoBufResponse : public ::google::protobuf::Message {
 public:
  ImportProtoBufResponse();
  virtual ~ImportProtoBufResponse();

  ImportProtoBufResponse(const ImportProtoBufResponse& from);

  inline ImportProtoBufResponse& operator=(const ImportProtoBufResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportProtoBufResponse& default_instance();

  void Swap(ImportProtoBufResponse* other);

  // implements Message ----------------------------------------------

  ImportProtoBufResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImportProtoBufResponse& from);
  void MergeFrom(const ImportProtoBufResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.ImportProtoBufResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ImportProtoBufResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExportProtoBuf : public ::google::protobuf::Message {
 public:
  ExportProtoBuf();
  virtual ~ExportProtoBuf();

  ExportProtoBuf(const ExportProtoBuf& from);

  inline ExportProtoBuf& operator=(const ExportProtoBuf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExportProtoBuf& default_instance();

  void Swap(ExportProtoBuf* other);

  // implements Message ----------------------------------------------

  ExportProtoBuf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExportProtoBuf& from);
  void MergeFrom(const ExportProtoBuf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string protocol = 1;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // required string type_name = 2;
  inline bool has_type_name() const;
  inline void clear_type_name();
  static const int kTypeNameFieldNumber = 2;
  inline const ::std::string& type_name() const;
  inline void set_type_name(const ::std::string& value);
  inline void set_type_name(const char* value);
  inline void set_type_name(const char* value, size_t size);
  inline ::std::string* mutable_type_name();
  inline ::std::string* release_type_name();
  inline void set_allocated_type_name(::std::string* type_name);

  // @@protoc_insertion_point(class_scope:blox.connect.ExportProtoBuf)
 private:
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_type_name();
  inline void clear_has_type_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* protocol_;
  ::std::string* type_name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ExportProtoBuf* default_instance_;
};
// -------------------------------------------------------------------

class ExportProtoBufResponse : public ::google::protobuf::Message {
 public:
  ExportProtoBufResponse();
  virtual ~ExportProtoBufResponse();

  ExportProtoBufResponse(const ExportProtoBufResponse& from);

  inline ExportProtoBufResponse& operator=(const ExportProtoBufResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExportProtoBufResponse& default_instance();

  void Swap(ExportProtoBufResponse* other);

  // implements Message ----------------------------------------------

  ExportProtoBufResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExportProtoBufResponse& from);
  void MergeFrom(const ExportProtoBufResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:blox.connect.ExportProtoBufResponse)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ExportProtoBufResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogMessage : public ::google::protobuf::Message {
 public:
  LogMessage();
  virtual ~LogMessage();

  LogMessage(const LogMessage& from);

  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMessage& default_instance();

  void Swap(LogMessage* other);

  // implements Message ----------------------------------------------

  LogMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogMessage& from);
  void MergeFrom(const LogMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:blox.connect.LogMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static LogMessage* default_instance_;
};
// -------------------------------------------------------------------

class LogMessageResponse : public ::google::protobuf::Message {
 public:
  LogMessageResponse();
  virtual ~LogMessageResponse();

  LogMessageResponse(const LogMessageResponse& from);

  inline LogMessageResponse& operator=(const LogMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMessageResponse& default_instance();

  void Swap(LogMessageResponse* other);

  // implements Message ----------------------------------------------

  LogMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogMessageResponse& from);
  void MergeFrom(const LogMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.LogMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static LogMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class ProtoAddSpec : public ::google::protobuf::Message {
 public:
  ProtoAddSpec();
  virtual ~ProtoAddSpec();

  ProtoAddSpec(const ProtoAddSpec& from);

  inline ProtoAddSpec& operator=(const ProtoAddSpec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoAddSpec& default_instance();

  void Swap(ProtoAddSpec* other);

  // implements Message ----------------------------------------------

  ProtoAddSpec* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoAddSpec& from);
  void MergeFrom(const ProtoAddSpec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bytes descriptor_msg = 2;
  inline bool has_descriptor_msg() const;
  inline void clear_descriptor_msg();
  static const int kDescriptorMsgFieldNumber = 2;
  inline const ::std::string& descriptor_msg() const;
  inline void set_descriptor_msg(const ::std::string& value);
  inline void set_descriptor_msg(const char* value);
  inline void set_descriptor_msg(const void* value, size_t size);
  inline ::std::string* mutable_descriptor_msg();
  inline ::std::string* release_descriptor_msg();
  inline void set_allocated_descriptor_msg(::std::string* descriptor_msg);

  // @@protoc_insertion_point(class_scope:blox.connect.ProtoAddSpec)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_descriptor_msg();
  inline void clear_has_descriptor_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* descriptor_msg_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ProtoAddSpec* default_instance_;
};
// -------------------------------------------------------------------

class ProtoAddSpecResponse : public ::google::protobuf::Message {
 public:
  ProtoAddSpecResponse();
  virtual ~ProtoAddSpecResponse();

  ProtoAddSpecResponse(const ProtoAddSpecResponse& from);

  inline ProtoAddSpecResponse& operator=(const ProtoAddSpecResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoAddSpecResponse& default_instance();

  void Swap(ProtoAddSpecResponse* other);

  // implements Message ----------------------------------------------

  ProtoAddSpecResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoAddSpecResponse& from);
  void MergeFrom(const ProtoAddSpecResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.ProtoAddSpecResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ProtoAddSpecResponse* default_instance_;
};
// -------------------------------------------------------------------

class BindBranchAlias : public ::google::protobuf::Message {
 public:
  BindBranchAlias();
  virtual ~BindBranchAlias();

  BindBranchAlias(const BindBranchAlias& from);

  inline BindBranchAlias& operator=(const BindBranchAlias& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindBranchAlias& default_instance();

  void Swap(BindBranchAlias* other);

  // implements Message ----------------------------------------------

  BindBranchAlias* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BindBranchAlias& from);
  void MergeFrom(const BindBranchAlias& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string alias = 1;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 1;
  inline const ::std::string& alias() const;
  inline void set_alias(const ::std::string& value);
  inline void set_alias(const char* value);
  inline void set_alias(const char* value, size_t size);
  inline ::std::string* mutable_alias();
  inline ::std::string* release_alias();
  inline void set_allocated_alias(::std::string* alias);

  // required string branch_name = 2;
  inline bool has_branch_name() const;
  inline void clear_branch_name();
  static const int kBranchNameFieldNumber = 2;
  inline const ::std::string& branch_name() const;
  inline void set_branch_name(const ::std::string& value);
  inline void set_branch_name(const char* value);
  inline void set_branch_name(const char* value, size_t size);
  inline ::std::string* mutable_branch_name();
  inline ::std::string* release_branch_name();
  inline void set_allocated_branch_name(::std::string* branch_name);

  // @@protoc_insertion_point(class_scope:blox.connect.BindBranchAlias)
 private:
  inline void set_has_alias();
  inline void clear_has_alias();
  inline void set_has_branch_name();
  inline void clear_has_branch_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* alias_;
  ::std::string* branch_name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static BindBranchAlias* default_instance_;
};
// -------------------------------------------------------------------

class BindBranchAliasResponse : public ::google::protobuf::Message {
 public:
  BindBranchAliasResponse();
  virtual ~BindBranchAliasResponse();

  BindBranchAliasResponse(const BindBranchAliasResponse& from);

  inline BindBranchAliasResponse& operator=(const BindBranchAliasResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindBranchAliasResponse& default_instance();

  void Swap(BindBranchAliasResponse* other);

  // implements Message ----------------------------------------------

  BindBranchAliasResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BindBranchAliasResponse& from);
  void MergeFrom(const BindBranchAliasResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.BindBranchAliasResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static BindBranchAliasResponse* default_instance_;
};
// -------------------------------------------------------------------

class GenerateFullUpdateDeltas : public ::google::protobuf::Message {
 public:
  GenerateFullUpdateDeltas();
  virtual ~GenerateFullUpdateDeltas();

  GenerateFullUpdateDeltas(const GenerateFullUpdateDeltas& from);

  inline GenerateFullUpdateDeltas& operator=(const GenerateFullUpdateDeltas& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenerateFullUpdateDeltas& default_instance();

  void Swap(GenerateFullUpdateDeltas* other);

  // implements Message ----------------------------------------------

  GenerateFullUpdateDeltas* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenerateFullUpdateDeltas& from);
  void MergeFrom(const GenerateFullUpdateDeltas& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .blox.connect.PredicateName predicate = 1;
  inline bool has_predicate() const;
  inline void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  inline const ::blox::connect::PredicateName& predicate() const;
  inline ::blox::connect::PredicateName* mutable_predicate();
  inline ::blox::connect::PredicateName* release_predicate();
  inline void set_allocated_predicate(::blox::connect::PredicateName* predicate);

  // @@protoc_insertion_point(class_scope:blox.connect.GenerateFullUpdateDeltas)
 private:
  inline void set_has_predicate();
  inline void clear_has_predicate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::PredicateName* predicate_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GenerateFullUpdateDeltas* default_instance_;
};
// -------------------------------------------------------------------

class GenerateFullUpdateDeltasResponse : public ::google::protobuf::Message {
 public:
  GenerateFullUpdateDeltasResponse();
  virtual ~GenerateFullUpdateDeltasResponse();

  GenerateFullUpdateDeltasResponse(const GenerateFullUpdateDeltasResponse& from);

  inline GenerateFullUpdateDeltasResponse& operator=(const GenerateFullUpdateDeltasResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenerateFullUpdateDeltasResponse& default_instance();

  void Swap(GenerateFullUpdateDeltasResponse* other);

  // implements Message ----------------------------------------------

  GenerateFullUpdateDeltasResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenerateFullUpdateDeltasResponse& from);
  void MergeFrom(const GenerateFullUpdateDeltasResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:blox.connect.GenerateFullUpdateDeltasResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GenerateFullUpdateDeltasResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteImportScript : public ::google::protobuf::Message {
 public:
  ExecuteImportScript();
  virtual ~ExecuteImportScript();

  ExecuteImportScript(const ExecuteImportScript& from);

  inline ExecuteImportScript& operator=(const ExecuteImportScript& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteImportScript& default_instance();

  void Swap(ExecuteImportScript* other);

  // implements Message ----------------------------------------------

  ExecuteImportScript* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecuteImportScript& from);
  void MergeFrom(const ExecuteImportScript& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string script_path = 1;
  inline bool has_script_path() const;
  inline void clear_script_path();
  static const int kScriptPathFieldNumber = 1;
  inline const ::std::string& script_path() const;
  inline void set_script_path(const ::std::string& value);
  inline void set_script_path(const char* value);
  inline void set_script_path(const char* value, size_t size);
  inline ::std::string* mutable_script_path();
  inline ::std::string* release_script_path();
  inline void set_allocated_script_path(::std::string* script_path);

  // optional bool incremental = 2;
  inline bool has_incremental() const;
  inline void clear_incremental();
  static const int kIncrementalFieldNumber = 2;
  inline bool incremental() const;
  inline void set_incremental(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.ExecuteImportScript)
 private:
  inline void set_has_script_path();
  inline void clear_has_script_path();
  inline void set_has_incremental();
  inline void clear_has_incremental();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* script_path_;
  bool incremental_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ExecuteImportScript* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteImportScriptResponse : public ::google::protobuf::Message {
 public:
  ExecuteImportScriptResponse();
  virtual ~ExecuteImportScriptResponse();

  ExecuteImportScriptResponse(const ExecuteImportScriptResponse& from);

  inline ExecuteImportScriptResponse& operator=(const ExecuteImportScriptResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteImportScriptResponse& default_instance();

  void Swap(ExecuteImportScriptResponse* other);

  // implements Message ----------------------------------------------

  ExecuteImportScriptResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecuteImportScriptResponse& from);
  void MergeFrom(const ExecuteImportScriptResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // @@protoc_insertion_point(class_scope:blox.connect.ExecuteImportScriptResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool success_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static ExecuteImportScriptResponse* default_instance_;
};
// -------------------------------------------------------------------

class FaultInjection : public ::google::protobuf::Message {
 public:
  FaultInjection();
  virtual ~FaultInjection();

  FaultInjection(const FaultInjection& from);

  inline FaultInjection& operator=(const FaultInjection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaultInjection& default_instance();

  void Swap(FaultInjection* other);

  // implements Message ----------------------------------------------

  FaultInjection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaultInjection& from);
  void MergeFrom(const FaultInjection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .blox.connect.FaultKind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::blox::connect::FaultKind kind() const;
  inline void set_kind(::blox::connect::FaultKind value);

  // optional uint32 seconds = 2;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 2;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blox.connect.FaultInjection)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_seconds();
  inline void clear_has_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int kind_;
  ::google::protobuf::uint32 seconds_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static FaultInjection* default_instance_;
};
// -------------------------------------------------------------------

class InputBinding : public ::google::protobuf::Message {
 public:
  InputBinding();
  virtual ~InputBinding();

  InputBinding(const InputBinding& from);

  inline InputBinding& operator=(const InputBinding& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputBinding& default_instance();

  void Swap(InputBinding* other);

  // implements Message ----------------------------------------------

  InputBinding* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputBinding& from);
  void MergeFrom(const InputBinding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .blox.connect.Relation relation = 2;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 2;
  inline const ::blox::connect::Relation& relation() const;
  inline ::blox::connect::Relation* mutable_relation();
  inline ::blox::connect::Relation* release_relation();
  inline void set_allocated_relation(::blox::connect::Relation* relation);

  // @@protoc_insertion_point(class_scope:blox.connect.InputBinding)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_relation();
  inline void clear_has_relation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::blox::connect::Relation* relation_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static InputBinding* default_instance_;
};
// -------------------------------------------------------------------

class Relation : public ::google::protobuf::Message {
 public:
  Relation();
  virtual ~Relation();

  Relation(const Relation& from);

  inline Relation& operator=(const Relation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Relation& default_instance();

  void Swap(Relation* other);

  // implements Message ----------------------------------------------

  Relation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Relation& from);
  void MergeFrom(const Relation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .blox.connect.Column column = 2;
  inline int column_size() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline const ::blox::connect::Column& column(int index) const;
  inline ::blox::connect::Column* mutable_column(int index);
  inline ::blox::connect::Column* add_column();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Column >&
      column() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Column >*
      mutable_column();

  // @@protoc_insertion_point(class_scope:blox.connect.Relation)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::blox::connect::Column > column_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static Relation* default_instance_;
};
// -------------------------------------------------------------------

class Column : public ::google::protobuf::Message {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Column& default_instance();

  void Swap(Column* other);

  // implements Message ----------------------------------------------

  Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .blox.connect.EntityColumn entity_column = 1;
  inline bool has_entity_column() const;
  inline void clear_entity_column();
  static const int kEntityColumnFieldNumber = 1;
  inline const ::blox::connect::EntityColumn& entity_column() const;
  inline ::blox::connect::EntityColumn* mutable_entity_column();
  inline ::blox::connect::EntityColumn* release_entity_column();
  inline void set_allocated_entity_column(::blox::connect::EntityColumn* entity_column);

  // optional .blox.connect.BoolColumn bool_column = 2;
  inline bool has_bool_column() const;
  inline void clear_bool_column();
  static const int kBoolColumnFieldNumber = 2;
  inline const ::blox::connect::BoolColumn& bool_column() const;
  inline ::blox::connect::BoolColumn* mutable_bool_column();
  inline ::blox::connect::BoolColumn* release_bool_column();
  inline void set_allocated_bool_column(::blox::connect::BoolColumn* bool_column);

  // optional .blox.connect.Int64Column int64_column = 4;
  inline bool has_int64_column() const;
  inline void clear_int64_column();
  static const int kInt64ColumnFieldNumber = 4;
  inline const ::blox::connect::Int64Column& int64_column() const;
  inline ::blox::connect::Int64Column* mutable_int64_column();
  inline ::blox::connect::Int64Column* release_int64_column();
  inline void set_allocated_int64_column(::blox::connect::Int64Column* int64_column);

  // optional .blox.connect.UInt64Column uint64_column = 6;
  inline bool has_uint64_column() const;
  inline void clear_uint64_column();
  static const int kUint64ColumnFieldNumber = 6;
  inline const ::blox::connect::UInt64Column& uint64_column() const;
  inline ::blox::connect::UInt64Column* mutable_uint64_column();
  inline ::blox::connect::UInt64Column* release_uint64_column();
  inline void set_allocated_uint64_column(::blox::connect::UInt64Column* uint64_column);

  // optional .blox.connect.Float64Column float64_column = 8;
  inline bool has_float64_column() const;
  inline void clear_float64_column();
  static const int kFloat64ColumnFieldNumber = 8;
  inline const ::blox::connect::Float64Column& float64_column() const;
  inline ::blox::connect::Float64Column* mutable_float64_column();
  inline ::blox::connect::Float64Column* release_float64_column();
  inline void set_allocated_float64_column(::blox::connect::Float64Column* float64_column);

  // optional .blox.connect.StringColumn string_column = 9;
  inline bool has_string_column() const;
  inline void clear_string_column();
  static const int kStringColumnFieldNumber = 9;
  inline const ::blox::connect::StringColumn& string_column() const;
  inline ::blox::connect::StringColumn* mutable_string_column();
  inline ::blox::connect::StringColumn* release_string_column();
  inline void set_allocated_string_column(::blox::connect::StringColumn* string_column);

  // optional .blox.connect.DateTimeColumn datetime_column = 10;
  inline bool has_datetime_column() const;
  inline void clear_datetime_column();
  static const int kDatetimeColumnFieldNumber = 10;
  inline const ::blox::connect::DateTimeColumn& datetime_column() const;
  inline ::blox::connect::DateTimeColumn* mutable_datetime_column();
  inline ::blox::connect::DateTimeColumn* release_datetime_column();
  inline void set_allocated_datetime_column(::blox::connect::DateTimeColumn* datetime_column);

  // optional .blox.connect.Decimal128Column decimal128_column = 14;
  inline bool has_decimal128_column() const;
  inline void clear_decimal128_column();
  static const int kDecimal128ColumnFieldNumber = 14;
  inline const ::blox::connect::Decimal128Column& decimal128_column() const;
  inline ::blox::connect::Decimal128Column* mutable_decimal128_column();
  inline ::blox::connect::Decimal128Column* release_decimal128_column();
  inline void set_allocated_decimal128_column(::blox::connect::Decimal128Column* decimal128_column);

  // optional .blox.connect.Int128Column int128_column = 15;
  inline bool has_int128_column() const;
  inline void clear_int128_column();
  static const int kInt128ColumnFieldNumber = 15;
  inline const ::blox::connect::Int128Column& int128_column() const;
  inline ::blox::connect::Int128Column* mutable_int128_column();
  inline ::blox::connect::Int128Column* release_int128_column();
  inline void set_allocated_int128_column(::blox::connect::Int128Column* int128_column);

  // @@protoc_insertion_point(class_scope:blox.connect.Column)
 private:
  inline void set_has_entity_column();
  inline void clear_has_entity_column();
  inline void set_has_bool_column();
  inline void clear_has_bool_column();
  inline void set_has_int64_column();
  inline void clear_has_int64_column();
  inline void set_has_uint64_column();
  inline void clear_has_uint64_column();
  inline void set_has_float64_column();
  inline void clear_has_float64_column();
  inline void set_has_string_column();
  inline void clear_has_string_column();
  inline void set_has_datetime_column();
  inline void clear_has_datetime_column();
  inline void set_has_decimal128_column();
  inline void clear_has_decimal128_column();
  inline void set_has_int128_column();
  inline void clear_has_int128_column();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::EntityColumn* entity_column_;
  ::blox::connect::BoolColumn* bool_column_;
  ::blox::connect::Int64Column* int64_column_;
  ::blox::connect::UInt64Column* uint64_column_;
  ::blox::connect::Float64Column* float64_column_;
  ::blox::connect::StringColumn* string_column_;
  ::blox::connect::DateTimeColumn* datetime_column_;
  ::blox::connect::Decimal128Column* decimal128_column_;
  ::blox::connect::Int128Column* int128_column_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static Column* default_instance_;
};
// -------------------------------------------------------------------

class BoolColumn : public ::google::protobuf::Message {
 public:
  BoolColumn();
  virtual ~BoolColumn();

  BoolColumn(const BoolColumn& from);

  inline BoolColumn& operator=(const BoolColumn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoolColumn& default_instance();

  void Swap(BoolColumn* other);

  // implements Message ----------------------------------------------

  BoolColumn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoolColumn& from);
  void MergeFrom(const BoolColumn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool values = 1 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline bool values(int index) const;
  inline void set_values(int index, bool value);
  inline void add_values(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      values() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:blox.connect.BoolColumn)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< bool > values_;
  mutable int _values_cached_byte_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static BoolColumn* default_instance_;
};
// -------------------------------------------------------------------

class Int64Column : public ::google::protobuf::Message {
 public:
  Int64Column();
  virtual ~Int64Column();

  Int64Column(const Int64Column& from);

  inline Int64Column& operator=(const Int64Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Int64Column& default_instance();

  void Swap(Int64Column* other);

  // implements Message ----------------------------------------------

  Int64Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Int64Column& from);
  void MergeFrom(const Int64Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 values = 1 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline ::google::protobuf::int64 values(int index) const;
  inline void set_values(int index, ::google::protobuf::int64 value);
  inline void add_values(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:blox.connect.Int64Column)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > values_;
  mutable int _values_cached_byte_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static Int64Column* default_instance_;
};
// -------------------------------------------------------------------

class UInt64Column : public ::google::protobuf::Message {
 public:
  UInt64Column();
  virtual ~UInt64Column();

  UInt64Column(const UInt64Column& from);

  inline UInt64Column& operator=(const UInt64Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UInt64Column& default_instance();

  void Swap(UInt64Column* other);

  // implements Message ----------------------------------------------

  UInt64Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UInt64Column& from);
  void MergeFrom(const UInt64Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 values = 1 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline ::google::protobuf::uint64 values(int index) const;
  inline void set_values(int index, ::google::protobuf::uint64 value);
  inline void add_values(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:blox.connect.UInt64Column)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > values_;
  mutable int _values_cached_byte_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static UInt64Column* default_instance_;
};
// -------------------------------------------------------------------

class Float64Column : public ::google::protobuf::Message {
 public:
  Float64Column();
  virtual ~Float64Column();

  Float64Column(const Float64Column& from);

  inline Float64Column& operator=(const Float64Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Float64Column& default_instance();

  void Swap(Float64Column* other);

  // implements Message ----------------------------------------------

  Float64Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Float64Column& from);
  void MergeFrom(const Float64Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double values = 1 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline double values(int index) const;
  inline void set_values(int index, double value);
  inline void add_values(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      values() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:blox.connect.Float64Column)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > values_;
  mutable int _values_cached_byte_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static Float64Column* default_instance_;
};
// -------------------------------------------------------------------

class DateTimeColumn : public ::google::protobuf::Message {
 public:
  DateTimeColumn();
  virtual ~DateTimeColumn();

  DateTimeColumn(const DateTimeColumn& from);

  inline DateTimeColumn& operator=(const DateTimeColumn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DateTimeColumn& default_instance();

  void Swap(DateTimeColumn* other);

  // implements Message ----------------------------------------------

  DateTimeColumn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DateTimeColumn& from);
  void MergeFrom(const DateTimeColumn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 values = 1 [packed = true];
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline ::google::protobuf::int64 values(int index) const;
  inline void set_values(int index, ::google::protobuf::int64 value);
  inline void add_values(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:blox.connect.DateTimeColumn)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > values_;
  mutable int _values_cached_byte_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static DateTimeColumn* default_instance_;
};
// -------------------------------------------------------------------

class StringColumn : public ::google::protobuf::Message {
 public:
  StringColumn();
  virtual ~StringColumn();

  StringColumn(const StringColumn& from);

  inline StringColumn& operator=(const StringColumn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringColumn& default_instance();

  void Swap(StringColumn* other);

  // implements Message ----------------------------------------------

  StringColumn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringColumn& from);
  void MergeFrom(const StringColumn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string values = 1;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:blox.connect.StringColumn)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static StringColumn* default_instance_;
};
// -------------------------------------------------------------------

class Decimal128Column : public ::google::protobuf::Message {
 public:
  Decimal128Column();
  virtual ~Decimal128Column();

  Decimal128Column(const Decimal128Column& from);

  inline Decimal128Column& operator=(const Decimal128Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Decimal128Column& default_instance();

  void Swap(Decimal128Column* other);

  // implements Message ----------------------------------------------

  Decimal128Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Decimal128Column& from);
  void MergeFrom(const Decimal128Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool negative = 1 [packed = true];
  inline int negative_size() const;
  inline void clear_negative();
  static const int kNegativeFieldNumber = 1;
  inline bool negative(int index) const;
  inline void set_negative(int index, bool value);
  inline void add_negative(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      negative() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_negative();

  // repeated uint64 integral_digits = 2 [packed = true];
  inline int integral_digits_size() const;
  inline void clear_integral_digits();
  static const int kIntegralDigitsFieldNumber = 2;
  inline ::google::protobuf::uint64 integral_digits(int index) const;
  inline void set_integral_digits(int index, ::google::protobuf::uint64 value);
  inline void add_integral_digits(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      integral_digits() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_integral_digits();

  // repeated uint64 fraction_digits = 3 [packed = true];
  inline int fraction_digits_size() const;
  inline void clear_fraction_digits();
  static const int kFractionDigitsFieldNumber = 3;
  inline ::google::protobuf::uint64 fraction_digits(int index) const;
  inline void set_fraction_digits(int index, ::google::protobuf::uint64 value);
  inline void add_fraction_digits(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      fraction_digits() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_fraction_digits();

  // @@protoc_insertion_point(class_scope:blox.connect.Decimal128Column)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< bool > negative_;
  mutable int _negative_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > integral_digits_;
  mutable int _integral_digits_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > fraction_digits_;
  mutable int _fraction_digits_cached_byte_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static Decimal128Column* default_instance_;
};
// -------------------------------------------------------------------

class Int128Column : public ::google::protobuf::Message {
 public:
  Int128Column();
  virtual ~Int128Column();

  Int128Column(const Int128Column& from);

  inline Int128Column& operator=(const Int128Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Int128Column& default_instance();

  void Swap(Int128Column* other);

  // implements Message ----------------------------------------------

  Int128Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Int128Column& from);
  void MergeFrom(const Int128Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 high = 1 [packed = true];
  inline int high_size() const;
  inline void clear_high();
  static const int kHighFieldNumber = 1;
  inline ::google::protobuf::uint64 high(int index) const;
  inline void set_high(int index, ::google::protobuf::uint64 value);
  inline void add_high(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      high() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_high();

  // repeated uint64 low = 2 [packed = true];
  inline int low_size() const;
  inline void clear_low();
  static const int kLowFieldNumber = 2;
  inline ::google::protobuf::uint64 low(int index) const;
  inline void set_low(int index, ::google::protobuf::uint64 value);
  inline void add_low(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      low() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_low();

  // @@protoc_insertion_point(class_scope:blox.connect.Int128Column)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > high_;
  mutable int _high_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > low_;
  mutable int _low_cached_byte_size_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static Int128Column* default_instance_;
};
// -------------------------------------------------------------------

class EntityColumn : public ::google::protobuf::Message {
 public:
  EntityColumn();
  virtual ~EntityColumn();

  EntityColumn(const EntityColumn& from);

  inline EntityColumn& operator=(const EntityColumn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityColumn& default_instance();

  void Swap(EntityColumn* other);

  // implements Message ----------------------------------------------

  EntityColumn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityColumn& from);
  void MergeFrom(const EntityColumn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .blox.connect.Column index_values = 2;
  inline bool has_index_values() const;
  inline void clear_index_values();
  static const int kIndexValuesFieldNumber = 2;
  inline const ::blox::connect::Column& index_values() const;
  inline ::blox::connect::Column* mutable_index_values();
  inline ::blox::connect::Column* release_index_values();
  inline void set_allocated_index_values(::blox::connect::Column* index_values);

  // optional .blox.connect.Column refmode_values = 3;
  inline bool has_refmode_values() const;
  inline void clear_refmode_values();
  static const int kRefmodeValuesFieldNumber = 3;
  inline const ::blox::connect::Column& refmode_values() const;
  inline ::blox::connect::Column* mutable_refmode_values();
  inline ::blox::connect::Column* release_refmode_values();
  inline void set_allocated_refmode_values(::blox::connect::Column* refmode_values);

  // @@protoc_insertion_point(class_scope:blox.connect.EntityColumn)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_index_values();
  inline void clear_has_index_values();
  inline void set_has_refmode_values();
  inline void clear_has_refmode_values();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::blox::connect::Column* index_values_;
  ::blox::connect::Column* refmode_values_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static EntityColumn* default_instance_;
};
// -------------------------------------------------------------------

class PredicateName : public ::google::protobuf::Message {
 public:
  PredicateName();
  virtual ~PredicateName();

  PredicateName(const PredicateName& from);

  inline PredicateName& operator=(const PredicateName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredicateName& default_instance();

  void Swap(PredicateName* other);

  // implements Message ----------------------------------------------

  PredicateName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PredicateName& from);
  void MergeFrom(const PredicateName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .blox.connect.LocalPredicateName local_name = 1;
  inline bool has_local_name() const;
  inline void clear_local_name();
  static const int kLocalNameFieldNumber = 1;
  inline const ::blox::connect::LocalPredicateName& local_name() const;
  inline ::blox::connect::LocalPredicateName* mutable_local_name();
  inline ::blox::connect::LocalPredicateName* release_local_name();
  inline void set_allocated_local_name(::blox::connect::LocalPredicateName* local_name);

  // optional .blox.connect.GlobalPredicateName global_name = 2;
  inline bool has_global_name() const;
  inline void clear_global_name();
  static const int kGlobalNameFieldNumber = 2;
  inline const ::blox::connect::GlobalPredicateName& global_name() const;
  inline ::blox::connect::GlobalPredicateName* mutable_global_name();
  inline ::blox::connect::GlobalPredicateName* release_global_name();
  inline void set_allocated_global_name(::blox::connect::GlobalPredicateName* global_name);

  // @@protoc_insertion_point(class_scope:blox.connect.PredicateName)
 private:
  inline void set_has_local_name();
  inline void clear_has_local_name();
  inline void set_has_global_name();
  inline void clear_has_global_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::connect::LocalPredicateName* local_name_;
  ::blox::connect::GlobalPredicateName* global_name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static PredicateName* default_instance_;
};
// -------------------------------------------------------------------

class LocalPredicateName : public ::google::protobuf::Message {
 public:
  LocalPredicateName();
  virtual ~LocalPredicateName();

  LocalPredicateName(const LocalPredicateName& from);

  inline LocalPredicateName& operator=(const LocalPredicateName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalPredicateName& default_instance();

  void Swap(LocalPredicateName* other);

  // implements Message ----------------------------------------------

  LocalPredicateName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalPredicateName& from);
  void MergeFrom(const LocalPredicateName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string local_name = 1;
  inline bool has_local_name() const;
  inline void clear_local_name();
  static const int kLocalNameFieldNumber = 1;
  inline const ::std::string& local_name() const;
  inline void set_local_name(const ::std::string& value);
  inline void set_local_name(const char* value);
  inline void set_local_name(const char* value, size_t size);
  inline ::std::string* mutable_local_name();
  inline ::std::string* release_local_name();
  inline void set_allocated_local_name(::std::string* local_name);

  // required string block_name = 2;
  inline bool has_block_name() const;
  inline void clear_block_name();
  static const int kBlockNameFieldNumber = 2;
  inline const ::std::string& block_name() const;
  inline void set_block_name(const ::std::string& value);
  inline void set_block_name(const char* value);
  inline void set_block_name(const char* value, size_t size);
  inline ::std::string* mutable_block_name();
  inline ::std::string* release_block_name();
  inline void set_allocated_block_name(::std::string* block_name);

  // @@protoc_insertion_point(class_scope:blox.connect.LocalPredicateName)
 private:
  inline void set_has_local_name();
  inline void clear_has_local_name();
  inline void set_has_block_name();
  inline void clear_has_block_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* local_name_;
  ::std::string* block_name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static LocalPredicateName* default_instance_;
};
// -------------------------------------------------------------------

class GlobalPredicateName : public ::google::protobuf::Message {
 public:
  GlobalPredicateName();
  virtual ~GlobalPredicateName();

  GlobalPredicateName(const GlobalPredicateName& from);

  inline GlobalPredicateName& operator=(const GlobalPredicateName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalPredicateName& default_instance();

  void Swap(GlobalPredicateName* other);

  // implements Message ----------------------------------------------

  GlobalPredicateName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalPredicateName& from);
  void MergeFrom(const GlobalPredicateName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string qualified_name = 1;
  inline bool has_qualified_name() const;
  inline void clear_qualified_name();
  static const int kQualifiedNameFieldNumber = 1;
  inline const ::std::string& qualified_name() const;
  inline void set_qualified_name(const ::std::string& value);
  inline void set_qualified_name(const char* value);
  inline void set_qualified_name(const char* value, size_t size);
  inline ::std::string* mutable_qualified_name();
  inline ::std::string* release_qualified_name();
  inline void set_allocated_qualified_name(::std::string* qualified_name);

  // @@protoc_insertion_point(class_scope:blox.connect.GlobalPredicateName)
 private:
  inline void set_has_qualified_name();
  inline void clear_has_qualified_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* qualified_name_;
  friend void  protobuf_AddDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_AssignDesc_blox_2fconnect_2fBloxCommand_2eproto();
  friend void protobuf_ShutdownFile_blox_2fconnect_2fBloxCommand_2eproto();

  void InitAsDefaultInstance();
  static GlobalPredicateName* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// optional .blox.connect.AddBlock add_block = 1;
inline bool Command::has_add_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_add_block() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_add_block() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_add_block() {
  if (add_block_ != NULL) add_block_->::blox::connect::AddBlock::Clear();
  clear_has_add_block();
}
inline const ::blox::connect::AddBlock& Command::add_block() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.add_block)
  return add_block_ != NULL ? *add_block_ : *default_instance_->add_block_;
}
inline ::blox::connect::AddBlock* Command::mutable_add_block() {
  set_has_add_block();
  if (add_block_ == NULL) add_block_ = new ::blox::connect::AddBlock;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.add_block)
  return add_block_;
}
inline ::blox::connect::AddBlock* Command::release_add_block() {
  clear_has_add_block();
  ::blox::connect::AddBlock* temp = add_block_;
  add_block_ = NULL;
  return temp;
}
inline void Command::set_allocated_add_block(::blox::connect::AddBlock* add_block) {
  delete add_block_;
  add_block_ = add_block;
  if (add_block) {
    set_has_add_block();
  } else {
    clear_has_add_block();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.add_block)
}

// optional .blox.connect.InstallLibrary install_library = 2;
inline bool Command::has_install_library() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_install_library() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_install_library() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_install_library() {
  if (install_library_ != NULL) install_library_->::blox::connect::InstallLibrary::Clear();
  clear_has_install_library();
}
inline const ::blox::connect::InstallLibrary& Command::install_library() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.install_library)
  return install_library_ != NULL ? *install_library_ : *default_instance_->install_library_;
}
inline ::blox::connect::InstallLibrary* Command::mutable_install_library() {
  set_has_install_library();
  if (install_library_ == NULL) install_library_ = new ::blox::connect::InstallLibrary;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.install_library)
  return install_library_;
}
inline ::blox::connect::InstallLibrary* Command::release_install_library() {
  clear_has_install_library();
  ::blox::connect::InstallLibrary* temp = install_library_;
  install_library_ = NULL;
  return temp;
}
inline void Command::set_allocated_install_library(::blox::connect::InstallLibrary* install_library) {
  delete install_library_;
  install_library_ = install_library;
  if (install_library) {
    set_has_install_library();
  } else {
    clear_has_install_library();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.install_library)
}

// optional .blox.connect.ExecInactiveBlock exec_inactive = 3;
inline bool Command::has_exec_inactive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_exec_inactive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_exec_inactive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_exec_inactive() {
  if (exec_inactive_ != NULL) exec_inactive_->::blox::connect::ExecInactiveBlock::Clear();
  clear_has_exec_inactive();
}
inline const ::blox::connect::ExecInactiveBlock& Command::exec_inactive() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.exec_inactive)
  return exec_inactive_ != NULL ? *exec_inactive_ : *default_instance_->exec_inactive_;
}
inline ::blox::connect::ExecInactiveBlock* Command::mutable_exec_inactive() {
  set_has_exec_inactive();
  if (exec_inactive_ == NULL) exec_inactive_ = new ::blox::connect::ExecInactiveBlock;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.exec_inactive)
  return exec_inactive_;
}
inline ::blox::connect::ExecInactiveBlock* Command::release_exec_inactive() {
  clear_has_exec_inactive();
  ::blox::connect::ExecInactiveBlock* temp = exec_inactive_;
  exec_inactive_ = NULL;
  return temp;
}
inline void Command::set_allocated_exec_inactive(::blox::connect::ExecInactiveBlock* exec_inactive) {
  delete exec_inactive_;
  exec_inactive_ = exec_inactive;
  if (exec_inactive) {
    set_has_exec_inactive();
  } else {
    clear_has_exec_inactive();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.exec_inactive)
}

// optional .blox.connect.ExecBlock exec = 4;
inline bool Command::has_exec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_exec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_exec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_exec() {
  if (exec_ != NULL) exec_->::blox::connect::ExecBlock::Clear();
  clear_has_exec();
}
inline const ::blox::connect::ExecBlock& Command::exec() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.exec)
  return exec_ != NULL ? *exec_ : *default_instance_->exec_;
}
inline ::blox::connect::ExecBlock* Command::mutable_exec() {
  set_has_exec();
  if (exec_ == NULL) exec_ = new ::blox::connect::ExecBlock;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.exec)
  return exec_;
}
inline ::blox::connect::ExecBlock* Command::release_exec() {
  clear_has_exec();
  ::blox::connect::ExecBlock* temp = exec_;
  exec_ = NULL;
  return temp;
}
inline void Command::set_allocated_exec(::blox::connect::ExecBlock* exec) {
  delete exec_;
  exec_ = exec;
  if (exec) {
    set_has_exec();
  } else {
    clear_has_exec();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.exec)
}

// optional .blox.connect.QueryPredicate query_predicate = 5;
inline bool Command::has_query_predicate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_query_predicate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_query_predicate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_query_predicate() {
  if (query_predicate_ != NULL) query_predicate_->::blox::connect::QueryPredicate::Clear();
  clear_has_query_predicate();
}
inline const ::blox::connect::QueryPredicate& Command::query_predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.query_predicate)
  return query_predicate_ != NULL ? *query_predicate_ : *default_instance_->query_predicate_;
}
inline ::blox::connect::QueryPredicate* Command::mutable_query_predicate() {
  set_has_query_predicate();
  if (query_predicate_ == NULL) query_predicate_ = new ::blox::connect::QueryPredicate;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.query_predicate)
  return query_predicate_;
}
inline ::blox::connect::QueryPredicate* Command::release_query_predicate() {
  clear_has_query_predicate();
  ::blox::connect::QueryPredicate* temp = query_predicate_;
  query_predicate_ = NULL;
  return temp;
}
inline void Command::set_allocated_query_predicate(::blox::connect::QueryPredicate* query_predicate) {
  delete query_predicate_;
  query_predicate_ = query_predicate;
  if (query_predicate) {
    set_has_query_predicate();
  } else {
    clear_has_query_predicate();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.query_predicate)
}

// optional .blox.connect.UpdatePredicate update_predicate = 6;
inline bool Command::has_update_predicate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command::set_has_update_predicate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command::clear_has_update_predicate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command::clear_update_predicate() {
  if (update_predicate_ != NULL) update_predicate_->::blox::connect::UpdatePredicate::Clear();
  clear_has_update_predicate();
}
inline const ::blox::connect::UpdatePredicate& Command::update_predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.update_predicate)
  return update_predicate_ != NULL ? *update_predicate_ : *default_instance_->update_predicate_;
}
inline ::blox::connect::UpdatePredicate* Command::mutable_update_predicate() {
  set_has_update_predicate();
  if (update_predicate_ == NULL) update_predicate_ = new ::blox::connect::UpdatePredicate;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.update_predicate)
  return update_predicate_;
}
inline ::blox::connect::UpdatePredicate* Command::release_update_predicate() {
  clear_has_update_predicate();
  ::blox::connect::UpdatePredicate* temp = update_predicate_;
  update_predicate_ = NULL;
  return temp;
}
inline void Command::set_allocated_update_predicate(::blox::connect::UpdatePredicate* update_predicate) {
  delete update_predicate_;
  update_predicate_ = update_predicate;
  if (update_predicate) {
    set_has_update_predicate();
  } else {
    clear_has_update_predicate();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.update_predicate)
}

// optional .blox.connect.GetPredicateInfo pred_info = 7;
inline bool Command::has_pred_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command::set_has_pred_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command::clear_has_pred_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command::clear_pred_info() {
  if (pred_info_ != NULL) pred_info_->::blox::connect::GetPredicateInfo::Clear();
  clear_has_pred_info();
}
inline const ::blox::connect::GetPredicateInfo& Command::pred_info() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.pred_info)
  return pred_info_ != NULL ? *pred_info_ : *default_instance_->pred_info_;
}
inline ::blox::connect::GetPredicateInfo* Command::mutable_pred_info() {
  set_has_pred_info();
  if (pred_info_ == NULL) pred_info_ = new ::blox::connect::GetPredicateInfo;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.pred_info)
  return pred_info_;
}
inline ::blox::connect::GetPredicateInfo* Command::release_pred_info() {
  clear_has_pred_info();
  ::blox::connect::GetPredicateInfo* temp = pred_info_;
  pred_info_ = NULL;
  return temp;
}
inline void Command::set_allocated_pred_info(::blox::connect::GetPredicateInfo* pred_info) {
  delete pred_info_;
  pred_info_ = pred_info;
  if (pred_info) {
    set_has_pred_info();
  } else {
    clear_has_pred_info();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.pred_info)
}

// optional .blox.connect.ImportProtoBuf import_protobuf = 8;
inline bool Command::has_import_protobuf() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command::set_has_import_protobuf() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command::clear_has_import_protobuf() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command::clear_import_protobuf() {
  if (import_protobuf_ != NULL) import_protobuf_->::blox::connect::ImportProtoBuf::Clear();
  clear_has_import_protobuf();
}
inline const ::blox::connect::ImportProtoBuf& Command::import_protobuf() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.import_protobuf)
  return import_protobuf_ != NULL ? *import_protobuf_ : *default_instance_->import_protobuf_;
}
inline ::blox::connect::ImportProtoBuf* Command::mutable_import_protobuf() {
  set_has_import_protobuf();
  if (import_protobuf_ == NULL) import_protobuf_ = new ::blox::connect::ImportProtoBuf;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.import_protobuf)
  return import_protobuf_;
}
inline ::blox::connect::ImportProtoBuf* Command::release_import_protobuf() {
  clear_has_import_protobuf();
  ::blox::connect::ImportProtoBuf* temp = import_protobuf_;
  import_protobuf_ = NULL;
  return temp;
}
inline void Command::set_allocated_import_protobuf(::blox::connect::ImportProtoBuf* import_protobuf) {
  delete import_protobuf_;
  import_protobuf_ = import_protobuf;
  if (import_protobuf) {
    set_has_import_protobuf();
  } else {
    clear_has_import_protobuf();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.import_protobuf)
}

// optional .blox.connect.CompileBlock compile_block = 9;
inline bool Command::has_compile_block() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Command::set_has_compile_block() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Command::clear_has_compile_block() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Command::clear_compile_block() {
  if (compile_block_ != NULL) compile_block_->::blox::connect::CompileBlock::Clear();
  clear_has_compile_block();
}
inline const ::blox::connect::CompileBlock& Command::compile_block() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.compile_block)
  return compile_block_ != NULL ? *compile_block_ : *default_instance_->compile_block_;
}
inline ::blox::connect::CompileBlock* Command::mutable_compile_block() {
  set_has_compile_block();
  if (compile_block_ == NULL) compile_block_ = new ::blox::connect::CompileBlock;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.compile_block)
  return compile_block_;
}
inline ::blox::connect::CompileBlock* Command::release_compile_block() {
  clear_has_compile_block();
  ::blox::connect::CompileBlock* temp = compile_block_;
  compile_block_ = NULL;
  return temp;
}
inline void Command::set_allocated_compile_block(::blox::connect::CompileBlock* compile_block) {
  delete compile_block_;
  compile_block_ = compile_block;
  if (compile_block) {
    set_has_compile_block();
  } else {
    clear_has_compile_block();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.compile_block)
}

// optional .blox.connect.InstallProject install_project = 10;
inline bool Command::has_install_project() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Command::set_has_install_project() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Command::clear_has_install_project() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Command::clear_install_project() {
  if (install_project_ != NULL) install_project_->::blox::connect::InstallProject::Clear();
  clear_has_install_project();
}
inline const ::blox::connect::InstallProject& Command::install_project() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.install_project)
  return install_project_ != NULL ? *install_project_ : *default_instance_->install_project_;
}
inline ::blox::connect::InstallProject* Command::mutable_install_project() {
  set_has_install_project();
  if (install_project_ == NULL) install_project_ = new ::blox::connect::InstallProject;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.install_project)
  return install_project_;
}
inline ::blox::connect::InstallProject* Command::release_install_project() {
  clear_has_install_project();
  ::blox::connect::InstallProject* temp = install_project_;
  install_project_ = NULL;
  return temp;
}
inline void Command::set_allocated_install_project(::blox::connect::InstallProject* install_project) {
  delete install_project_;
  install_project_ = install_project;
  if (install_project) {
    set_has_install_project();
  } else {
    clear_has_install_project();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.install_project)
}

// optional .blox.connect.RemoveBlock remove_block = 11;
inline bool Command::has_remove_block() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Command::set_has_remove_block() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Command::clear_has_remove_block() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Command::clear_remove_block() {
  if (remove_block_ != NULL) remove_block_->::blox::connect::RemoveBlock::Clear();
  clear_has_remove_block();
}
inline const ::blox::connect::RemoveBlock& Command::remove_block() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.remove_block)
  return remove_block_ != NULL ? *remove_block_ : *default_instance_->remove_block_;
}
inline ::blox::connect::RemoveBlock* Command::mutable_remove_block() {
  set_has_remove_block();
  if (remove_block_ == NULL) remove_block_ = new ::blox::connect::RemoveBlock;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.remove_block)
  return remove_block_;
}
inline ::blox::connect::RemoveBlock* Command::release_remove_block() {
  clear_has_remove_block();
  ::blox::connect::RemoveBlock* temp = remove_block_;
  remove_block_ = NULL;
  return temp;
}
inline void Command::set_allocated_remove_block(::blox::connect::RemoveBlock* remove_block) {
  delete remove_block_;
  remove_block_ = remove_block;
  if (remove_block) {
    set_has_remove_block();
  } else {
    clear_has_remove_block();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.remove_block)
}

// optional .blox.connect.LogMessage log_message = 12;
inline bool Command::has_log_message() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Command::set_has_log_message() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Command::clear_has_log_message() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Command::clear_log_message() {
  if (log_message_ != NULL) log_message_->::blox::connect::LogMessage::Clear();
  clear_has_log_message();
}
inline const ::blox::connect::LogMessage& Command::log_message() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.log_message)
  return log_message_ != NULL ? *log_message_ : *default_instance_->log_message_;
}
inline ::blox::connect::LogMessage* Command::mutable_log_message() {
  set_has_log_message();
  if (log_message_ == NULL) log_message_ = new ::blox::connect::LogMessage;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.log_message)
  return log_message_;
}
inline ::blox::connect::LogMessage* Command::release_log_message() {
  clear_has_log_message();
  ::blox::connect::LogMessage* temp = log_message_;
  log_message_ = NULL;
  return temp;
}
inline void Command::set_allocated_log_message(::blox::connect::LogMessage* log_message) {
  delete log_message_;
  log_message_ = log_message;
  if (log_message) {
    set_has_log_message();
  } else {
    clear_has_log_message();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.log_message)
}

// optional .blox.connect.ExportProtoBuf export_protobuf = 14;
inline bool Command::has_export_protobuf() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Command::set_has_export_protobuf() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Command::clear_has_export_protobuf() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Command::clear_export_protobuf() {
  if (export_protobuf_ != NULL) export_protobuf_->::blox::connect::ExportProtoBuf::Clear();
  clear_has_export_protobuf();
}
inline const ::blox::connect::ExportProtoBuf& Command::export_protobuf() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.export_protobuf)
  return export_protobuf_ != NULL ? *export_protobuf_ : *default_instance_->export_protobuf_;
}
inline ::blox::connect::ExportProtoBuf* Command::mutable_export_protobuf() {
  set_has_export_protobuf();
  if (export_protobuf_ == NULL) export_protobuf_ = new ::blox::connect::ExportProtoBuf;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.export_protobuf)
  return export_protobuf_;
}
inline ::blox::connect::ExportProtoBuf* Command::release_export_protobuf() {
  clear_has_export_protobuf();
  ::blox::connect::ExportProtoBuf* temp = export_protobuf_;
  export_protobuf_ = NULL;
  return temp;
}
inline void Command::set_allocated_export_protobuf(::blox::connect::ExportProtoBuf* export_protobuf) {
  delete export_protobuf_;
  export_protobuf_ = export_protobuf;
  if (export_protobuf) {
    set_has_export_protobuf();
  } else {
    clear_has_export_protobuf();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.export_protobuf)
}

// optional .blox.connect.ProtoAddSpec proto_add_spec = 15;
inline bool Command::has_proto_add_spec() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Command::set_has_proto_add_spec() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Command::clear_has_proto_add_spec() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Command::clear_proto_add_spec() {
  if (proto_add_spec_ != NULL) proto_add_spec_->::blox::connect::ProtoAddSpec::Clear();
  clear_has_proto_add_spec();
}
inline const ::blox::connect::ProtoAddSpec& Command::proto_add_spec() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.proto_add_spec)
  return proto_add_spec_ != NULL ? *proto_add_spec_ : *default_instance_->proto_add_spec_;
}
inline ::blox::connect::ProtoAddSpec* Command::mutable_proto_add_spec() {
  set_has_proto_add_spec();
  if (proto_add_spec_ == NULL) proto_add_spec_ = new ::blox::connect::ProtoAddSpec;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.proto_add_spec)
  return proto_add_spec_;
}
inline ::blox::connect::ProtoAddSpec* Command::release_proto_add_spec() {
  clear_has_proto_add_spec();
  ::blox::connect::ProtoAddSpec* temp = proto_add_spec_;
  proto_add_spec_ = NULL;
  return temp;
}
inline void Command::set_allocated_proto_add_spec(::blox::connect::ProtoAddSpec* proto_add_spec) {
  delete proto_add_spec_;
  proto_add_spec_ = proto_add_spec;
  if (proto_add_spec) {
    set_has_proto_add_spec();
  } else {
    clear_has_proto_add_spec();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.proto_add_spec)
}

// optional .blox.connect.FaultInjection fault = 16;
inline bool Command::has_fault() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Command::set_has_fault() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Command::clear_has_fault() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Command::clear_fault() {
  if (fault_ != NULL) fault_->::blox::connect::FaultInjection::Clear();
  clear_has_fault();
}
inline const ::blox::connect::FaultInjection& Command::fault() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.fault)
  return fault_ != NULL ? *fault_ : *default_instance_->fault_;
}
inline ::blox::connect::FaultInjection* Command::mutable_fault() {
  set_has_fault();
  if (fault_ == NULL) fault_ = new ::blox::connect::FaultInjection;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.fault)
  return fault_;
}
inline ::blox::connect::FaultInjection* Command::release_fault() {
  clear_has_fault();
  ::blox::connect::FaultInjection* temp = fault_;
  fault_ = NULL;
  return temp;
}
inline void Command::set_allocated_fault(::blox::connect::FaultInjection* fault) {
  delete fault_;
  fault_ = fault;
  if (fault) {
    set_has_fault();
  } else {
    clear_has_fault();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.fault)
}

// optional .blox.connect.GetPredicateInfoBulk pred_info_bulk = 17;
inline bool Command::has_pred_info_bulk() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Command::set_has_pred_info_bulk() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Command::clear_has_pred_info_bulk() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Command::clear_pred_info_bulk() {
  if (pred_info_bulk_ != NULL) pred_info_bulk_->::blox::connect::GetPredicateInfoBulk::Clear();
  clear_has_pred_info_bulk();
}
inline const ::blox::connect::GetPredicateInfoBulk& Command::pred_info_bulk() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.pred_info_bulk)
  return pred_info_bulk_ != NULL ? *pred_info_bulk_ : *default_instance_->pred_info_bulk_;
}
inline ::blox::connect::GetPredicateInfoBulk* Command::mutable_pred_info_bulk() {
  set_has_pred_info_bulk();
  if (pred_info_bulk_ == NULL) pred_info_bulk_ = new ::blox::connect::GetPredicateInfoBulk;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.pred_info_bulk)
  return pred_info_bulk_;
}
inline ::blox::connect::GetPredicateInfoBulk* Command::release_pred_info_bulk() {
  clear_has_pred_info_bulk();
  ::blox::connect::GetPredicateInfoBulk* temp = pred_info_bulk_;
  pred_info_bulk_ = NULL;
  return temp;
}
inline void Command::set_allocated_pred_info_bulk(::blox::connect::GetPredicateInfoBulk* pred_info_bulk) {
  delete pred_info_bulk_;
  pred_info_bulk_ = pred_info_bulk;
  if (pred_info_bulk) {
    set_has_pred_info_bulk();
  } else {
    clear_has_pred_info_bulk();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.pred_info_bulk)
}

// optional .blox.connect.GetPredicatePopcount pred_popcount = 20;
inline bool Command::has_pred_popcount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Command::set_has_pred_popcount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Command::clear_has_pred_popcount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Command::clear_pred_popcount() {
  if (pred_popcount_ != NULL) pred_popcount_->::blox::connect::GetPredicatePopcount::Clear();
  clear_has_pred_popcount();
}
inline const ::blox::connect::GetPredicatePopcount& Command::pred_popcount() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.pred_popcount)
  return pred_popcount_ != NULL ? *pred_popcount_ : *default_instance_->pred_popcount_;
}
inline ::blox::connect::GetPredicatePopcount* Command::mutable_pred_popcount() {
  set_has_pred_popcount();
  if (pred_popcount_ == NULL) pred_popcount_ = new ::blox::connect::GetPredicatePopcount;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.pred_popcount)
  return pred_popcount_;
}
inline ::blox::connect::GetPredicatePopcount* Command::release_pred_popcount() {
  clear_has_pred_popcount();
  ::blox::connect::GetPredicatePopcount* temp = pred_popcount_;
  pred_popcount_ = NULL;
  return temp;
}
inline void Command::set_allocated_pred_popcount(::blox::connect::GetPredicatePopcount* pred_popcount) {
  delete pred_popcount_;
  pred_popcount_ = pred_popcount;
  if (pred_popcount) {
    set_has_pred_popcount();
  } else {
    clear_has_pred_popcount();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.pred_popcount)
}

// optional .blox.connect.GenerateFullUpdateDeltas pred_full_update_deltas = 21;
inline bool Command::has_pred_full_update_deltas() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Command::set_has_pred_full_update_deltas() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Command::clear_has_pred_full_update_deltas() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Command::clear_pred_full_update_deltas() {
  if (pred_full_update_deltas_ != NULL) pred_full_update_deltas_->::blox::connect::GenerateFullUpdateDeltas::Clear();
  clear_has_pred_full_update_deltas();
}
inline const ::blox::connect::GenerateFullUpdateDeltas& Command::pred_full_update_deltas() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.pred_full_update_deltas)
  return pred_full_update_deltas_ != NULL ? *pred_full_update_deltas_ : *default_instance_->pred_full_update_deltas_;
}
inline ::blox::connect::GenerateFullUpdateDeltas* Command::mutable_pred_full_update_deltas() {
  set_has_pred_full_update_deltas();
  if (pred_full_update_deltas_ == NULL) pred_full_update_deltas_ = new ::blox::connect::GenerateFullUpdateDeltas;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.pred_full_update_deltas)
  return pred_full_update_deltas_;
}
inline ::blox::connect::GenerateFullUpdateDeltas* Command::release_pred_full_update_deltas() {
  clear_has_pred_full_update_deltas();
  ::blox::connect::GenerateFullUpdateDeltas* temp = pred_full_update_deltas_;
  pred_full_update_deltas_ = NULL;
  return temp;
}
inline void Command::set_allocated_pred_full_update_deltas(::blox::connect::GenerateFullUpdateDeltas* pred_full_update_deltas) {
  delete pred_full_update_deltas_;
  pred_full_update_deltas_ = pred_full_update_deltas;
  if (pred_full_update_deltas) {
    set_has_pred_full_update_deltas();
  } else {
    clear_has_pred_full_update_deltas();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.pred_full_update_deltas)
}

// optional .blox.connect.ExecuteImportScript exec_import_script = 22;
inline bool Command::has_exec_import_script() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Command::set_has_exec_import_script() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Command::clear_has_exec_import_script() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Command::clear_exec_import_script() {
  if (exec_import_script_ != NULL) exec_import_script_->::blox::connect::ExecuteImportScript::Clear();
  clear_has_exec_import_script();
}
inline const ::blox::connect::ExecuteImportScript& Command::exec_import_script() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.exec_import_script)
  return exec_import_script_ != NULL ? *exec_import_script_ : *default_instance_->exec_import_script_;
}
inline ::blox::connect::ExecuteImportScript* Command::mutable_exec_import_script() {
  set_has_exec_import_script();
  if (exec_import_script_ == NULL) exec_import_script_ = new ::blox::connect::ExecuteImportScript;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.exec_import_script)
  return exec_import_script_;
}
inline ::blox::connect::ExecuteImportScript* Command::release_exec_import_script() {
  clear_has_exec_import_script();
  ::blox::connect::ExecuteImportScript* temp = exec_import_script_;
  exec_import_script_ = NULL;
  return temp;
}
inline void Command::set_allocated_exec_import_script(::blox::connect::ExecuteImportScript* exec_import_script) {
  delete exec_import_script_;
  exec_import_script_ = exec_import_script;
  if (exec_import_script) {
    set_has_exec_import_script();
  } else {
    clear_has_exec_import_script();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.exec_import_script)
}

// optional .blox.connect.GetProtocolDescriptors proto_get_descriptors = 23;
inline bool Command::has_proto_get_descriptors() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Command::set_has_proto_get_descriptors() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Command::clear_has_proto_get_descriptors() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Command::clear_proto_get_descriptors() {
  if (proto_get_descriptors_ != NULL) proto_get_descriptors_->::blox::connect::GetProtocolDescriptors::Clear();
  clear_has_proto_get_descriptors();
}
inline const ::blox::connect::GetProtocolDescriptors& Command::proto_get_descriptors() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.proto_get_descriptors)
  return proto_get_descriptors_ != NULL ? *proto_get_descriptors_ : *default_instance_->proto_get_descriptors_;
}
inline ::blox::connect::GetProtocolDescriptors* Command::mutable_proto_get_descriptors() {
  set_has_proto_get_descriptors();
  if (proto_get_descriptors_ == NULL) proto_get_descriptors_ = new ::blox::connect::GetProtocolDescriptors;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.proto_get_descriptors)
  return proto_get_descriptors_;
}
inline ::blox::connect::GetProtocolDescriptors* Command::release_proto_get_descriptors() {
  clear_has_proto_get_descriptors();
  ::blox::connect::GetProtocolDescriptors* temp = proto_get_descriptors_;
  proto_get_descriptors_ = NULL;
  return temp;
}
inline void Command::set_allocated_proto_get_descriptors(::blox::connect::GetProtocolDescriptors* proto_get_descriptors) {
  delete proto_get_descriptors_;
  proto_get_descriptors_ = proto_get_descriptors;
  if (proto_get_descriptors) {
    set_has_proto_get_descriptors();
  } else {
    clear_has_proto_get_descriptors();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.proto_get_descriptors)
}

// optional .blox.connect.BindBranchAlias bind_branch_alias = 24;
inline bool Command::has_bind_branch_alias() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Command::set_has_bind_branch_alias() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Command::clear_has_bind_branch_alias() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Command::clear_bind_branch_alias() {
  if (bind_branch_alias_ != NULL) bind_branch_alias_->::blox::connect::BindBranchAlias::Clear();
  clear_has_bind_branch_alias();
}
inline const ::blox::connect::BindBranchAlias& Command::bind_branch_alias() const {
  // @@protoc_insertion_point(field_get:blox.connect.Command.bind_branch_alias)
  return bind_branch_alias_ != NULL ? *bind_branch_alias_ : *default_instance_->bind_branch_alias_;
}
inline ::blox::connect::BindBranchAlias* Command::mutable_bind_branch_alias() {
  set_has_bind_branch_alias();
  if (bind_branch_alias_ == NULL) bind_branch_alias_ = new ::blox::connect::BindBranchAlias;
  // @@protoc_insertion_point(field_mutable:blox.connect.Command.bind_branch_alias)
  return bind_branch_alias_;
}
inline ::blox::connect::BindBranchAlias* Command::release_bind_branch_alias() {
  clear_has_bind_branch_alias();
  ::blox::connect::BindBranchAlias* temp = bind_branch_alias_;
  bind_branch_alias_ = NULL;
  return temp;
}
inline void Command::set_allocated_bind_branch_alias(::blox::connect::BindBranchAlias* bind_branch_alias) {
  delete bind_branch_alias_;
  bind_branch_alias_ = bind_branch_alias;
  if (bind_branch_alias) {
    set_has_bind_branch_alias();
  } else {
    clear_has_bind_branch_alias();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Command.bind_branch_alias)
}

// -------------------------------------------------------------------

// CommandResponse

// optional .blox.connect.ExceptionContainer exception = 1;
inline bool CommandResponse::has_exception() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandResponse::set_has_exception() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandResponse::clear_has_exception() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandResponse::clear_exception() {
  if (exception_ != NULL) exception_->::blox::connect::ExceptionContainer::Clear();
  clear_has_exception();
}
inline const ::blox::connect::ExceptionContainer& CommandResponse::exception() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.exception)
  return exception_ != NULL ? *exception_ : *default_instance_->exception_;
}
inline ::blox::connect::ExceptionContainer* CommandResponse::mutable_exception() {
  set_has_exception();
  if (exception_ == NULL) exception_ = new ::blox::connect::ExceptionContainer;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.exception)
  return exception_;
}
inline ::blox::connect::ExceptionContainer* CommandResponse::release_exception() {
  clear_has_exception();
  ::blox::connect::ExceptionContainer* temp = exception_;
  exception_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_exception(::blox::connect::ExceptionContainer* exception) {
  delete exception_;
  exception_ = exception;
  if (exception) {
    set_has_exception();
  } else {
    clear_has_exception();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.exception)
}

// optional .blox.connect.AddBlockResponse add_block = 2;
inline bool CommandResponse::has_add_block() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandResponse::set_has_add_block() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandResponse::clear_has_add_block() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandResponse::clear_add_block() {
  if (add_block_ != NULL) add_block_->::blox::connect::AddBlockResponse::Clear();
  clear_has_add_block();
}
inline const ::blox::connect::AddBlockResponse& CommandResponse::add_block() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.add_block)
  return add_block_ != NULL ? *add_block_ : *default_instance_->add_block_;
}
inline ::blox::connect::AddBlockResponse* CommandResponse::mutable_add_block() {
  set_has_add_block();
  if (add_block_ == NULL) add_block_ = new ::blox::connect::AddBlockResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.add_block)
  return add_block_;
}
inline ::blox::connect::AddBlockResponse* CommandResponse::release_add_block() {
  clear_has_add_block();
  ::blox::connect::AddBlockResponse* temp = add_block_;
  add_block_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_add_block(::blox::connect::AddBlockResponse* add_block) {
  delete add_block_;
  add_block_ = add_block;
  if (add_block) {
    set_has_add_block();
  } else {
    clear_has_add_block();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.add_block)
}

// optional .blox.connect.InstallLibraryResponse install_library = 3;
inline bool CommandResponse::has_install_library() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandResponse::set_has_install_library() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandResponse::clear_has_install_library() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandResponse::clear_install_library() {
  if (install_library_ != NULL) install_library_->::blox::connect::InstallLibraryResponse::Clear();
  clear_has_install_library();
}
inline const ::blox::connect::InstallLibraryResponse& CommandResponse::install_library() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.install_library)
  return install_library_ != NULL ? *install_library_ : *default_instance_->install_library_;
}
inline ::blox::connect::InstallLibraryResponse* CommandResponse::mutable_install_library() {
  set_has_install_library();
  if (install_library_ == NULL) install_library_ = new ::blox::connect::InstallLibraryResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.install_library)
  return install_library_;
}
inline ::blox::connect::InstallLibraryResponse* CommandResponse::release_install_library() {
  clear_has_install_library();
  ::blox::connect::InstallLibraryResponse* temp = install_library_;
  install_library_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_install_library(::blox::connect::InstallLibraryResponse* install_library) {
  delete install_library_;
  install_library_ = install_library;
  if (install_library) {
    set_has_install_library();
  } else {
    clear_has_install_library();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.install_library)
}

// optional .blox.connect.ExecInactiveBlockResponse exec_inactive = 4;
inline bool CommandResponse::has_exec_inactive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandResponse::set_has_exec_inactive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandResponse::clear_has_exec_inactive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandResponse::clear_exec_inactive() {
  if (exec_inactive_ != NULL) exec_inactive_->::blox::connect::ExecInactiveBlockResponse::Clear();
  clear_has_exec_inactive();
}
inline const ::blox::connect::ExecInactiveBlockResponse& CommandResponse::exec_inactive() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.exec_inactive)
  return exec_inactive_ != NULL ? *exec_inactive_ : *default_instance_->exec_inactive_;
}
inline ::blox::connect::ExecInactiveBlockResponse* CommandResponse::mutable_exec_inactive() {
  set_has_exec_inactive();
  if (exec_inactive_ == NULL) exec_inactive_ = new ::blox::connect::ExecInactiveBlockResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.exec_inactive)
  return exec_inactive_;
}
inline ::blox::connect::ExecInactiveBlockResponse* CommandResponse::release_exec_inactive() {
  clear_has_exec_inactive();
  ::blox::connect::ExecInactiveBlockResponse* temp = exec_inactive_;
  exec_inactive_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_exec_inactive(::blox::connect::ExecInactiveBlockResponse* exec_inactive) {
  delete exec_inactive_;
  exec_inactive_ = exec_inactive;
  if (exec_inactive) {
    set_has_exec_inactive();
  } else {
    clear_has_exec_inactive();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.exec_inactive)
}

// optional .blox.connect.ExecBlockResponse exec = 5;
inline bool CommandResponse::has_exec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandResponse::set_has_exec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandResponse::clear_has_exec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandResponse::clear_exec() {
  if (exec_ != NULL) exec_->::blox::connect::ExecBlockResponse::Clear();
  clear_has_exec();
}
inline const ::blox::connect::ExecBlockResponse& CommandResponse::exec() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.exec)
  return exec_ != NULL ? *exec_ : *default_instance_->exec_;
}
inline ::blox::connect::ExecBlockResponse* CommandResponse::mutable_exec() {
  set_has_exec();
  if (exec_ == NULL) exec_ = new ::blox::connect::ExecBlockResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.exec)
  return exec_;
}
inline ::blox::connect::ExecBlockResponse* CommandResponse::release_exec() {
  clear_has_exec();
  ::blox::connect::ExecBlockResponse* temp = exec_;
  exec_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_exec(::blox::connect::ExecBlockResponse* exec) {
  delete exec_;
  exec_ = exec;
  if (exec) {
    set_has_exec();
  } else {
    clear_has_exec();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.exec)
}

// optional .blox.connect.QueryPredicateResponse query_predicate = 6;
inline bool CommandResponse::has_query_predicate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandResponse::set_has_query_predicate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandResponse::clear_has_query_predicate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandResponse::clear_query_predicate() {
  if (query_predicate_ != NULL) query_predicate_->::blox::connect::QueryPredicateResponse::Clear();
  clear_has_query_predicate();
}
inline const ::blox::connect::QueryPredicateResponse& CommandResponse::query_predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.query_predicate)
  return query_predicate_ != NULL ? *query_predicate_ : *default_instance_->query_predicate_;
}
inline ::blox::connect::QueryPredicateResponse* CommandResponse::mutable_query_predicate() {
  set_has_query_predicate();
  if (query_predicate_ == NULL) query_predicate_ = new ::blox::connect::QueryPredicateResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.query_predicate)
  return query_predicate_;
}
inline ::blox::connect::QueryPredicateResponse* CommandResponse::release_query_predicate() {
  clear_has_query_predicate();
  ::blox::connect::QueryPredicateResponse* temp = query_predicate_;
  query_predicate_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_query_predicate(::blox::connect::QueryPredicateResponse* query_predicate) {
  delete query_predicate_;
  query_predicate_ = query_predicate;
  if (query_predicate) {
    set_has_query_predicate();
  } else {
    clear_has_query_predicate();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.query_predicate)
}

// optional .blox.connect.UpdatePredicateResponse update_predicate = 7;
inline bool CommandResponse::has_update_predicate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandResponse::set_has_update_predicate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandResponse::clear_has_update_predicate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandResponse::clear_update_predicate() {
  if (update_predicate_ != NULL) update_predicate_->::blox::connect::UpdatePredicateResponse::Clear();
  clear_has_update_predicate();
}
inline const ::blox::connect::UpdatePredicateResponse& CommandResponse::update_predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.update_predicate)
  return update_predicate_ != NULL ? *update_predicate_ : *default_instance_->update_predicate_;
}
inline ::blox::connect::UpdatePredicateResponse* CommandResponse::mutable_update_predicate() {
  set_has_update_predicate();
  if (update_predicate_ == NULL) update_predicate_ = new ::blox::connect::UpdatePredicateResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.update_predicate)
  return update_predicate_;
}
inline ::blox::connect::UpdatePredicateResponse* CommandResponse::release_update_predicate() {
  clear_has_update_predicate();
  ::blox::connect::UpdatePredicateResponse* temp = update_predicate_;
  update_predicate_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_update_predicate(::blox::connect::UpdatePredicateResponse* update_predicate) {
  delete update_predicate_;
  update_predicate_ = update_predicate;
  if (update_predicate) {
    set_has_update_predicate();
  } else {
    clear_has_update_predicate();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.update_predicate)
}

// optional .blox.connect.GetPredicateInfoResponse pred_info = 8;
inline bool CommandResponse::has_pred_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandResponse::set_has_pred_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandResponse::clear_has_pred_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandResponse::clear_pred_info() {
  if (pred_info_ != NULL) pred_info_->::blox::connect::GetPredicateInfoResponse::Clear();
  clear_has_pred_info();
}
inline const ::blox::connect::GetPredicateInfoResponse& CommandResponse::pred_info() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.pred_info)
  return pred_info_ != NULL ? *pred_info_ : *default_instance_->pred_info_;
}
inline ::blox::connect::GetPredicateInfoResponse* CommandResponse::mutable_pred_info() {
  set_has_pred_info();
  if (pred_info_ == NULL) pred_info_ = new ::blox::connect::GetPredicateInfoResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.pred_info)
  return pred_info_;
}
inline ::blox::connect::GetPredicateInfoResponse* CommandResponse::release_pred_info() {
  clear_has_pred_info();
  ::blox::connect::GetPredicateInfoResponse* temp = pred_info_;
  pred_info_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_pred_info(::blox::connect::GetPredicateInfoResponse* pred_info) {
  delete pred_info_;
  pred_info_ = pred_info;
  if (pred_info) {
    set_has_pred_info();
  } else {
    clear_has_pred_info();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.pred_info)
}

// optional .blox.connect.ImportProtoBufResponse import_protobuf = 9;
inline bool CommandResponse::has_import_protobuf() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommandResponse::set_has_import_protobuf() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommandResponse::clear_has_import_protobuf() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommandResponse::clear_import_protobuf() {
  if (import_protobuf_ != NULL) import_protobuf_->::blox::connect::ImportProtoBufResponse::Clear();
  clear_has_import_protobuf();
}
inline const ::blox::connect::ImportProtoBufResponse& CommandResponse::import_protobuf() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.import_protobuf)
  return import_protobuf_ != NULL ? *import_protobuf_ : *default_instance_->import_protobuf_;
}
inline ::blox::connect::ImportProtoBufResponse* CommandResponse::mutable_import_protobuf() {
  set_has_import_protobuf();
  if (import_protobuf_ == NULL) import_protobuf_ = new ::blox::connect::ImportProtoBufResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.import_protobuf)
  return import_protobuf_;
}
inline ::blox::connect::ImportProtoBufResponse* CommandResponse::release_import_protobuf() {
  clear_has_import_protobuf();
  ::blox::connect::ImportProtoBufResponse* temp = import_protobuf_;
  import_protobuf_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_import_protobuf(::blox::connect::ImportProtoBufResponse* import_protobuf) {
  delete import_protobuf_;
  import_protobuf_ = import_protobuf;
  if (import_protobuf) {
    set_has_import_protobuf();
  } else {
    clear_has_import_protobuf();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.import_protobuf)
}

// optional .blox.connect.CompileBlockResponse compile_block = 10;
inline bool CommandResponse::has_compile_block() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommandResponse::set_has_compile_block() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommandResponse::clear_has_compile_block() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommandResponse::clear_compile_block() {
  if (compile_block_ != NULL) compile_block_->::blox::connect::CompileBlockResponse::Clear();
  clear_has_compile_block();
}
inline const ::blox::connect::CompileBlockResponse& CommandResponse::compile_block() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.compile_block)
  return compile_block_ != NULL ? *compile_block_ : *default_instance_->compile_block_;
}
inline ::blox::connect::CompileBlockResponse* CommandResponse::mutable_compile_block() {
  set_has_compile_block();
  if (compile_block_ == NULL) compile_block_ = new ::blox::connect::CompileBlockResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.compile_block)
  return compile_block_;
}
inline ::blox::connect::CompileBlockResponse* CommandResponse::release_compile_block() {
  clear_has_compile_block();
  ::blox::connect::CompileBlockResponse* temp = compile_block_;
  compile_block_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_compile_block(::blox::connect::CompileBlockResponse* compile_block) {
  delete compile_block_;
  compile_block_ = compile_block;
  if (compile_block) {
    set_has_compile_block();
  } else {
    clear_has_compile_block();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.compile_block)
}

// optional .blox.connect.InstallProjectResponse install_project = 11;
inline bool CommandResponse::has_install_project() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommandResponse::set_has_install_project() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommandResponse::clear_has_install_project() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommandResponse::clear_install_project() {
  if (install_project_ != NULL) install_project_->::blox::connect::InstallProjectResponse::Clear();
  clear_has_install_project();
}
inline const ::blox::connect::InstallProjectResponse& CommandResponse::install_project() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.install_project)
  return install_project_ != NULL ? *install_project_ : *default_instance_->install_project_;
}
inline ::blox::connect::InstallProjectResponse* CommandResponse::mutable_install_project() {
  set_has_install_project();
  if (install_project_ == NULL) install_project_ = new ::blox::connect::InstallProjectResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.install_project)
  return install_project_;
}
inline ::blox::connect::InstallProjectResponse* CommandResponse::release_install_project() {
  clear_has_install_project();
  ::blox::connect::InstallProjectResponse* temp = install_project_;
  install_project_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_install_project(::blox::connect::InstallProjectResponse* install_project) {
  delete install_project_;
  install_project_ = install_project;
  if (install_project) {
    set_has_install_project();
  } else {
    clear_has_install_project();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.install_project)
}

// optional .blox.connect.RemoveBlockResponse remove_block = 12;
inline bool CommandResponse::has_remove_block() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommandResponse::set_has_remove_block() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommandResponse::clear_has_remove_block() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommandResponse::clear_remove_block() {
  if (remove_block_ != NULL) remove_block_->::blox::connect::RemoveBlockResponse::Clear();
  clear_has_remove_block();
}
inline const ::blox::connect::RemoveBlockResponse& CommandResponse::remove_block() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.remove_block)
  return remove_block_ != NULL ? *remove_block_ : *default_instance_->remove_block_;
}
inline ::blox::connect::RemoveBlockResponse* CommandResponse::mutable_remove_block() {
  set_has_remove_block();
  if (remove_block_ == NULL) remove_block_ = new ::blox::connect::RemoveBlockResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.remove_block)
  return remove_block_;
}
inline ::blox::connect::RemoveBlockResponse* CommandResponse::release_remove_block() {
  clear_has_remove_block();
  ::blox::connect::RemoveBlockResponse* temp = remove_block_;
  remove_block_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_remove_block(::blox::connect::RemoveBlockResponse* remove_block) {
  delete remove_block_;
  remove_block_ = remove_block;
  if (remove_block) {
    set_has_remove_block();
  } else {
    clear_has_remove_block();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.remove_block)
}

// optional .blox.connect.LogMessageResponse log_message = 13;
inline bool CommandResponse::has_log_message() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommandResponse::set_has_log_message() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommandResponse::clear_has_log_message() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommandResponse::clear_log_message() {
  if (log_message_ != NULL) log_message_->::blox::connect::LogMessageResponse::Clear();
  clear_has_log_message();
}
inline const ::blox::connect::LogMessageResponse& CommandResponse::log_message() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.log_message)
  return log_message_ != NULL ? *log_message_ : *default_instance_->log_message_;
}
inline ::blox::connect::LogMessageResponse* CommandResponse::mutable_log_message() {
  set_has_log_message();
  if (log_message_ == NULL) log_message_ = new ::blox::connect::LogMessageResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.log_message)
  return log_message_;
}
inline ::blox::connect::LogMessageResponse* CommandResponse::release_log_message() {
  clear_has_log_message();
  ::blox::connect::LogMessageResponse* temp = log_message_;
  log_message_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_log_message(::blox::connect::LogMessageResponse* log_message) {
  delete log_message_;
  log_message_ = log_message;
  if (log_message) {
    set_has_log_message();
  } else {
    clear_has_log_message();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.log_message)
}

// optional .blox.connect.ExportProtoBufResponse export_protobuf = 15;
inline bool CommandResponse::has_export_protobuf() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CommandResponse::set_has_export_protobuf() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CommandResponse::clear_has_export_protobuf() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CommandResponse::clear_export_protobuf() {
  if (export_protobuf_ != NULL) export_protobuf_->::blox::connect::ExportProtoBufResponse::Clear();
  clear_has_export_protobuf();
}
inline const ::blox::connect::ExportProtoBufResponse& CommandResponse::export_protobuf() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.export_protobuf)
  return export_protobuf_ != NULL ? *export_protobuf_ : *default_instance_->export_protobuf_;
}
inline ::blox::connect::ExportProtoBufResponse* CommandResponse::mutable_export_protobuf() {
  set_has_export_protobuf();
  if (export_protobuf_ == NULL) export_protobuf_ = new ::blox::connect::ExportProtoBufResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.export_protobuf)
  return export_protobuf_;
}
inline ::blox::connect::ExportProtoBufResponse* CommandResponse::release_export_protobuf() {
  clear_has_export_protobuf();
  ::blox::connect::ExportProtoBufResponse* temp = export_protobuf_;
  export_protobuf_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_export_protobuf(::blox::connect::ExportProtoBufResponse* export_protobuf) {
  delete export_protobuf_;
  export_protobuf_ = export_protobuf;
  if (export_protobuf) {
    set_has_export_protobuf();
  } else {
    clear_has_export_protobuf();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.export_protobuf)
}

// optional .blox.connect.ProtoAddSpecResponse proto_add_spec = 16;
inline bool CommandResponse::has_proto_add_spec() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CommandResponse::set_has_proto_add_spec() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CommandResponse::clear_has_proto_add_spec() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CommandResponse::clear_proto_add_spec() {
  if (proto_add_spec_ != NULL) proto_add_spec_->::blox::connect::ProtoAddSpecResponse::Clear();
  clear_has_proto_add_spec();
}
inline const ::blox::connect::ProtoAddSpecResponse& CommandResponse::proto_add_spec() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.proto_add_spec)
  return proto_add_spec_ != NULL ? *proto_add_spec_ : *default_instance_->proto_add_spec_;
}
inline ::blox::connect::ProtoAddSpecResponse* CommandResponse::mutable_proto_add_spec() {
  set_has_proto_add_spec();
  if (proto_add_spec_ == NULL) proto_add_spec_ = new ::blox::connect::ProtoAddSpecResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.proto_add_spec)
  return proto_add_spec_;
}
inline ::blox::connect::ProtoAddSpecResponse* CommandResponse::release_proto_add_spec() {
  clear_has_proto_add_spec();
  ::blox::connect::ProtoAddSpecResponse* temp = proto_add_spec_;
  proto_add_spec_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_proto_add_spec(::blox::connect::ProtoAddSpecResponse* proto_add_spec) {
  delete proto_add_spec_;
  proto_add_spec_ = proto_add_spec;
  if (proto_add_spec) {
    set_has_proto_add_spec();
  } else {
    clear_has_proto_add_spec();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.proto_add_spec)
}

// optional .blox.connect.FaultInjection fault = 17;
inline bool CommandResponse::has_fault() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CommandResponse::set_has_fault() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CommandResponse::clear_has_fault() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CommandResponse::clear_fault() {
  if (fault_ != NULL) fault_->::blox::connect::FaultInjection::Clear();
  clear_has_fault();
}
inline const ::blox::connect::FaultInjection& CommandResponse::fault() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.fault)
  return fault_ != NULL ? *fault_ : *default_instance_->fault_;
}
inline ::blox::connect::FaultInjection* CommandResponse::mutable_fault() {
  set_has_fault();
  if (fault_ == NULL) fault_ = new ::blox::connect::FaultInjection;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.fault)
  return fault_;
}
inline ::blox::connect::FaultInjection* CommandResponse::release_fault() {
  clear_has_fault();
  ::blox::connect::FaultInjection* temp = fault_;
  fault_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_fault(::blox::connect::FaultInjection* fault) {
  delete fault_;
  fault_ = fault;
  if (fault) {
    set_has_fault();
  } else {
    clear_has_fault();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.fault)
}

// optional .blox.connect.GetPredicateInfoBulkResponse pred_info_bulk = 18;
inline bool CommandResponse::has_pred_info_bulk() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CommandResponse::set_has_pred_info_bulk() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CommandResponse::clear_has_pred_info_bulk() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CommandResponse::clear_pred_info_bulk() {
  if (pred_info_bulk_ != NULL) pred_info_bulk_->::blox::connect::GetPredicateInfoBulkResponse::Clear();
  clear_has_pred_info_bulk();
}
inline const ::blox::connect::GetPredicateInfoBulkResponse& CommandResponse::pred_info_bulk() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.pred_info_bulk)
  return pred_info_bulk_ != NULL ? *pred_info_bulk_ : *default_instance_->pred_info_bulk_;
}
inline ::blox::connect::GetPredicateInfoBulkResponse* CommandResponse::mutable_pred_info_bulk() {
  set_has_pred_info_bulk();
  if (pred_info_bulk_ == NULL) pred_info_bulk_ = new ::blox::connect::GetPredicateInfoBulkResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.pred_info_bulk)
  return pred_info_bulk_;
}
inline ::blox::connect::GetPredicateInfoBulkResponse* CommandResponse::release_pred_info_bulk() {
  clear_has_pred_info_bulk();
  ::blox::connect::GetPredicateInfoBulkResponse* temp = pred_info_bulk_;
  pred_info_bulk_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_pred_info_bulk(::blox::connect::GetPredicateInfoBulkResponse* pred_info_bulk) {
  delete pred_info_bulk_;
  pred_info_bulk_ = pred_info_bulk;
  if (pred_info_bulk) {
    set_has_pred_info_bulk();
  } else {
    clear_has_pred_info_bulk();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.pred_info_bulk)
}

// optional .blox.connect.GetPredicatePopcountResponse pred_popcount = 21;
inline bool CommandResponse::has_pred_popcount() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CommandResponse::set_has_pred_popcount() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CommandResponse::clear_has_pred_popcount() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CommandResponse::clear_pred_popcount() {
  if (pred_popcount_ != NULL) pred_popcount_->::blox::connect::GetPredicatePopcountResponse::Clear();
  clear_has_pred_popcount();
}
inline const ::blox::connect::GetPredicatePopcountResponse& CommandResponse::pred_popcount() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.pred_popcount)
  return pred_popcount_ != NULL ? *pred_popcount_ : *default_instance_->pred_popcount_;
}
inline ::blox::connect::GetPredicatePopcountResponse* CommandResponse::mutable_pred_popcount() {
  set_has_pred_popcount();
  if (pred_popcount_ == NULL) pred_popcount_ = new ::blox::connect::GetPredicatePopcountResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.pred_popcount)
  return pred_popcount_;
}
inline ::blox::connect::GetPredicatePopcountResponse* CommandResponse::release_pred_popcount() {
  clear_has_pred_popcount();
  ::blox::connect::GetPredicatePopcountResponse* temp = pred_popcount_;
  pred_popcount_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_pred_popcount(::blox::connect::GetPredicatePopcountResponse* pred_popcount) {
  delete pred_popcount_;
  pred_popcount_ = pred_popcount;
  if (pred_popcount) {
    set_has_pred_popcount();
  } else {
    clear_has_pred_popcount();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.pred_popcount)
}

// optional .blox.connect.GenerateFullUpdateDeltasResponse pred_full_update_deltas = 22;
inline bool CommandResponse::has_pred_full_update_deltas() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CommandResponse::set_has_pred_full_update_deltas() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CommandResponse::clear_has_pred_full_update_deltas() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CommandResponse::clear_pred_full_update_deltas() {
  if (pred_full_update_deltas_ != NULL) pred_full_update_deltas_->::blox::connect::GenerateFullUpdateDeltasResponse::Clear();
  clear_has_pred_full_update_deltas();
}
inline const ::blox::connect::GenerateFullUpdateDeltasResponse& CommandResponse::pred_full_update_deltas() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.pred_full_update_deltas)
  return pred_full_update_deltas_ != NULL ? *pred_full_update_deltas_ : *default_instance_->pred_full_update_deltas_;
}
inline ::blox::connect::GenerateFullUpdateDeltasResponse* CommandResponse::mutable_pred_full_update_deltas() {
  set_has_pred_full_update_deltas();
  if (pred_full_update_deltas_ == NULL) pred_full_update_deltas_ = new ::blox::connect::GenerateFullUpdateDeltasResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.pred_full_update_deltas)
  return pred_full_update_deltas_;
}
inline ::blox::connect::GenerateFullUpdateDeltasResponse* CommandResponse::release_pred_full_update_deltas() {
  clear_has_pred_full_update_deltas();
  ::blox::connect::GenerateFullUpdateDeltasResponse* temp = pred_full_update_deltas_;
  pred_full_update_deltas_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_pred_full_update_deltas(::blox::connect::GenerateFullUpdateDeltasResponse* pred_full_update_deltas) {
  delete pred_full_update_deltas_;
  pred_full_update_deltas_ = pred_full_update_deltas;
  if (pred_full_update_deltas) {
    set_has_pred_full_update_deltas();
  } else {
    clear_has_pred_full_update_deltas();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.pred_full_update_deltas)
}

// optional .blox.connect.ExecuteImportScriptResponse exec_import_script = 23;
inline bool CommandResponse::has_exec_import_script() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CommandResponse::set_has_exec_import_script() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CommandResponse::clear_has_exec_import_script() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CommandResponse::clear_exec_import_script() {
  if (exec_import_script_ != NULL) exec_import_script_->::blox::connect::ExecuteImportScriptResponse::Clear();
  clear_has_exec_import_script();
}
inline const ::blox::connect::ExecuteImportScriptResponse& CommandResponse::exec_import_script() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.exec_import_script)
  return exec_import_script_ != NULL ? *exec_import_script_ : *default_instance_->exec_import_script_;
}
inline ::blox::connect::ExecuteImportScriptResponse* CommandResponse::mutable_exec_import_script() {
  set_has_exec_import_script();
  if (exec_import_script_ == NULL) exec_import_script_ = new ::blox::connect::ExecuteImportScriptResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.exec_import_script)
  return exec_import_script_;
}
inline ::blox::connect::ExecuteImportScriptResponse* CommandResponse::release_exec_import_script() {
  clear_has_exec_import_script();
  ::blox::connect::ExecuteImportScriptResponse* temp = exec_import_script_;
  exec_import_script_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_exec_import_script(::blox::connect::ExecuteImportScriptResponse* exec_import_script) {
  delete exec_import_script_;
  exec_import_script_ = exec_import_script;
  if (exec_import_script) {
    set_has_exec_import_script();
  } else {
    clear_has_exec_import_script();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.exec_import_script)
}

// optional .blox.connect.GetProtocolDescriptorsResponse proto_get_descriptors = 24;
inline bool CommandResponse::has_proto_get_descriptors() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CommandResponse::set_has_proto_get_descriptors() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CommandResponse::clear_has_proto_get_descriptors() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CommandResponse::clear_proto_get_descriptors() {
  if (proto_get_descriptors_ != NULL) proto_get_descriptors_->::blox::connect::GetProtocolDescriptorsResponse::Clear();
  clear_has_proto_get_descriptors();
}
inline const ::blox::connect::GetProtocolDescriptorsResponse& CommandResponse::proto_get_descriptors() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.proto_get_descriptors)
  return proto_get_descriptors_ != NULL ? *proto_get_descriptors_ : *default_instance_->proto_get_descriptors_;
}
inline ::blox::connect::GetProtocolDescriptorsResponse* CommandResponse::mutable_proto_get_descriptors() {
  set_has_proto_get_descriptors();
  if (proto_get_descriptors_ == NULL) proto_get_descriptors_ = new ::blox::connect::GetProtocolDescriptorsResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.proto_get_descriptors)
  return proto_get_descriptors_;
}
inline ::blox::connect::GetProtocolDescriptorsResponse* CommandResponse::release_proto_get_descriptors() {
  clear_has_proto_get_descriptors();
  ::blox::connect::GetProtocolDescriptorsResponse* temp = proto_get_descriptors_;
  proto_get_descriptors_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_proto_get_descriptors(::blox::connect::GetProtocolDescriptorsResponse* proto_get_descriptors) {
  delete proto_get_descriptors_;
  proto_get_descriptors_ = proto_get_descriptors;
  if (proto_get_descriptors) {
    set_has_proto_get_descriptors();
  } else {
    clear_has_proto_get_descriptors();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.proto_get_descriptors)
}

// optional .blox.connect.BindBranchAliasResponse bind_branch_alias = 25;
inline bool CommandResponse::has_bind_branch_alias() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CommandResponse::set_has_bind_branch_alias() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CommandResponse::clear_has_bind_branch_alias() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CommandResponse::clear_bind_branch_alias() {
  if (bind_branch_alias_ != NULL) bind_branch_alias_->::blox::connect::BindBranchAliasResponse::Clear();
  clear_has_bind_branch_alias();
}
inline const ::blox::connect::BindBranchAliasResponse& CommandResponse::bind_branch_alias() const {
  // @@protoc_insertion_point(field_get:blox.connect.CommandResponse.bind_branch_alias)
  return bind_branch_alias_ != NULL ? *bind_branch_alias_ : *default_instance_->bind_branch_alias_;
}
inline ::blox::connect::BindBranchAliasResponse* CommandResponse::mutable_bind_branch_alias() {
  set_has_bind_branch_alias();
  if (bind_branch_alias_ == NULL) bind_branch_alias_ = new ::blox::connect::BindBranchAliasResponse;
  // @@protoc_insertion_point(field_mutable:blox.connect.CommandResponse.bind_branch_alias)
  return bind_branch_alias_;
}
inline ::blox::connect::BindBranchAliasResponse* CommandResponse::release_bind_branch_alias() {
  clear_has_bind_branch_alias();
  ::blox::connect::BindBranchAliasResponse* temp = bind_branch_alias_;
  bind_branch_alias_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_bind_branch_alias(::blox::connect::BindBranchAliasResponse* bind_branch_alias) {
  delete bind_branch_alias_;
  bind_branch_alias_ = bind_branch_alias;
  if (bind_branch_alias) {
    set_has_bind_branch_alias();
  } else {
    clear_has_bind_branch_alias();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CommandResponse.bind_branch_alias)
}

// -------------------------------------------------------------------

// AddBlock

// optional string block_name = 1;
inline bool AddBlock::has_block_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddBlock::set_has_block_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddBlock::clear_has_block_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddBlock::clear_block_name() {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_->clear();
  }
  clear_has_block_name();
}
inline const ::std::string& AddBlock::block_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddBlock.block_name)
  return *block_name_;
}
inline void AddBlock::set_block_name(const ::std::string& value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AddBlock.block_name)
}
inline void AddBlock::set_block_name(const char* value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AddBlock.block_name)
}
inline void AddBlock::set_block_name(const char* value, size_t size) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AddBlock.block_name)
}
inline ::std::string* AddBlock::mutable_block_name() {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AddBlock.block_name)
  return block_name_;
}
inline ::std::string* AddBlock::release_block_name() {
  clear_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = block_name_;
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddBlock::set_allocated_block_name(::std::string* block_name) {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete block_name_;
  }
  if (block_name) {
    set_has_block_name();
    block_name_ = block_name;
  } else {
    clear_has_block_name();
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AddBlock.block_name)
}

// optional bool active = 2;
inline bool AddBlock::has_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddBlock::set_has_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddBlock::clear_has_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddBlock::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool AddBlock::active() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddBlock.active)
  return active_;
}
inline void AddBlock::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.AddBlock.active)
}

// required bytes logic = 3;
inline bool AddBlock::has_logic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddBlock::set_has_logic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddBlock::clear_has_logic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddBlock::clear_logic() {
  if (logic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_->clear();
  }
  clear_has_logic();
}
inline const ::std::string& AddBlock::logic() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddBlock.logic)
  return *logic_;
}
inline void AddBlock::set_logic(const ::std::string& value) {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  logic_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AddBlock.logic)
}
inline void AddBlock::set_logic(const char* value) {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  logic_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AddBlock.logic)
}
inline void AddBlock::set_logic(const void* value, size_t size) {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  logic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AddBlock.logic)
}
inline ::std::string* AddBlock::mutable_logic() {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AddBlock.logic)
  return logic_;
}
inline ::std::string* AddBlock::release_logic() {
  clear_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = logic_;
    logic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddBlock::set_allocated_logic(::std::string* logic) {
  if (logic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete logic_;
  }
  if (logic) {
    set_has_logic();
    logic_ = logic;
  } else {
    clear_has_logic();
    logic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AddBlock.logic)
}

// optional .blox.connect.Language language = 4;
inline bool AddBlock::has_language() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddBlock::set_has_language() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddBlock::clear_has_language() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddBlock::clear_language() {
  language_ = 1;
  clear_has_language();
}
inline ::blox::connect::Language AddBlock::language() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddBlock.language)
  return static_cast< ::blox::connect::Language >(language_);
}
inline void AddBlock::set_language(::blox::connect::Language value) {
  assert(::blox::connect::Language_IsValid(value));
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.AddBlock.language)
}

// optional bool after_fixpoint = 5;
inline bool AddBlock::has_after_fixpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddBlock::set_has_after_fixpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddBlock::clear_has_after_fixpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddBlock::clear_after_fixpoint() {
  after_fixpoint_ = false;
  clear_has_after_fixpoint();
}
inline bool AddBlock::after_fixpoint() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddBlock.after_fixpoint)
  return after_fixpoint_;
}
inline void AddBlock::set_after_fixpoint(bool value) {
  set_has_after_fixpoint();
  after_fixpoint_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.AddBlock.after_fixpoint)
}

// -------------------------------------------------------------------

// AddBlockResponse

// optional string block_name = 1;
inline bool AddBlockResponse::has_block_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddBlockResponse::set_has_block_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddBlockResponse::clear_has_block_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddBlockResponse::clear_block_name() {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_->clear();
  }
  clear_has_block_name();
}
inline const ::std::string& AddBlockResponse::block_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddBlockResponse.block_name)
  return *block_name_;
}
inline void AddBlockResponse::set_block_name(const ::std::string& value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.AddBlockResponse.block_name)
}
inline void AddBlockResponse::set_block_name(const char* value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.AddBlockResponse.block_name)
}
inline void AddBlockResponse::set_block_name(const char* value, size_t size) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.AddBlockResponse.block_name)
}
inline ::std::string* AddBlockResponse::mutable_block_name() {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.AddBlockResponse.block_name)
  return block_name_;
}
inline ::std::string* AddBlockResponse::release_block_name() {
  clear_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = block_name_;
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddBlockResponse::set_allocated_block_name(::std::string* block_name) {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete block_name_;
  }
  if (block_name) {
    set_has_block_name();
    block_name_ = block_name;
  } else {
    clear_has_block_name();
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AddBlockResponse.block_name)
}

// optional .blox.common.protocol.CompilationProblems problems = 2;
inline bool AddBlockResponse::has_problems() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddBlockResponse::set_has_problems() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddBlockResponse::clear_has_problems() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddBlockResponse::clear_problems() {
  if (problems_ != NULL) problems_->::blox::common::protocol::CompilationProblems::Clear();
  clear_has_problems();
}
inline const ::blox::common::protocol::CompilationProblems& AddBlockResponse::problems() const {
  // @@protoc_insertion_point(field_get:blox.connect.AddBlockResponse.problems)
  return problems_ != NULL ? *problems_ : *default_instance_->problems_;
}
inline ::blox::common::protocol::CompilationProblems* AddBlockResponse::mutable_problems() {
  set_has_problems();
  if (problems_ == NULL) problems_ = new ::blox::common::protocol::CompilationProblems;
  // @@protoc_insertion_point(field_mutable:blox.connect.AddBlockResponse.problems)
  return problems_;
}
inline ::blox::common::protocol::CompilationProblems* AddBlockResponse::release_problems() {
  clear_has_problems();
  ::blox::common::protocol::CompilationProblems* temp = problems_;
  problems_ = NULL;
  return temp;
}
inline void AddBlockResponse::set_allocated_problems(::blox::common::protocol::CompilationProblems* problems) {
  delete problems_;
  problems_ = problems;
  if (problems) {
    set_has_problems();
  } else {
    clear_has_problems();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.AddBlockResponse.problems)
}

// -------------------------------------------------------------------

// RemoveBlock

// repeated string block_name = 1;
inline int RemoveBlock::block_name_size() const {
  return block_name_.size();
}
inline void RemoveBlock::clear_block_name() {
  block_name_.Clear();
}
inline const ::std::string& RemoveBlock::block_name(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.RemoveBlock.block_name)
  return block_name_.Get(index);
}
inline ::std::string* RemoveBlock::mutable_block_name(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.RemoveBlock.block_name)
  return block_name_.Mutable(index);
}
inline void RemoveBlock::set_block_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.RemoveBlock.block_name)
  block_name_.Mutable(index)->assign(value);
}
inline void RemoveBlock::set_block_name(int index, const char* value) {
  block_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.RemoveBlock.block_name)
}
inline void RemoveBlock::set_block_name(int index, const char* value, size_t size) {
  block_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.RemoveBlock.block_name)
}
inline ::std::string* RemoveBlock::add_block_name() {
  return block_name_.Add();
}
inline void RemoveBlock::add_block_name(const ::std::string& value) {
  block_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.RemoveBlock.block_name)
}
inline void RemoveBlock::add_block_name(const char* value) {
  block_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.RemoveBlock.block_name)
}
inline void RemoveBlock::add_block_name(const char* value, size_t size) {
  block_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.RemoveBlock.block_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RemoveBlock::block_name() const {
  // @@protoc_insertion_point(field_list:blox.connect.RemoveBlock.block_name)
  return block_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RemoveBlock::mutable_block_name() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.RemoveBlock.block_name)
  return &block_name_;
}

// -------------------------------------------------------------------

// RemoveBlockResponse

// optional .blox.common.protocol.CompilationProblems problems = 2;
inline bool RemoveBlockResponse::has_problems() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveBlockResponse::set_has_problems() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveBlockResponse::clear_has_problems() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveBlockResponse::clear_problems() {
  if (problems_ != NULL) problems_->::blox::common::protocol::CompilationProblems::Clear();
  clear_has_problems();
}
inline const ::blox::common::protocol::CompilationProblems& RemoveBlockResponse::problems() const {
  // @@protoc_insertion_point(field_get:blox.connect.RemoveBlockResponse.problems)
  return problems_ != NULL ? *problems_ : *default_instance_->problems_;
}
inline ::blox::common::protocol::CompilationProblems* RemoveBlockResponse::mutable_problems() {
  set_has_problems();
  if (problems_ == NULL) problems_ = new ::blox::common::protocol::CompilationProblems;
  // @@protoc_insertion_point(field_mutable:blox.connect.RemoveBlockResponse.problems)
  return problems_;
}
inline ::blox::common::protocol::CompilationProblems* RemoveBlockResponse::release_problems() {
  clear_has_problems();
  ::blox::common::protocol::CompilationProblems* temp = problems_;
  problems_ = NULL;
  return temp;
}
inline void RemoveBlockResponse::set_allocated_problems(::blox::common::protocol::CompilationProblems* problems) {
  delete problems_;
  problems_ = problems;
  if (problems) {
    set_has_problems();
  } else {
    clear_has_problems();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.RemoveBlockResponse.problems)
}

// -------------------------------------------------------------------

// CompileBlock

// optional string block_name = 1;
inline bool CompileBlock::has_block_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompileBlock::set_has_block_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompileBlock::clear_has_block_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompileBlock::clear_block_name() {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_->clear();
  }
  clear_has_block_name();
}
inline const ::std::string& CompileBlock::block_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.CompileBlock.block_name)
  return *block_name_;
}
inline void CompileBlock::set_block_name(const ::std::string& value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CompileBlock.block_name)
}
inline void CompileBlock::set_block_name(const char* value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CompileBlock.block_name)
}
inline void CompileBlock::set_block_name(const char* value, size_t size) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CompileBlock.block_name)
}
inline ::std::string* CompileBlock::mutable_block_name() {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CompileBlock.block_name)
  return block_name_;
}
inline ::std::string* CompileBlock::release_block_name() {
  clear_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = block_name_;
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CompileBlock::set_allocated_block_name(::std::string* block_name) {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete block_name_;
  }
  if (block_name) {
    set_has_block_name();
    block_name_ = block_name;
  } else {
    clear_has_block_name();
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CompileBlock.block_name)
}

// required .blox.common.protocol.LogicSort sort = 2;
inline bool CompileBlock::has_sort() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompileBlock::set_has_sort() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompileBlock::clear_has_sort() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompileBlock::clear_sort() {
  sort_ = 1;
  clear_has_sort();
}
inline ::blox::common::protocol::LogicSort CompileBlock::sort() const {
  // @@protoc_insertion_point(field_get:blox.connect.CompileBlock.sort)
  return static_cast< ::blox::common::protocol::LogicSort >(sort_);
}
inline void CompileBlock::set_sort(::blox::common::protocol::LogicSort value) {
  assert(::blox::common::protocol::LogicSort_IsValid(value));
  set_has_sort();
  sort_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.CompileBlock.sort)
}

// required string logic = 3;
inline bool CompileBlock::has_logic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompileBlock::set_has_logic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompileBlock::clear_has_logic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompileBlock::clear_logic() {
  if (logic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_->clear();
  }
  clear_has_logic();
}
inline const ::std::string& CompileBlock::logic() const {
  // @@protoc_insertion_point(field_get:blox.connect.CompileBlock.logic)
  return *logic_;
}
inline void CompileBlock::set_logic(const ::std::string& value) {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  logic_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CompileBlock.logic)
}
inline void CompileBlock::set_logic(const char* value) {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  logic_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CompileBlock.logic)
}
inline void CompileBlock::set_logic(const char* value, size_t size) {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  logic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CompileBlock.logic)
}
inline ::std::string* CompileBlock::mutable_logic() {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CompileBlock.logic)
  return logic_;
}
inline ::std::string* CompileBlock::release_logic() {
  clear_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = logic_;
    logic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CompileBlock::set_allocated_logic(::std::string* logic) {
  if (logic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete logic_;
  }
  if (logic) {
    set_has_logic();
    logic_ = logic;
  } else {
    clear_has_logic();
    logic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CompileBlock.logic)
}

// -------------------------------------------------------------------

// CompileBlockResponse

// optional .blox.common.protocol.CompilationProblems problems = 1;
inline bool CompileBlockResponse::has_problems() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompileBlockResponse::set_has_problems() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompileBlockResponse::clear_has_problems() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompileBlockResponse::clear_problems() {
  if (problems_ != NULL) problems_->::blox::common::protocol::CompilationProblems::Clear();
  clear_has_problems();
}
inline const ::blox::common::protocol::CompilationProblems& CompileBlockResponse::problems() const {
  // @@protoc_insertion_point(field_get:blox.connect.CompileBlockResponse.problems)
  return problems_ != NULL ? *problems_ : *default_instance_->problems_;
}
inline ::blox::common::protocol::CompilationProblems* CompileBlockResponse::mutable_problems() {
  set_has_problems();
  if (problems_ == NULL) problems_ = new ::blox::common::protocol::CompilationProblems;
  // @@protoc_insertion_point(field_mutable:blox.connect.CompileBlockResponse.problems)
  return problems_;
}
inline ::blox::common::protocol::CompilationProblems* CompileBlockResponse::release_problems() {
  clear_has_problems();
  ::blox::common::protocol::CompilationProblems* temp = problems_;
  problems_ = NULL;
  return temp;
}
inline void CompileBlockResponse::set_allocated_problems(::blox::common::protocol::CompilationProblems* problems) {
  delete problems_;
  problems_ = problems;
  if (problems) {
    set_has_problems();
  } else {
    clear_has_problems();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CompileBlockResponse.problems)
}

// optional bytes result = 2;
inline bool CompileBlockResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompileBlockResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompileBlockResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompileBlockResponse::clear_result() {
  if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& CompileBlockResponse::result() const {
  // @@protoc_insertion_point(field_get:blox.connect.CompileBlockResponse.result)
  return *result_;
}
inline void CompileBlockResponse::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_ = new ::std::string;
  }
  result_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.CompileBlockResponse.result)
}
inline void CompileBlockResponse::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_ = new ::std::string;
  }
  result_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.CompileBlockResponse.result)
}
inline void CompileBlockResponse::set_result(const void* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.CompileBlockResponse.result)
}
inline ::std::string* CompileBlockResponse::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.CompileBlockResponse.result)
  return result_;
}
inline ::std::string* CompileBlockResponse::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CompileBlockResponse::set_allocated_result(::std::string* result) {
  if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_;
  }
  if (result) {
    set_has_result();
    result_ = result;
  } else {
    clear_has_result();
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.CompileBlockResponse.result)
}

// -------------------------------------------------------------------

// InstallLibrary

// required string name = 1;
inline bool InstallLibrary::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstallLibrary::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstallLibrary::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstallLibrary::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InstallLibrary::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.InstallLibrary.name)
  return *name_;
}
inline void InstallLibrary::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.InstallLibrary.name)
}
inline void InstallLibrary::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.InstallLibrary.name)
}
inline void InstallLibrary::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.InstallLibrary.name)
}
inline ::std::string* InstallLibrary::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.InstallLibrary.name)
  return name_;
}
inline ::std::string* InstallLibrary::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstallLibrary::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.InstallLibrary.name)
}

// -------------------------------------------------------------------

// InstallLibraryResponse

// -------------------------------------------------------------------

// InstallProject

// required string projDir = 1;
inline bool InstallProject::has_projdir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstallProject::set_has_projdir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstallProject::clear_has_projdir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstallProject::clear_projdir() {
  if (projdir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    projdir_->clear();
  }
  clear_has_projdir();
}
inline const ::std::string& InstallProject::projdir() const {
  // @@protoc_insertion_point(field_get:blox.connect.InstallProject.projDir)
  return *projdir_;
}
inline void InstallProject::set_projdir(const ::std::string& value) {
  set_has_projdir();
  if (projdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    projdir_ = new ::std::string;
  }
  projdir_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.InstallProject.projDir)
}
inline void InstallProject::set_projdir(const char* value) {
  set_has_projdir();
  if (projdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    projdir_ = new ::std::string;
  }
  projdir_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.InstallProject.projDir)
}
inline void InstallProject::set_projdir(const char* value, size_t size) {
  set_has_projdir();
  if (projdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    projdir_ = new ::std::string;
  }
  projdir_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.InstallProject.projDir)
}
inline ::std::string* InstallProject::mutable_projdir() {
  set_has_projdir();
  if (projdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    projdir_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.InstallProject.projDir)
  return projdir_;
}
inline ::std::string* InstallProject::release_projdir() {
  clear_has_projdir();
  if (projdir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = projdir_;
    projdir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstallProject::set_allocated_projdir(::std::string* projdir) {
  if (projdir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete projdir_;
  }
  if (projdir) {
    set_has_projdir();
    projdir_ = projdir;
  } else {
    clear_has_projdir();
    projdir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.InstallProject.projDir)
}

// optional bool recurse = 2 [default = true];
inline bool InstallProject::has_recurse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstallProject::set_has_recurse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstallProject::clear_has_recurse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstallProject::clear_recurse() {
  recurse_ = true;
  clear_has_recurse();
}
inline bool InstallProject::recurse() const {
  // @@protoc_insertion_point(field_get:blox.connect.InstallProject.recurse)
  return recurse_;
}
inline void InstallProject::set_recurse(bool value) {
  set_has_recurse();
  recurse_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.InstallProject.recurse)
}

// optional bool copy = 3 [default = true];
inline bool InstallProject::has_copy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstallProject::set_has_copy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstallProject::clear_has_copy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstallProject::clear_copy() {
  copy_ = true;
  clear_has_copy();
}
inline bool InstallProject::copy() const {
  // @@protoc_insertion_point(field_get:blox.connect.InstallProject.copy)
  return copy_;
}
inline void InstallProject::set_copy(bool value) {
  set_has_copy();
  copy_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.InstallProject.copy)
}

// optional string lib_path = 4;
inline bool InstallProject::has_lib_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstallProject::set_has_lib_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstallProject::clear_has_lib_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstallProject::clear_lib_path() {
  if (lib_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_path_->clear();
  }
  clear_has_lib_path();
}
inline const ::std::string& InstallProject::lib_path() const {
  // @@protoc_insertion_point(field_get:blox.connect.InstallProject.lib_path)
  return *lib_path_;
}
inline void InstallProject::set_lib_path(const ::std::string& value) {
  set_has_lib_path();
  if (lib_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_path_ = new ::std::string;
  }
  lib_path_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.InstallProject.lib_path)
}
inline void InstallProject::set_lib_path(const char* value) {
  set_has_lib_path();
  if (lib_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_path_ = new ::std::string;
  }
  lib_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.InstallProject.lib_path)
}
inline void InstallProject::set_lib_path(const char* value, size_t size) {
  set_has_lib_path();
  if (lib_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_path_ = new ::std::string;
  }
  lib_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.InstallProject.lib_path)
}
inline ::std::string* InstallProject::mutable_lib_path() {
  set_has_lib_path();
  if (lib_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.InstallProject.lib_path)
  return lib_path_;
}
inline ::std::string* InstallProject::release_lib_path() {
  clear_has_lib_path();
  if (lib_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lib_path_;
    lib_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstallProject::set_allocated_lib_path(::std::string* lib_path) {
  if (lib_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lib_path_;
  }
  if (lib_path) {
    set_has_lib_path();
    lib_path_ = lib_path;
  } else {
    clear_has_lib_path();
    lib_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.InstallProject.lib_path)
}

// -------------------------------------------------------------------

// InstallProjectResponse

// -------------------------------------------------------------------

// ExecInactiveBlock

// required string block_name = 1;
inline bool ExecInactiveBlock::has_block_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecInactiveBlock::set_has_block_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecInactiveBlock::clear_has_block_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecInactiveBlock::clear_block_name() {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_->clear();
  }
  clear_has_block_name();
}
inline const ::std::string& ExecInactiveBlock::block_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecInactiveBlock.block_name)
  return *block_name_;
}
inline void ExecInactiveBlock::set_block_name(const ::std::string& value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExecInactiveBlock.block_name)
}
inline void ExecInactiveBlock::set_block_name(const char* value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExecInactiveBlock.block_name)
}
inline void ExecInactiveBlock::set_block_name(const char* value, size_t size) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExecInactiveBlock.block_name)
}
inline ::std::string* ExecInactiveBlock::mutable_block_name() {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecInactiveBlock.block_name)
  return block_name_;
}
inline ::std::string* ExecInactiveBlock::release_block_name() {
  clear_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = block_name_;
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecInactiveBlock::set_allocated_block_name(::std::string* block_name) {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete block_name_;
  }
  if (block_name) {
    set_has_block_name();
    block_name_ = block_name;
  } else {
    clear_has_block_name();
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExecInactiveBlock.block_name)
}

// repeated .blox.connect.InputBinding input = 2;
inline int ExecInactiveBlock::input_size() const {
  return input_.size();
}
inline void ExecInactiveBlock::clear_input() {
  input_.Clear();
}
inline const ::blox::connect::InputBinding& ExecInactiveBlock::input(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecInactiveBlock.input)
  return input_.Get(index);
}
inline ::blox::connect::InputBinding* ExecInactiveBlock::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecInactiveBlock.input)
  return input_.Mutable(index);
}
inline ::blox::connect::InputBinding* ExecInactiveBlock::add_input() {
  // @@protoc_insertion_point(field_add:blox.connect.ExecInactiveBlock.input)
  return input_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding >&
ExecInactiveBlock::input() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecInactiveBlock.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding >*
ExecInactiveBlock::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecInactiveBlock.input)
  return &input_;
}

// repeated string return_local = 3;
inline int ExecInactiveBlock::return_local_size() const {
  return return_local_.size();
}
inline void ExecInactiveBlock::clear_return_local() {
  return_local_.Clear();
}
inline const ::std::string& ExecInactiveBlock::return_local(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecInactiveBlock.return_local)
  return return_local_.Get(index);
}
inline ::std::string* ExecInactiveBlock::mutable_return_local(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecInactiveBlock.return_local)
  return return_local_.Mutable(index);
}
inline void ExecInactiveBlock::set_return_local(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.ExecInactiveBlock.return_local)
  return_local_.Mutable(index)->assign(value);
}
inline void ExecInactiveBlock::set_return_local(int index, const char* value) {
  return_local_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExecInactiveBlock.return_local)
}
inline void ExecInactiveBlock::set_return_local(int index, const char* value, size_t size) {
  return_local_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExecInactiveBlock.return_local)
}
inline ::std::string* ExecInactiveBlock::add_return_local() {
  return return_local_.Add();
}
inline void ExecInactiveBlock::add_return_local(const ::std::string& value) {
  return_local_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.ExecInactiveBlock.return_local)
}
inline void ExecInactiveBlock::add_return_local(const char* value) {
  return_local_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.ExecInactiveBlock.return_local)
}
inline void ExecInactiveBlock::add_return_local(const char* value, size_t size) {
  return_local_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.ExecInactiveBlock.return_local)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExecInactiveBlock::return_local() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecInactiveBlock.return_local)
  return return_local_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExecInactiveBlock::mutable_return_local() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecInactiveBlock.return_local)
  return &return_local_;
}

// repeated .blox.connect.ReturnLocalProtoBuf return_protobuf = 4;
inline int ExecInactiveBlock::return_protobuf_size() const {
  return return_protobuf_.size();
}
inline void ExecInactiveBlock::clear_return_protobuf() {
  return_protobuf_.Clear();
}
inline const ::blox::connect::ReturnLocalProtoBuf& ExecInactiveBlock::return_protobuf(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecInactiveBlock.return_protobuf)
  return return_protobuf_.Get(index);
}
inline ::blox::connect::ReturnLocalProtoBuf* ExecInactiveBlock::mutable_return_protobuf(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecInactiveBlock.return_protobuf)
  return return_protobuf_.Mutable(index);
}
inline ::blox::connect::ReturnLocalProtoBuf* ExecInactiveBlock::add_return_protobuf() {
  // @@protoc_insertion_point(field_add:blox.connect.ExecInactiveBlock.return_protobuf)
  return return_protobuf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf >&
ExecInactiveBlock::return_protobuf() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecInactiveBlock.return_protobuf)
  return return_protobuf_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf >*
ExecInactiveBlock::mutable_return_protobuf() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecInactiveBlock.return_protobuf)
  return &return_protobuf_;
}

// -------------------------------------------------------------------

// ExecInactiveBlockResponse

// repeated .blox.connect.Relation return_local = 1;
inline int ExecInactiveBlockResponse::return_local_size() const {
  return return_local_.size();
}
inline void ExecInactiveBlockResponse::clear_return_local() {
  return_local_.Clear();
}
inline const ::blox::connect::Relation& ExecInactiveBlockResponse::return_local(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecInactiveBlockResponse.return_local)
  return return_local_.Get(index);
}
inline ::blox::connect::Relation* ExecInactiveBlockResponse::mutable_return_local(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecInactiveBlockResponse.return_local)
  return return_local_.Mutable(index);
}
inline ::blox::connect::Relation* ExecInactiveBlockResponse::add_return_local() {
  // @@protoc_insertion_point(field_add:blox.connect.ExecInactiveBlockResponse.return_local)
  return return_local_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >&
ExecInactiveBlockResponse::return_local() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecInactiveBlockResponse.return_local)
  return return_local_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >*
ExecInactiveBlockResponse::mutable_return_local() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecInactiveBlockResponse.return_local)
  return &return_local_;
}

// repeated .blox.connect.ReturnLocalProtoBufResponse return_protobuf = 2;
inline int ExecInactiveBlockResponse::return_protobuf_size() const {
  return return_protobuf_.size();
}
inline void ExecInactiveBlockResponse::clear_return_protobuf() {
  return_protobuf_.Clear();
}
inline const ::blox::connect::ReturnLocalProtoBufResponse& ExecInactiveBlockResponse::return_protobuf(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecInactiveBlockResponse.return_protobuf)
  return return_protobuf_.Get(index);
}
inline ::blox::connect::ReturnLocalProtoBufResponse* ExecInactiveBlockResponse::mutable_return_protobuf(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecInactiveBlockResponse.return_protobuf)
  return return_protobuf_.Mutable(index);
}
inline ::blox::connect::ReturnLocalProtoBufResponse* ExecInactiveBlockResponse::add_return_protobuf() {
  // @@protoc_insertion_point(field_add:blox.connect.ExecInactiveBlockResponse.return_protobuf)
  return return_protobuf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse >&
ExecInactiveBlockResponse::return_protobuf() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecInactiveBlockResponse.return_protobuf)
  return return_protobuf_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse >*
ExecInactiveBlockResponse::mutable_return_protobuf() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecInactiveBlockResponse.return_protobuf)
  return &return_protobuf_;
}

// -------------------------------------------------------------------

// ReturnLocalProtoBuf

// required string predicate = 1;
inline bool ReturnLocalProtoBuf::has_predicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReturnLocalProtoBuf::set_has_predicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReturnLocalProtoBuf::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReturnLocalProtoBuf::clear_predicate() {
  if (predicate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_->clear();
  }
  clear_has_predicate();
}
inline const ::std::string& ReturnLocalProtoBuf::predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.ReturnLocalProtoBuf.predicate)
  return *predicate_;
}
inline void ReturnLocalProtoBuf::set_predicate(const ::std::string& value) {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_ = new ::std::string;
  }
  predicate_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ReturnLocalProtoBuf.predicate)
}
inline void ReturnLocalProtoBuf::set_predicate(const char* value) {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_ = new ::std::string;
  }
  predicate_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ReturnLocalProtoBuf.predicate)
}
inline void ReturnLocalProtoBuf::set_predicate(const char* value, size_t size) {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_ = new ::std::string;
  }
  predicate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ReturnLocalProtoBuf.predicate)
}
inline ::std::string* ReturnLocalProtoBuf::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ReturnLocalProtoBuf.predicate)
  return predicate_;
}
inline ::std::string* ReturnLocalProtoBuf::release_predicate() {
  clear_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = predicate_;
    predicate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnLocalProtoBuf::set_allocated_predicate(::std::string* predicate) {
  if (predicate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete predicate_;
  }
  if (predicate) {
    set_has_predicate();
    predicate_ = predicate;
  } else {
    clear_has_predicate();
    predicate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ReturnLocalProtoBuf.predicate)
}

// required string protocol = 2;
inline bool ReturnLocalProtoBuf::has_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReturnLocalProtoBuf::set_has_protocol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReturnLocalProtoBuf::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReturnLocalProtoBuf::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& ReturnLocalProtoBuf::protocol() const {
  // @@protoc_insertion_point(field_get:blox.connect.ReturnLocalProtoBuf.protocol)
  return *protocol_;
}
inline void ReturnLocalProtoBuf::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ReturnLocalProtoBuf.protocol)
}
inline void ReturnLocalProtoBuf::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ReturnLocalProtoBuf.protocol)
}
inline void ReturnLocalProtoBuf::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ReturnLocalProtoBuf.protocol)
}
inline ::std::string* ReturnLocalProtoBuf::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ReturnLocalProtoBuf.protocol)
  return protocol_;
}
inline ::std::string* ReturnLocalProtoBuf::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnLocalProtoBuf::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ReturnLocalProtoBuf.protocol)
}

// -------------------------------------------------------------------

// ReturnLocalProtoBufResponse

// optional string predicate = 1;
inline bool ReturnLocalProtoBufResponse::has_predicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReturnLocalProtoBufResponse::set_has_predicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReturnLocalProtoBufResponse::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReturnLocalProtoBufResponse::clear_predicate() {
  if (predicate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_->clear();
  }
  clear_has_predicate();
}
inline const ::std::string& ReturnLocalProtoBufResponse::predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.ReturnLocalProtoBufResponse.predicate)
  return *predicate_;
}
inline void ReturnLocalProtoBufResponse::set_predicate(const ::std::string& value) {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_ = new ::std::string;
  }
  predicate_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ReturnLocalProtoBufResponse.predicate)
}
inline void ReturnLocalProtoBufResponse::set_predicate(const char* value) {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_ = new ::std::string;
  }
  predicate_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ReturnLocalProtoBufResponse.predicate)
}
inline void ReturnLocalProtoBufResponse::set_predicate(const char* value, size_t size) {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_ = new ::std::string;
  }
  predicate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ReturnLocalProtoBufResponse.predicate)
}
inline ::std::string* ReturnLocalProtoBufResponse::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    predicate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ReturnLocalProtoBufResponse.predicate)
  return predicate_;
}
inline ::std::string* ReturnLocalProtoBufResponse::release_predicate() {
  clear_has_predicate();
  if (predicate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = predicate_;
    predicate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnLocalProtoBufResponse::set_allocated_predicate(::std::string* predicate) {
  if (predicate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete predicate_;
  }
  if (predicate) {
    set_has_predicate();
    predicate_ = predicate;
  } else {
    clear_has_predicate();
    predicate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ReturnLocalProtoBufResponse.predicate)
}

// repeated bytes message = 2;
inline int ReturnLocalProtoBufResponse::message_size() const {
  return message_.size();
}
inline void ReturnLocalProtoBufResponse::clear_message() {
  message_.Clear();
}
inline const ::std::string& ReturnLocalProtoBufResponse::message(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ReturnLocalProtoBufResponse.message)
  return message_.Get(index);
}
inline ::std::string* ReturnLocalProtoBufResponse::mutable_message(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ReturnLocalProtoBufResponse.message)
  return message_.Mutable(index);
}
inline void ReturnLocalProtoBufResponse::set_message(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.ReturnLocalProtoBufResponse.message)
  message_.Mutable(index)->assign(value);
}
inline void ReturnLocalProtoBufResponse::set_message(int index, const char* value) {
  message_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ReturnLocalProtoBufResponse.message)
}
inline void ReturnLocalProtoBufResponse::set_message(int index, const void* value, size_t size) {
  message_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ReturnLocalProtoBufResponse.message)
}
inline ::std::string* ReturnLocalProtoBufResponse::add_message() {
  return message_.Add();
}
inline void ReturnLocalProtoBufResponse::add_message(const ::std::string& value) {
  message_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.ReturnLocalProtoBufResponse.message)
}
inline void ReturnLocalProtoBufResponse::add_message(const char* value) {
  message_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.ReturnLocalProtoBufResponse.message)
}
inline void ReturnLocalProtoBufResponse::add_message(const void* value, size_t size) {
  message_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.ReturnLocalProtoBufResponse.message)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReturnLocalProtoBufResponse::message() const {
  // @@protoc_insertion_point(field_list:blox.connect.ReturnLocalProtoBufResponse.message)
  return message_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReturnLocalProtoBufResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ReturnLocalProtoBufResponse.message)
  return &message_;
}

// -------------------------------------------------------------------

// ExecBlock

// optional string block_name = 1;
inline bool ExecBlock::has_block_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecBlock::set_has_block_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecBlock::clear_has_block_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecBlock::clear_block_name() {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_->clear();
  }
  clear_has_block_name();
}
inline const ::std::string& ExecBlock::block_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecBlock.block_name)
  return *block_name_;
}
inline void ExecBlock::set_block_name(const ::std::string& value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExecBlock.block_name)
}
inline void ExecBlock::set_block_name(const char* value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExecBlock.block_name)
}
inline void ExecBlock::set_block_name(const char* value, size_t size) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExecBlock.block_name)
}
inline ::std::string* ExecBlock::mutable_block_name() {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecBlock.block_name)
  return block_name_;
}
inline ::std::string* ExecBlock::release_block_name() {
  clear_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = block_name_;
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecBlock::set_allocated_block_name(::std::string* block_name) {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete block_name_;
  }
  if (block_name) {
    set_has_block_name();
    block_name_ = block_name;
  } else {
    clear_has_block_name();
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExecBlock.block_name)
}

// required bytes logic = 2;
inline bool ExecBlock::has_logic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecBlock::set_has_logic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecBlock::clear_has_logic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecBlock::clear_logic() {
  if (logic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_->clear();
  }
  clear_has_logic();
}
inline const ::std::string& ExecBlock::logic() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecBlock.logic)
  return *logic_;
}
inline void ExecBlock::set_logic(const ::std::string& value) {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  logic_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExecBlock.logic)
}
inline void ExecBlock::set_logic(const char* value) {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  logic_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExecBlock.logic)
}
inline void ExecBlock::set_logic(const void* value, size_t size) {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  logic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExecBlock.logic)
}
inline ::std::string* ExecBlock::mutable_logic() {
  set_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    logic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecBlock.logic)
  return logic_;
}
inline ::std::string* ExecBlock::release_logic() {
  clear_has_logic();
  if (logic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = logic_;
    logic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecBlock::set_allocated_logic(::std::string* logic) {
  if (logic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete logic_;
  }
  if (logic) {
    set_has_logic();
    logic_ = logic;
  } else {
    clear_has_logic();
    logic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExecBlock.logic)
}

// optional .blox.connect.Language language = 3;
inline bool ExecBlock::has_language() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecBlock::set_has_language() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecBlock::clear_has_language() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecBlock::clear_language() {
  language_ = 1;
  clear_has_language();
}
inline ::blox::connect::Language ExecBlock::language() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecBlock.language)
  return static_cast< ::blox::connect::Language >(language_);
}
inline void ExecBlock::set_language(::blox::connect::Language value) {
  assert(::blox::connect::Language_IsValid(value));
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.ExecBlock.language)
}

// repeated .blox.connect.InputBinding input = 4;
inline int ExecBlock::input_size() const {
  return input_.size();
}
inline void ExecBlock::clear_input() {
  input_.Clear();
}
inline const ::blox::connect::InputBinding& ExecBlock::input(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecBlock.input)
  return input_.Get(index);
}
inline ::blox::connect::InputBinding* ExecBlock::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecBlock.input)
  return input_.Mutable(index);
}
inline ::blox::connect::InputBinding* ExecBlock::add_input() {
  // @@protoc_insertion_point(field_add:blox.connect.ExecBlock.input)
  return input_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding >&
ExecBlock::input() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecBlock.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::InputBinding >*
ExecBlock::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecBlock.input)
  return &input_;
}

// repeated string return_local = 5;
inline int ExecBlock::return_local_size() const {
  return return_local_.size();
}
inline void ExecBlock::clear_return_local() {
  return_local_.Clear();
}
inline const ::std::string& ExecBlock::return_local(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecBlock.return_local)
  return return_local_.Get(index);
}
inline ::std::string* ExecBlock::mutable_return_local(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecBlock.return_local)
  return return_local_.Mutable(index);
}
inline void ExecBlock::set_return_local(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.ExecBlock.return_local)
  return_local_.Mutable(index)->assign(value);
}
inline void ExecBlock::set_return_local(int index, const char* value) {
  return_local_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExecBlock.return_local)
}
inline void ExecBlock::set_return_local(int index, const char* value, size_t size) {
  return_local_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExecBlock.return_local)
}
inline ::std::string* ExecBlock::add_return_local() {
  return return_local_.Add();
}
inline void ExecBlock::add_return_local(const ::std::string& value) {
  return_local_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.ExecBlock.return_local)
}
inline void ExecBlock::add_return_local(const char* value) {
  return_local_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.ExecBlock.return_local)
}
inline void ExecBlock::add_return_local(const char* value, size_t size) {
  return_local_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.ExecBlock.return_local)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExecBlock::return_local() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecBlock.return_local)
  return return_local_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExecBlock::mutable_return_local() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecBlock.return_local)
  return &return_local_;
}

// repeated .blox.connect.ReturnLocalProtoBuf return_protobuf = 6;
inline int ExecBlock::return_protobuf_size() const {
  return return_protobuf_.size();
}
inline void ExecBlock::clear_return_protobuf() {
  return_protobuf_.Clear();
}
inline const ::blox::connect::ReturnLocalProtoBuf& ExecBlock::return_protobuf(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecBlock.return_protobuf)
  return return_protobuf_.Get(index);
}
inline ::blox::connect::ReturnLocalProtoBuf* ExecBlock::mutable_return_protobuf(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecBlock.return_protobuf)
  return return_protobuf_.Mutable(index);
}
inline ::blox::connect::ReturnLocalProtoBuf* ExecBlock::add_return_protobuf() {
  // @@protoc_insertion_point(field_add:blox.connect.ExecBlock.return_protobuf)
  return return_protobuf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf >&
ExecBlock::return_protobuf() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecBlock.return_protobuf)
  return return_protobuf_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBuf >*
ExecBlock::mutable_return_protobuf() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecBlock.return_protobuf)
  return &return_protobuf_;
}

// -------------------------------------------------------------------

// ExecBlockResponse

// optional .blox.common.protocol.CompilationProblems problems = 1;
inline bool ExecBlockResponse::has_problems() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecBlockResponse::set_has_problems() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecBlockResponse::clear_has_problems() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecBlockResponse::clear_problems() {
  if (problems_ != NULL) problems_->::blox::common::protocol::CompilationProblems::Clear();
  clear_has_problems();
}
inline const ::blox::common::protocol::CompilationProblems& ExecBlockResponse::problems() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecBlockResponse.problems)
  return problems_ != NULL ? *problems_ : *default_instance_->problems_;
}
inline ::blox::common::protocol::CompilationProblems* ExecBlockResponse::mutable_problems() {
  set_has_problems();
  if (problems_ == NULL) problems_ = new ::blox::common::protocol::CompilationProblems;
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecBlockResponse.problems)
  return problems_;
}
inline ::blox::common::protocol::CompilationProblems* ExecBlockResponse::release_problems() {
  clear_has_problems();
  ::blox::common::protocol::CompilationProblems* temp = problems_;
  problems_ = NULL;
  return temp;
}
inline void ExecBlockResponse::set_allocated_problems(::blox::common::protocol::CompilationProblems* problems) {
  delete problems_;
  problems_ = problems;
  if (problems) {
    set_has_problems();
  } else {
    clear_has_problems();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExecBlockResponse.problems)
}

// repeated .blox.connect.Relation return_local = 2;
inline int ExecBlockResponse::return_local_size() const {
  return return_local_.size();
}
inline void ExecBlockResponse::clear_return_local() {
  return_local_.Clear();
}
inline const ::blox::connect::Relation& ExecBlockResponse::return_local(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecBlockResponse.return_local)
  return return_local_.Get(index);
}
inline ::blox::connect::Relation* ExecBlockResponse::mutable_return_local(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecBlockResponse.return_local)
  return return_local_.Mutable(index);
}
inline ::blox::connect::Relation* ExecBlockResponse::add_return_local() {
  // @@protoc_insertion_point(field_add:blox.connect.ExecBlockResponse.return_local)
  return return_local_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >&
ExecBlockResponse::return_local() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecBlockResponse.return_local)
  return return_local_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Relation >*
ExecBlockResponse::mutable_return_local() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecBlockResponse.return_local)
  return &return_local_;
}

// repeated .blox.connect.ReturnLocalProtoBufResponse return_protobuf = 3;
inline int ExecBlockResponse::return_protobuf_size() const {
  return return_protobuf_.size();
}
inline void ExecBlockResponse::clear_return_protobuf() {
  return_protobuf_.Clear();
}
inline const ::blox::connect::ReturnLocalProtoBufResponse& ExecBlockResponse::return_protobuf(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecBlockResponse.return_protobuf)
  return return_protobuf_.Get(index);
}
inline ::blox::connect::ReturnLocalProtoBufResponse* ExecBlockResponse::mutable_return_protobuf(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecBlockResponse.return_protobuf)
  return return_protobuf_.Mutable(index);
}
inline ::blox::connect::ReturnLocalProtoBufResponse* ExecBlockResponse::add_return_protobuf() {
  // @@protoc_insertion_point(field_add:blox.connect.ExecBlockResponse.return_protobuf)
  return return_protobuf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse >&
ExecBlockResponse::return_protobuf() const {
  // @@protoc_insertion_point(field_list:blox.connect.ExecBlockResponse.return_protobuf)
  return return_protobuf_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ReturnLocalProtoBufResponse >*
ExecBlockResponse::mutable_return_protobuf() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.ExecBlockResponse.return_protobuf)
  return &return_protobuf_;
}

// -------------------------------------------------------------------

// QueryPredicate

// required .blox.connect.PredicateName predicate = 1;
inline bool QueryPredicate::has_predicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryPredicate::set_has_predicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryPredicate::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryPredicate::clear_predicate() {
  if (predicate_ != NULL) predicate_->::blox::connect::PredicateName::Clear();
  clear_has_predicate();
}
inline const ::blox::connect::PredicateName& QueryPredicate::predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.QueryPredicate.predicate)
  return predicate_ != NULL ? *predicate_ : *default_instance_->predicate_;
}
inline ::blox::connect::PredicateName* QueryPredicate::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == NULL) predicate_ = new ::blox::connect::PredicateName;
  // @@protoc_insertion_point(field_mutable:blox.connect.QueryPredicate.predicate)
  return predicate_;
}
inline ::blox::connect::PredicateName* QueryPredicate::release_predicate() {
  clear_has_predicate();
  ::blox::connect::PredicateName* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline void QueryPredicate::set_allocated_predicate(::blox::connect::PredicateName* predicate) {
  delete predicate_;
  predicate_ = predicate;
  if (predicate) {
    set_has_predicate();
  } else {
    clear_has_predicate();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.QueryPredicate.predicate)
}

// optional .blox.connect.DeltaModifier delta = 2;
inline bool QueryPredicate::has_delta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryPredicate::set_has_delta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryPredicate::clear_has_delta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryPredicate::clear_delta() {
  delta_ = 1;
  clear_has_delta();
}
inline ::blox::connect::DeltaModifier QueryPredicate::delta() const {
  // @@protoc_insertion_point(field_get:blox.connect.QueryPredicate.delta)
  return static_cast< ::blox::connect::DeltaModifier >(delta_);
}
inline void QueryPredicate::set_delta(::blox::connect::DeltaModifier value) {
  assert(::blox::connect::DeltaModifier_IsValid(value));
  set_has_delta();
  delta_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.QueryPredicate.delta)
}

// optional bool return_refmodes = 3 [default = true];
inline bool QueryPredicate::has_return_refmodes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryPredicate::set_has_return_refmodes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryPredicate::clear_has_return_refmodes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryPredicate::clear_return_refmodes() {
  return_refmodes_ = true;
  clear_has_return_refmodes();
}
inline bool QueryPredicate::return_refmodes() const {
  // @@protoc_insertion_point(field_get:blox.connect.QueryPredicate.return_refmodes)
  return return_refmodes_;
}
inline void QueryPredicate::set_return_refmodes(bool value) {
  set_has_return_refmodes();
  return_refmodes_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.QueryPredicate.return_refmodes)
}

// -------------------------------------------------------------------

// QueryPredicateResponse

// required .blox.connect.Relation relation = 1;
inline bool QueryPredicateResponse::has_relation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryPredicateResponse::set_has_relation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryPredicateResponse::clear_has_relation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryPredicateResponse::clear_relation() {
  if (relation_ != NULL) relation_->::blox::connect::Relation::Clear();
  clear_has_relation();
}
inline const ::blox::connect::Relation& QueryPredicateResponse::relation() const {
  // @@protoc_insertion_point(field_get:blox.connect.QueryPredicateResponse.relation)
  return relation_ != NULL ? *relation_ : *default_instance_->relation_;
}
inline ::blox::connect::Relation* QueryPredicateResponse::mutable_relation() {
  set_has_relation();
  if (relation_ == NULL) relation_ = new ::blox::connect::Relation;
  // @@protoc_insertion_point(field_mutable:blox.connect.QueryPredicateResponse.relation)
  return relation_;
}
inline ::blox::connect::Relation* QueryPredicateResponse::release_relation() {
  clear_has_relation();
  ::blox::connect::Relation* temp = relation_;
  relation_ = NULL;
  return temp;
}
inline void QueryPredicateResponse::set_allocated_relation(::blox::connect::Relation* relation) {
  delete relation_;
  relation_ = relation;
  if (relation) {
    set_has_relation();
  } else {
    clear_has_relation();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.QueryPredicateResponse.relation)
}

// -------------------------------------------------------------------

// UpdatePredicate

// required .blox.connect.PredicateName predicate = 1;
inline bool UpdatePredicate::has_predicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdatePredicate::set_has_predicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdatePredicate::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdatePredicate::clear_predicate() {
  if (predicate_ != NULL) predicate_->::blox::connect::PredicateName::Clear();
  clear_has_predicate();
}
inline const ::blox::connect::PredicateName& UpdatePredicate::predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.UpdatePredicate.predicate)
  return predicate_ != NULL ? *predicate_ : *default_instance_->predicate_;
}
inline ::blox::connect::PredicateName* UpdatePredicate::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == NULL) predicate_ = new ::blox::connect::PredicateName;
  // @@protoc_insertion_point(field_mutable:blox.connect.UpdatePredicate.predicate)
  return predicate_;
}
inline ::blox::connect::PredicateName* UpdatePredicate::release_predicate() {
  clear_has_predicate();
  ::blox::connect::PredicateName* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline void UpdatePredicate::set_allocated_predicate(::blox::connect::PredicateName* predicate) {
  delete predicate_;
  predicate_ = predicate;
  if (predicate) {
    set_has_predicate();
  } else {
    clear_has_predicate();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.UpdatePredicate.predicate)
}

// required .blox.connect.Relation relation = 2;
inline bool UpdatePredicate::has_relation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdatePredicate::set_has_relation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdatePredicate::clear_has_relation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdatePredicate::clear_relation() {
  if (relation_ != NULL) relation_->::blox::connect::Relation::Clear();
  clear_has_relation();
}
inline const ::blox::connect::Relation& UpdatePredicate::relation() const {
  // @@protoc_insertion_point(field_get:blox.connect.UpdatePredicate.relation)
  return relation_ != NULL ? *relation_ : *default_instance_->relation_;
}
inline ::blox::connect::Relation* UpdatePredicate::mutable_relation() {
  set_has_relation();
  if (relation_ == NULL) relation_ = new ::blox::connect::Relation;
  // @@protoc_insertion_point(field_mutable:blox.connect.UpdatePredicate.relation)
  return relation_;
}
inline ::blox::connect::Relation* UpdatePredicate::release_relation() {
  clear_has_relation();
  ::blox::connect::Relation* temp = relation_;
  relation_ = NULL;
  return temp;
}
inline void UpdatePredicate::set_allocated_relation(::blox::connect::Relation* relation) {
  delete relation_;
  relation_ = relation;
  if (relation) {
    set_has_relation();
  } else {
    clear_has_relation();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.UpdatePredicate.relation)
}

// required .blox.connect.DeltaModifier delta = 3;
inline bool UpdatePredicate::has_delta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdatePredicate::set_has_delta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdatePredicate::clear_has_delta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdatePredicate::clear_delta() {
  delta_ = 1;
  clear_has_delta();
}
inline ::blox::connect::DeltaModifier UpdatePredicate::delta() const {
  // @@protoc_insertion_point(field_get:blox.connect.UpdatePredicate.delta)
  return static_cast< ::blox::connect::DeltaModifier >(delta_);
}
inline void UpdatePredicate::set_delta(::blox::connect::DeltaModifier value) {
  assert(::blox::connect::DeltaModifier_IsValid(value));
  set_has_delta();
  delta_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.UpdatePredicate.delta)
}

// optional .blox.connect.EntityMode entity_mode = 4;
inline bool UpdatePredicate::has_entity_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdatePredicate::set_has_entity_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdatePredicate::clear_has_entity_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdatePredicate::clear_entity_mode() {
  entity_mode_ = 1;
  clear_has_entity_mode();
}
inline ::blox::connect::EntityMode UpdatePredicate::entity_mode() const {
  // @@protoc_insertion_point(field_get:blox.connect.UpdatePredicate.entity_mode)
  return static_cast< ::blox::connect::EntityMode >(entity_mode_);
}
inline void UpdatePredicate::set_entity_mode(::blox::connect::EntityMode value) {
  assert(::blox::connect::EntityMode_IsValid(value));
  set_has_entity_mode();
  entity_mode_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.UpdatePredicate.entity_mode)
}

// -------------------------------------------------------------------

// UpdatePredicateResponse

// -------------------------------------------------------------------

// GetPredicateInfo

// required .blox.connect.PredicateName predicate = 1;
inline bool GetPredicateInfo::has_predicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPredicateInfo::set_has_predicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPredicateInfo::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPredicateInfo::clear_predicate() {
  if (predicate_ != NULL) predicate_->::blox::connect::PredicateName::Clear();
  clear_has_predicate();
}
inline const ::blox::connect::PredicateName& GetPredicateInfo::predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicateInfo.predicate)
  return predicate_ != NULL ? *predicate_ : *default_instance_->predicate_;
}
inline ::blox::connect::PredicateName* GetPredicateInfo::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == NULL) predicate_ = new ::blox::connect::PredicateName;
  // @@protoc_insertion_point(field_mutable:blox.connect.GetPredicateInfo.predicate)
  return predicate_;
}
inline ::blox::connect::PredicateName* GetPredicateInfo::release_predicate() {
  clear_has_predicate();
  ::blox::connect::PredicateName* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline void GetPredicateInfo::set_allocated_predicate(::blox::connect::PredicateName* predicate) {
  delete predicate_;
  predicate_ = predicate;
  if (predicate) {
    set_has_predicate();
  } else {
    clear_has_predicate();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetPredicateInfo.predicate)
}

// -------------------------------------------------------------------

// GetPredicateInfoResponse

// required .blox.common.protocol.PredicateInfo info = 1;
inline bool GetPredicateInfoResponse::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPredicateInfoResponse::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPredicateInfoResponse::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPredicateInfoResponse::clear_info() {
  if (info_ != NULL) info_->::blox::common::protocol::PredicateInfo::Clear();
  clear_has_info();
}
inline const ::blox::common::protocol::PredicateInfo& GetPredicateInfoResponse::info() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicateInfoResponse.info)
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::blox::common::protocol::PredicateInfo* GetPredicateInfoResponse::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::blox::common::protocol::PredicateInfo;
  // @@protoc_insertion_point(field_mutable:blox.connect.GetPredicateInfoResponse.info)
  return info_;
}
inline ::blox::common::protocol::PredicateInfo* GetPredicateInfoResponse::release_info() {
  clear_has_info();
  ::blox::common::protocol::PredicateInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void GetPredicateInfoResponse::set_allocated_info(::blox::common::protocol::PredicateInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetPredicateInfoResponse.info)
}

// -------------------------------------------------------------------

// GetPredicateInfoBulk

// repeated .blox.connect.PredicateName predicate = 1;
inline int GetPredicateInfoBulk::predicate_size() const {
  return predicate_.size();
}
inline void GetPredicateInfoBulk::clear_predicate() {
  predicate_.Clear();
}
inline const ::blox::connect::PredicateName& GetPredicateInfoBulk::predicate(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicateInfoBulk.predicate)
  return predicate_.Get(index);
}
inline ::blox::connect::PredicateName* GetPredicateInfoBulk::mutable_predicate(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetPredicateInfoBulk.predicate)
  return predicate_.Mutable(index);
}
inline ::blox::connect::PredicateName* GetPredicateInfoBulk::add_predicate() {
  // @@protoc_insertion_point(field_add:blox.connect.GetPredicateInfoBulk.predicate)
  return predicate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >&
GetPredicateInfoBulk::predicate() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetPredicateInfoBulk.predicate)
  return predicate_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >*
GetPredicateInfoBulk::mutable_predicate() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetPredicateInfoBulk.predicate)
  return &predicate_;
}

// repeated .blox.connect.PredicateName omit = 2;
inline int GetPredicateInfoBulk::omit_size() const {
  return omit_.size();
}
inline void GetPredicateInfoBulk::clear_omit() {
  omit_.Clear();
}
inline const ::blox::connect::PredicateName& GetPredicateInfoBulk::omit(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicateInfoBulk.omit)
  return omit_.Get(index);
}
inline ::blox::connect::PredicateName* GetPredicateInfoBulk::mutable_omit(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetPredicateInfoBulk.omit)
  return omit_.Mutable(index);
}
inline ::blox::connect::PredicateName* GetPredicateInfoBulk::add_omit() {
  // @@protoc_insertion_point(field_add:blox.connect.GetPredicateInfoBulk.omit)
  return omit_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >&
GetPredicateInfoBulk::omit() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetPredicateInfoBulk.omit)
  return omit_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >*
GetPredicateInfoBulk::mutable_omit() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetPredicateInfoBulk.omit)
  return &omit_;
}

// -------------------------------------------------------------------

// GetPredicateInfoBulkResponse

// repeated .blox.common.protocol.PredicateInfo info = 1;
inline int GetPredicateInfoBulkResponse::info_size() const {
  return info_.size();
}
inline void GetPredicateInfoBulkResponse::clear_info() {
  info_.Clear();
}
inline const ::blox::common::protocol::PredicateInfo& GetPredicateInfoBulkResponse::info(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicateInfoBulkResponse.info)
  return info_.Get(index);
}
inline ::blox::common::protocol::PredicateInfo* GetPredicateInfoBulkResponse::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetPredicateInfoBulkResponse.info)
  return info_.Mutable(index);
}
inline ::blox::common::protocol::PredicateInfo* GetPredicateInfoBulkResponse::add_info() {
  // @@protoc_insertion_point(field_add:blox.connect.GetPredicateInfoBulkResponse.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicateInfo >&
GetPredicateInfoBulkResponse::info() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetPredicateInfoBulkResponse.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicateInfo >*
GetPredicateInfoBulkResponse::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetPredicateInfoBulkResponse.info)
  return &info_;
}

// -------------------------------------------------------------------

// GetPredicatePopcount

// required bool all = 1 [default = true];
inline bool GetPredicatePopcount::has_all() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPredicatePopcount::set_has_all() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPredicatePopcount::clear_has_all() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPredicatePopcount::clear_all() {
  all_ = true;
  clear_has_all();
}
inline bool GetPredicatePopcount::all() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicatePopcount.all)
  return all_;
}
inline void GetPredicatePopcount::set_all(bool value) {
  set_has_all();
  all_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetPredicatePopcount.all)
}

// repeated .blox.connect.PredicateName predicate = 2;
inline int GetPredicatePopcount::predicate_size() const {
  return predicate_.size();
}
inline void GetPredicatePopcount::clear_predicate() {
  predicate_.Clear();
}
inline const ::blox::connect::PredicateName& GetPredicatePopcount::predicate(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicatePopcount.predicate)
  return predicate_.Get(index);
}
inline ::blox::connect::PredicateName* GetPredicatePopcount::mutable_predicate(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetPredicatePopcount.predicate)
  return predicate_.Mutable(index);
}
inline ::blox::connect::PredicateName* GetPredicatePopcount::add_predicate() {
  // @@protoc_insertion_point(field_add:blox.connect.GetPredicatePopcount.predicate)
  return predicate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >&
GetPredicatePopcount::predicate() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetPredicatePopcount.predicate)
  return predicate_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::PredicateName >*
GetPredicatePopcount::mutable_predicate() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetPredicatePopcount.predicate)
  return &predicate_;
}

// optional string include_regexp = 3;
inline bool GetPredicatePopcount::has_include_regexp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPredicatePopcount::set_has_include_regexp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPredicatePopcount::clear_has_include_regexp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPredicatePopcount::clear_include_regexp() {
  if (include_regexp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_->clear();
  }
  clear_has_include_regexp();
}
inline const ::std::string& GetPredicatePopcount::include_regexp() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicatePopcount.include_regexp)
  return *include_regexp_;
}
inline void GetPredicatePopcount::set_include_regexp(const ::std::string& value) {
  set_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_ = new ::std::string;
  }
  include_regexp_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetPredicatePopcount.include_regexp)
}
inline void GetPredicatePopcount::set_include_regexp(const char* value) {
  set_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_ = new ::std::string;
  }
  include_regexp_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetPredicatePopcount.include_regexp)
}
inline void GetPredicatePopcount::set_include_regexp(const char* value, size_t size) {
  set_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_ = new ::std::string;
  }
  include_regexp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetPredicatePopcount.include_regexp)
}
inline ::std::string* GetPredicatePopcount::mutable_include_regexp() {
  set_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetPredicatePopcount.include_regexp)
  return include_regexp_;
}
inline ::std::string* GetPredicatePopcount::release_include_regexp() {
  clear_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = include_regexp_;
    include_regexp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetPredicatePopcount::set_allocated_include_regexp(::std::string* include_regexp) {
  if (include_regexp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete include_regexp_;
  }
  if (include_regexp) {
    set_has_include_regexp();
    include_regexp_ = include_regexp;
  } else {
    clear_has_include_regexp();
    include_regexp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetPredicatePopcount.include_regexp)
}

// optional string exclude_regexp = 4;
inline bool GetPredicatePopcount::has_exclude_regexp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetPredicatePopcount::set_has_exclude_regexp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetPredicatePopcount::clear_has_exclude_regexp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetPredicatePopcount::clear_exclude_regexp() {
  if (exclude_regexp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_->clear();
  }
  clear_has_exclude_regexp();
}
inline const ::std::string& GetPredicatePopcount::exclude_regexp() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicatePopcount.exclude_regexp)
  return *exclude_regexp_;
}
inline void GetPredicatePopcount::set_exclude_regexp(const ::std::string& value) {
  set_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_ = new ::std::string;
  }
  exclude_regexp_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetPredicatePopcount.exclude_regexp)
}
inline void GetPredicatePopcount::set_exclude_regexp(const char* value) {
  set_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_ = new ::std::string;
  }
  exclude_regexp_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetPredicatePopcount.exclude_regexp)
}
inline void GetPredicatePopcount::set_exclude_regexp(const char* value, size_t size) {
  set_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_ = new ::std::string;
  }
  exclude_regexp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetPredicatePopcount.exclude_regexp)
}
inline ::std::string* GetPredicatePopcount::mutable_exclude_regexp() {
  set_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetPredicatePopcount.exclude_regexp)
  return exclude_regexp_;
}
inline ::std::string* GetPredicatePopcount::release_exclude_regexp() {
  clear_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exclude_regexp_;
    exclude_regexp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetPredicatePopcount::set_allocated_exclude_regexp(::std::string* exclude_regexp) {
  if (exclude_regexp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exclude_regexp_;
  }
  if (exclude_regexp) {
    set_has_exclude_regexp();
    exclude_regexp_ = exclude_regexp;
  } else {
    clear_has_exclude_regexp();
    exclude_regexp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetPredicatePopcount.exclude_regexp)
}

// optional bool only_predicate_names = 5 [default = false];
inline bool GetPredicatePopcount::has_only_predicate_names() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetPredicatePopcount::set_has_only_predicate_names() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetPredicatePopcount::clear_has_only_predicate_names() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetPredicatePopcount::clear_only_predicate_names() {
  only_predicate_names_ = false;
  clear_has_only_predicate_names();
}
inline bool GetPredicatePopcount::only_predicate_names() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicatePopcount.only_predicate_names)
  return only_predicate_names_;
}
inline void GetPredicatePopcount::set_only_predicate_names(bool value) {
  set_has_only_predicate_names();
  only_predicate_names_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetPredicatePopcount.only_predicate_names)
}

// optional bool estimated = 6 [default = false];
inline bool GetPredicatePopcount::has_estimated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetPredicatePopcount::set_has_estimated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetPredicatePopcount::clear_has_estimated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetPredicatePopcount::clear_estimated() {
  estimated_ = false;
  clear_has_estimated();
}
inline bool GetPredicatePopcount::estimated() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicatePopcount.estimated)
  return estimated_;
}
inline void GetPredicatePopcount::set_estimated(bool value) {
  set_has_estimated();
  estimated_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetPredicatePopcount.estimated)
}

// optional bool include_default = 7 [default = false];
inline bool GetPredicatePopcount::has_include_default() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetPredicatePopcount::set_has_include_default() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetPredicatePopcount::clear_has_include_default() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetPredicatePopcount::clear_include_default() {
  include_default_ = false;
  clear_has_include_default();
}
inline bool GetPredicatePopcount::include_default() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicatePopcount.include_default)
  return include_default_;
}
inline void GetPredicatePopcount::set_include_default(bool value) {
  set_has_include_default();
  include_default_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetPredicatePopcount.include_default)
}

// -------------------------------------------------------------------

// GetPredicatePopcountResponse

// repeated .blox.common.protocol.PredicatePopcount popcount = 1;
inline int GetPredicatePopcountResponse::popcount_size() const {
  return popcount_.size();
}
inline void GetPredicatePopcountResponse::clear_popcount() {
  popcount_.Clear();
}
inline const ::blox::common::protocol::PredicatePopcount& GetPredicatePopcountResponse::popcount(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetPredicatePopcountResponse.popcount)
  return popcount_.Get(index);
}
inline ::blox::common::protocol::PredicatePopcount* GetPredicatePopcountResponse::mutable_popcount(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetPredicatePopcountResponse.popcount)
  return popcount_.Mutable(index);
}
inline ::blox::common::protocol::PredicatePopcount* GetPredicatePopcountResponse::add_popcount() {
  // @@protoc_insertion_point(field_add:blox.connect.GetPredicatePopcountResponse.popcount)
  return popcount_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicatePopcount >&
GetPredicatePopcountResponse::popcount() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetPredicatePopcountResponse.popcount)
  return popcount_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::PredicatePopcount >*
GetPredicatePopcountResponse::mutable_popcount() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetPredicatePopcountResponse.popcount)
  return &popcount_;
}

// -------------------------------------------------------------------

// GetProtocolDescriptors

// required bool all = 1;
inline bool GetProtocolDescriptors::has_all() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetProtocolDescriptors::set_has_all() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetProtocolDescriptors::clear_has_all() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetProtocolDescriptors::clear_all() {
  all_ = false;
  clear_has_all();
}
inline bool GetProtocolDescriptors::all() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetProtocolDescriptors.all)
  return all_;
}
inline void GetProtocolDescriptors::set_all(bool value) {
  set_has_all();
  all_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.GetProtocolDescriptors.all)
}

// repeated string protocol_name = 2;
inline int GetProtocolDescriptors::protocol_name_size() const {
  return protocol_name_.size();
}
inline void GetProtocolDescriptors::clear_protocol_name() {
  protocol_name_.Clear();
}
inline const ::std::string& GetProtocolDescriptors::protocol_name(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetProtocolDescriptors.protocol_name)
  return protocol_name_.Get(index);
}
inline ::std::string* GetProtocolDescriptors::mutable_protocol_name(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetProtocolDescriptors.protocol_name)
  return protocol_name_.Mutable(index);
}
inline void GetProtocolDescriptors::set_protocol_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.GetProtocolDescriptors.protocol_name)
  protocol_name_.Mutable(index)->assign(value);
}
inline void GetProtocolDescriptors::set_protocol_name(int index, const char* value) {
  protocol_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetProtocolDescriptors.protocol_name)
}
inline void GetProtocolDescriptors::set_protocol_name(int index, const char* value, size_t size) {
  protocol_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetProtocolDescriptors.protocol_name)
}
inline ::std::string* GetProtocolDescriptors::add_protocol_name() {
  return protocol_name_.Add();
}
inline void GetProtocolDescriptors::add_protocol_name(const ::std::string& value) {
  protocol_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.GetProtocolDescriptors.protocol_name)
}
inline void GetProtocolDescriptors::add_protocol_name(const char* value) {
  protocol_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.GetProtocolDescriptors.protocol_name)
}
inline void GetProtocolDescriptors::add_protocol_name(const char* value, size_t size) {
  protocol_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.GetProtocolDescriptors.protocol_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetProtocolDescriptors::protocol_name() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetProtocolDescriptors.protocol_name)
  return protocol_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetProtocolDescriptors::mutable_protocol_name() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetProtocolDescriptors.protocol_name)
  return &protocol_name_;
}

// optional string include_regexp = 3;
inline bool GetProtocolDescriptors::has_include_regexp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetProtocolDescriptors::set_has_include_regexp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetProtocolDescriptors::clear_has_include_regexp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetProtocolDescriptors::clear_include_regexp() {
  if (include_regexp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_->clear();
  }
  clear_has_include_regexp();
}
inline const ::std::string& GetProtocolDescriptors::include_regexp() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetProtocolDescriptors.include_regexp)
  return *include_regexp_;
}
inline void GetProtocolDescriptors::set_include_regexp(const ::std::string& value) {
  set_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_ = new ::std::string;
  }
  include_regexp_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetProtocolDescriptors.include_regexp)
}
inline void GetProtocolDescriptors::set_include_regexp(const char* value) {
  set_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_ = new ::std::string;
  }
  include_regexp_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetProtocolDescriptors.include_regexp)
}
inline void GetProtocolDescriptors::set_include_regexp(const char* value, size_t size) {
  set_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_ = new ::std::string;
  }
  include_regexp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetProtocolDescriptors.include_regexp)
}
inline ::std::string* GetProtocolDescriptors::mutable_include_regexp() {
  set_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    include_regexp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetProtocolDescriptors.include_regexp)
  return include_regexp_;
}
inline ::std::string* GetProtocolDescriptors::release_include_regexp() {
  clear_has_include_regexp();
  if (include_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = include_regexp_;
    include_regexp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetProtocolDescriptors::set_allocated_include_regexp(::std::string* include_regexp) {
  if (include_regexp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete include_regexp_;
  }
  if (include_regexp) {
    set_has_include_regexp();
    include_regexp_ = include_regexp;
  } else {
    clear_has_include_regexp();
    include_regexp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetProtocolDescriptors.include_regexp)
}

// optional string exclude_regexp = 4;
inline bool GetProtocolDescriptors::has_exclude_regexp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetProtocolDescriptors::set_has_exclude_regexp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetProtocolDescriptors::clear_has_exclude_regexp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetProtocolDescriptors::clear_exclude_regexp() {
  if (exclude_regexp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_->clear();
  }
  clear_has_exclude_regexp();
}
inline const ::std::string& GetProtocolDescriptors::exclude_regexp() const {
  // @@protoc_insertion_point(field_get:blox.connect.GetProtocolDescriptors.exclude_regexp)
  return *exclude_regexp_;
}
inline void GetProtocolDescriptors::set_exclude_regexp(const ::std::string& value) {
  set_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_ = new ::std::string;
  }
  exclude_regexp_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GetProtocolDescriptors.exclude_regexp)
}
inline void GetProtocolDescriptors::set_exclude_regexp(const char* value) {
  set_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_ = new ::std::string;
  }
  exclude_regexp_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GetProtocolDescriptors.exclude_regexp)
}
inline void GetProtocolDescriptors::set_exclude_regexp(const char* value, size_t size) {
  set_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_ = new ::std::string;
  }
  exclude_regexp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GetProtocolDescriptors.exclude_regexp)
}
inline ::std::string* GetProtocolDescriptors::mutable_exclude_regexp() {
  set_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exclude_regexp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GetProtocolDescriptors.exclude_regexp)
  return exclude_regexp_;
}
inline ::std::string* GetProtocolDescriptors::release_exclude_regexp() {
  clear_has_exclude_regexp();
  if (exclude_regexp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exclude_regexp_;
    exclude_regexp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetProtocolDescriptors::set_allocated_exclude_regexp(::std::string* exclude_regexp) {
  if (exclude_regexp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exclude_regexp_;
  }
  if (exclude_regexp) {
    set_has_exclude_regexp();
    exclude_regexp_ = exclude_regexp;
  } else {
    clear_has_exclude_regexp();
    exclude_regexp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GetProtocolDescriptors.exclude_regexp)
}

// -------------------------------------------------------------------

// GetProtocolDescriptorsResponse

// repeated .blox.connect.ProtocolDescriptor protocols = 1;
inline int GetProtocolDescriptorsResponse::protocols_size() const {
  return protocols_.size();
}
inline void GetProtocolDescriptorsResponse::clear_protocols() {
  protocols_.Clear();
}
inline const ::blox::connect::ProtocolDescriptor& GetProtocolDescriptorsResponse::protocols(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.GetProtocolDescriptorsResponse.protocols)
  return protocols_.Get(index);
}
inline ::blox::connect::ProtocolDescriptor* GetProtocolDescriptorsResponse::mutable_protocols(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.GetProtocolDescriptorsResponse.protocols)
  return protocols_.Mutable(index);
}
inline ::blox::connect::ProtocolDescriptor* GetProtocolDescriptorsResponse::add_protocols() {
  // @@protoc_insertion_point(field_add:blox.connect.GetProtocolDescriptorsResponse.protocols)
  return protocols_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::ProtocolDescriptor >&
GetProtocolDescriptorsResponse::protocols() const {
  // @@protoc_insertion_point(field_list:blox.connect.GetProtocolDescriptorsResponse.protocols)
  return protocols_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::ProtocolDescriptor >*
GetProtocolDescriptorsResponse::mutable_protocols() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.GetProtocolDescriptorsResponse.protocols)
  return &protocols_;
}

// -------------------------------------------------------------------

// ProtocolDescriptor

// required string name = 1;
inline bool ProtocolDescriptor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolDescriptor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtocolDescriptor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtocolDescriptor::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProtocolDescriptor::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.ProtocolDescriptor.name)
  return *name_;
}
inline void ProtocolDescriptor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ProtocolDescriptor.name)
}
inline void ProtocolDescriptor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ProtocolDescriptor.name)
}
inline void ProtocolDescriptor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ProtocolDescriptor.name)
}
inline ::std::string* ProtocolDescriptor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ProtocolDescriptor.name)
  return name_;
}
inline ::std::string* ProtocolDescriptor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtocolDescriptor::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ProtocolDescriptor.name)
}

// required bytes descriptor_data = 2;
inline bool ProtocolDescriptor::has_descriptor_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtocolDescriptor::set_has_descriptor_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtocolDescriptor::clear_has_descriptor_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtocolDescriptor::clear_descriptor_data() {
  if (descriptor_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_data_->clear();
  }
  clear_has_descriptor_data();
}
inline const ::std::string& ProtocolDescriptor::descriptor_data() const {
  // @@protoc_insertion_point(field_get:blox.connect.ProtocolDescriptor.descriptor_data)
  return *descriptor_data_;
}
inline void ProtocolDescriptor::set_descriptor_data(const ::std::string& value) {
  set_has_descriptor_data();
  if (descriptor_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_data_ = new ::std::string;
  }
  descriptor_data_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ProtocolDescriptor.descriptor_data)
}
inline void ProtocolDescriptor::set_descriptor_data(const char* value) {
  set_has_descriptor_data();
  if (descriptor_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_data_ = new ::std::string;
  }
  descriptor_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ProtocolDescriptor.descriptor_data)
}
inline void ProtocolDescriptor::set_descriptor_data(const void* value, size_t size) {
  set_has_descriptor_data();
  if (descriptor_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_data_ = new ::std::string;
  }
  descriptor_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ProtocolDescriptor.descriptor_data)
}
inline ::std::string* ProtocolDescriptor::mutable_descriptor_data() {
  set_has_descriptor_data();
  if (descriptor_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ProtocolDescriptor.descriptor_data)
  return descriptor_data_;
}
inline ::std::string* ProtocolDescriptor::release_descriptor_data() {
  clear_has_descriptor_data();
  if (descriptor_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = descriptor_data_;
    descriptor_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtocolDescriptor::set_allocated_descriptor_data(::std::string* descriptor_data) {
  if (descriptor_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete descriptor_data_;
  }
  if (descriptor_data) {
    set_has_descriptor_data();
    descriptor_data_ = descriptor_data;
  } else {
    clear_has_descriptor_data();
    descriptor_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ProtocolDescriptor.descriptor_data)
}

// -------------------------------------------------------------------

// ImportProtoBuf

// required string protocol = 1;
inline bool ImportProtoBuf::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImportProtoBuf::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImportProtoBuf::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImportProtoBuf::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& ImportProtoBuf::protocol() const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportProtoBuf.protocol)
  return *protocol_;
}
inline void ImportProtoBuf::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ImportProtoBuf.protocol)
}
inline void ImportProtoBuf::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ImportProtoBuf.protocol)
}
inline void ImportProtoBuf::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ImportProtoBuf.protocol)
}
inline ::std::string* ImportProtoBuf::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportProtoBuf.protocol)
  return protocol_;
}
inline ::std::string* ImportProtoBuf::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImportProtoBuf::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ImportProtoBuf.protocol)
}

// required string type_name = 2;
inline bool ImportProtoBuf::has_type_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImportProtoBuf::set_has_type_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImportProtoBuf::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImportProtoBuf::clear_type_name() {
  if (type_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_->clear();
  }
  clear_has_type_name();
}
inline const ::std::string& ImportProtoBuf::type_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportProtoBuf.type_name)
  return *type_name_;
}
inline void ImportProtoBuf::set_type_name(const ::std::string& value) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ImportProtoBuf.type_name)
}
inline void ImportProtoBuf::set_type_name(const char* value) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ImportProtoBuf.type_name)
}
inline void ImportProtoBuf::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ImportProtoBuf.type_name)
}
inline ::std::string* ImportProtoBuf::mutable_type_name() {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportProtoBuf.type_name)
  return type_name_;
}
inline ::std::string* ImportProtoBuf::release_type_name() {
  clear_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_name_;
    type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImportProtoBuf::set_allocated_type_name(::std::string* type_name) {
  if (type_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_name_;
  }
  if (type_name) {
    set_has_type_name();
    type_name_ = type_name;
  } else {
    clear_has_type_name();
    type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ImportProtoBuf.type_name)
}

// required bytes message = 3;
inline bool ImportProtoBuf::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImportProtoBuf::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImportProtoBuf::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImportProtoBuf::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ImportProtoBuf::message() const {
  // @@protoc_insertion_point(field_get:blox.connect.ImportProtoBuf.message)
  return *message_;
}
inline void ImportProtoBuf::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ImportProtoBuf.message)
}
inline void ImportProtoBuf::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ImportProtoBuf.message)
}
inline void ImportProtoBuf::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ImportProtoBuf.message)
}
inline ::std::string* ImportProtoBuf::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ImportProtoBuf.message)
  return message_;
}
inline ::std::string* ImportProtoBuf::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImportProtoBuf::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ImportProtoBuf.message)
}

// -------------------------------------------------------------------

// ImportProtoBufResponse

// -------------------------------------------------------------------

// ExportProtoBuf

// required string protocol = 1;
inline bool ExportProtoBuf::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExportProtoBuf::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExportProtoBuf::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExportProtoBuf::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& ExportProtoBuf::protocol() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExportProtoBuf.protocol)
  return *protocol_;
}
inline void ExportProtoBuf::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExportProtoBuf.protocol)
}
inline void ExportProtoBuf::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExportProtoBuf.protocol)
}
inline void ExportProtoBuf::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExportProtoBuf.protocol)
}
inline ::std::string* ExportProtoBuf::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    protocol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExportProtoBuf.protocol)
  return protocol_;
}
inline ::std::string* ExportProtoBuf::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExportProtoBuf::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExportProtoBuf.protocol)
}

// required string type_name = 2;
inline bool ExportProtoBuf::has_type_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExportProtoBuf::set_has_type_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExportProtoBuf::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExportProtoBuf::clear_type_name() {
  if (type_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_->clear();
  }
  clear_has_type_name();
}
inline const ::std::string& ExportProtoBuf::type_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExportProtoBuf.type_name)
  return *type_name_;
}
inline void ExportProtoBuf::set_type_name(const ::std::string& value) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExportProtoBuf.type_name)
}
inline void ExportProtoBuf::set_type_name(const char* value) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExportProtoBuf.type_name)
}
inline void ExportProtoBuf::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExportProtoBuf.type_name)
}
inline ::std::string* ExportProtoBuf::mutable_type_name() {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExportProtoBuf.type_name)
  return type_name_;
}
inline ::std::string* ExportProtoBuf::release_type_name() {
  clear_has_type_name();
  if (type_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_name_;
    type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExportProtoBuf::set_allocated_type_name(::std::string* type_name) {
  if (type_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_name_;
  }
  if (type_name) {
    set_has_type_name();
    type_name_ = type_name;
  } else {
    clear_has_type_name();
    type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExportProtoBuf.type_name)
}

// -------------------------------------------------------------------

// ExportProtoBufResponse

// required bytes message = 1;
inline bool ExportProtoBufResponse::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExportProtoBufResponse::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExportProtoBufResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExportProtoBufResponse::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ExportProtoBufResponse::message() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExportProtoBufResponse.message)
  return *message_;
}
inline void ExportProtoBufResponse::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExportProtoBufResponse.message)
}
inline void ExportProtoBufResponse::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExportProtoBufResponse.message)
}
inline void ExportProtoBufResponse::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExportProtoBufResponse.message)
}
inline ::std::string* ExportProtoBufResponse::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExportProtoBufResponse.message)
  return message_;
}
inline ::std::string* ExportProtoBufResponse::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExportProtoBufResponse::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExportProtoBufResponse.message)
}

// -------------------------------------------------------------------

// LogMessage

// required string message = 1;
inline bool LogMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& LogMessage::message() const {
  // @@protoc_insertion_point(field_get:blox.connect.LogMessage.message)
  return *message_;
}
inline void LogMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.LogMessage.message)
}
inline void LogMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.LogMessage.message)
}
inline void LogMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.LogMessage.message)
}
inline ::std::string* LogMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.LogMessage.message)
  return message_;
}
inline ::std::string* LogMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.LogMessage.message)
}

// -------------------------------------------------------------------

// LogMessageResponse

// -------------------------------------------------------------------

// ProtoAddSpec

// required string name = 1;
inline bool ProtoAddSpec::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoAddSpec::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoAddSpec::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoAddSpec::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProtoAddSpec::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.ProtoAddSpec.name)
  return *name_;
}
inline void ProtoAddSpec::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ProtoAddSpec.name)
}
inline void ProtoAddSpec::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ProtoAddSpec.name)
}
inline void ProtoAddSpec::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ProtoAddSpec.name)
}
inline ::std::string* ProtoAddSpec::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ProtoAddSpec.name)
  return name_;
}
inline ::std::string* ProtoAddSpec::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoAddSpec::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ProtoAddSpec.name)
}

// required bytes descriptor_msg = 2;
inline bool ProtoAddSpec::has_descriptor_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoAddSpec::set_has_descriptor_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoAddSpec::clear_has_descriptor_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoAddSpec::clear_descriptor_msg() {
  if (descriptor_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_msg_->clear();
  }
  clear_has_descriptor_msg();
}
inline const ::std::string& ProtoAddSpec::descriptor_msg() const {
  // @@protoc_insertion_point(field_get:blox.connect.ProtoAddSpec.descriptor_msg)
  return *descriptor_msg_;
}
inline void ProtoAddSpec::set_descriptor_msg(const ::std::string& value) {
  set_has_descriptor_msg();
  if (descriptor_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_msg_ = new ::std::string;
  }
  descriptor_msg_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ProtoAddSpec.descriptor_msg)
}
inline void ProtoAddSpec::set_descriptor_msg(const char* value) {
  set_has_descriptor_msg();
  if (descriptor_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_msg_ = new ::std::string;
  }
  descriptor_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ProtoAddSpec.descriptor_msg)
}
inline void ProtoAddSpec::set_descriptor_msg(const void* value, size_t size) {
  set_has_descriptor_msg();
  if (descriptor_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_msg_ = new ::std::string;
  }
  descriptor_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ProtoAddSpec.descriptor_msg)
}
inline ::std::string* ProtoAddSpec::mutable_descriptor_msg() {
  set_has_descriptor_msg();
  if (descriptor_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    descriptor_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ProtoAddSpec.descriptor_msg)
  return descriptor_msg_;
}
inline ::std::string* ProtoAddSpec::release_descriptor_msg() {
  clear_has_descriptor_msg();
  if (descriptor_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = descriptor_msg_;
    descriptor_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoAddSpec::set_allocated_descriptor_msg(::std::string* descriptor_msg) {
  if (descriptor_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete descriptor_msg_;
  }
  if (descriptor_msg) {
    set_has_descriptor_msg();
    descriptor_msg_ = descriptor_msg;
  } else {
    clear_has_descriptor_msg();
    descriptor_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ProtoAddSpec.descriptor_msg)
}

// -------------------------------------------------------------------

// ProtoAddSpecResponse

// -------------------------------------------------------------------

// BindBranchAlias

// required string alias = 1;
inline bool BindBranchAlias::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindBranchAlias::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindBranchAlias::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindBranchAlias::clear_alias() {
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_->clear();
  }
  clear_has_alias();
}
inline const ::std::string& BindBranchAlias::alias() const {
  // @@protoc_insertion_point(field_get:blox.connect.BindBranchAlias.alias)
  return *alias_;
}
inline void BindBranchAlias::set_alias(const ::std::string& value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.BindBranchAlias.alias)
}
inline void BindBranchAlias::set_alias(const char* value) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  alias_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.BindBranchAlias.alias)
}
inline void BindBranchAlias::set_alias(const char* value, size_t size) {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  alias_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.BindBranchAlias.alias)
}
inline ::std::string* BindBranchAlias::mutable_alias() {
  set_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alias_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.BindBranchAlias.alias)
  return alias_;
}
inline ::std::string* BindBranchAlias::release_alias() {
  clear_has_alias();
  if (alias_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = alias_;
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BindBranchAlias::set_allocated_alias(::std::string* alias) {
  if (alias_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alias_;
  }
  if (alias) {
    set_has_alias();
    alias_ = alias;
  } else {
    clear_has_alias();
    alias_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.BindBranchAlias.alias)
}

// required string branch_name = 2;
inline bool BindBranchAlias::has_branch_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindBranchAlias::set_has_branch_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindBranchAlias::clear_has_branch_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindBranchAlias::clear_branch_name() {
  if (branch_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_name_->clear();
  }
  clear_has_branch_name();
}
inline const ::std::string& BindBranchAlias::branch_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.BindBranchAlias.branch_name)
  return *branch_name_;
}
inline void BindBranchAlias::set_branch_name(const ::std::string& value) {
  set_has_branch_name();
  if (branch_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_name_ = new ::std::string;
  }
  branch_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.BindBranchAlias.branch_name)
}
inline void BindBranchAlias::set_branch_name(const char* value) {
  set_has_branch_name();
  if (branch_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_name_ = new ::std::string;
  }
  branch_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.BindBranchAlias.branch_name)
}
inline void BindBranchAlias::set_branch_name(const char* value, size_t size) {
  set_has_branch_name();
  if (branch_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_name_ = new ::std::string;
  }
  branch_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.BindBranchAlias.branch_name)
}
inline ::std::string* BindBranchAlias::mutable_branch_name() {
  set_has_branch_name();
  if (branch_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    branch_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.BindBranchAlias.branch_name)
  return branch_name_;
}
inline ::std::string* BindBranchAlias::release_branch_name() {
  clear_has_branch_name();
  if (branch_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = branch_name_;
    branch_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BindBranchAlias::set_allocated_branch_name(::std::string* branch_name) {
  if (branch_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete branch_name_;
  }
  if (branch_name) {
    set_has_branch_name();
    branch_name_ = branch_name;
  } else {
    clear_has_branch_name();
    branch_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.BindBranchAlias.branch_name)
}

// -------------------------------------------------------------------

// BindBranchAliasResponse

// -------------------------------------------------------------------

// GenerateFullUpdateDeltas

// required .blox.connect.PredicateName predicate = 1;
inline bool GenerateFullUpdateDeltas::has_predicate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenerateFullUpdateDeltas::set_has_predicate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenerateFullUpdateDeltas::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenerateFullUpdateDeltas::clear_predicate() {
  if (predicate_ != NULL) predicate_->::blox::connect::PredicateName::Clear();
  clear_has_predicate();
}
inline const ::blox::connect::PredicateName& GenerateFullUpdateDeltas::predicate() const {
  // @@protoc_insertion_point(field_get:blox.connect.GenerateFullUpdateDeltas.predicate)
  return predicate_ != NULL ? *predicate_ : *default_instance_->predicate_;
}
inline ::blox::connect::PredicateName* GenerateFullUpdateDeltas::mutable_predicate() {
  set_has_predicate();
  if (predicate_ == NULL) predicate_ = new ::blox::connect::PredicateName;
  // @@protoc_insertion_point(field_mutable:blox.connect.GenerateFullUpdateDeltas.predicate)
  return predicate_;
}
inline ::blox::connect::PredicateName* GenerateFullUpdateDeltas::release_predicate() {
  clear_has_predicate();
  ::blox::connect::PredicateName* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline void GenerateFullUpdateDeltas::set_allocated_predicate(::blox::connect::PredicateName* predicate) {
  delete predicate_;
  predicate_ = predicate;
  if (predicate) {
    set_has_predicate();
  } else {
    clear_has_predicate();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GenerateFullUpdateDeltas.predicate)
}

// -------------------------------------------------------------------

// GenerateFullUpdateDeltasResponse

// -------------------------------------------------------------------

// ExecuteImportScript

// required string script_path = 1;
inline bool ExecuteImportScript::has_script_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteImportScript::set_has_script_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteImportScript::clear_has_script_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteImportScript::clear_script_path() {
  if (script_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_path_->clear();
  }
  clear_has_script_path();
}
inline const ::std::string& ExecuteImportScript::script_path() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecuteImportScript.script_path)
  return *script_path_;
}
inline void ExecuteImportScript::set_script_path(const ::std::string& value) {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_path_ = new ::std::string;
  }
  script_path_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.ExecuteImportScript.script_path)
}
inline void ExecuteImportScript::set_script_path(const char* value) {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_path_ = new ::std::string;
  }
  script_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.ExecuteImportScript.script_path)
}
inline void ExecuteImportScript::set_script_path(const char* value, size_t size) {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_path_ = new ::std::string;
  }
  script_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.ExecuteImportScript.script_path)
}
inline ::std::string* ExecuteImportScript::mutable_script_path() {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.ExecuteImportScript.script_path)
  return script_path_;
}
inline ::std::string* ExecuteImportScript::release_script_path() {
  clear_has_script_path();
  if (script_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = script_path_;
    script_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecuteImportScript::set_allocated_script_path(::std::string* script_path) {
  if (script_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_path_;
  }
  if (script_path) {
    set_has_script_path();
    script_path_ = script_path;
  } else {
    clear_has_script_path();
    script_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.ExecuteImportScript.script_path)
}

// optional bool incremental = 2;
inline bool ExecuteImportScript::has_incremental() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecuteImportScript::set_has_incremental() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecuteImportScript::clear_has_incremental() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecuteImportScript::clear_incremental() {
  incremental_ = false;
  clear_has_incremental();
}
inline bool ExecuteImportScript::incremental() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecuteImportScript.incremental)
  return incremental_;
}
inline void ExecuteImportScript::set_incremental(bool value) {
  set_has_incremental();
  incremental_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.ExecuteImportScript.incremental)
}

// -------------------------------------------------------------------

// ExecuteImportScriptResponse

// required bool success = 1;
inline bool ExecuteImportScriptResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteImportScriptResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteImportScriptResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteImportScriptResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ExecuteImportScriptResponse::success() const {
  // @@protoc_insertion_point(field_get:blox.connect.ExecuteImportScriptResponse.success)
  return success_;
}
inline void ExecuteImportScriptResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.ExecuteImportScriptResponse.success)
}

// -------------------------------------------------------------------

// FaultInjection

// required .blox.connect.FaultKind kind = 1;
inline bool FaultInjection::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaultInjection::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaultInjection::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaultInjection::clear_kind() {
  kind_ = 1;
  clear_has_kind();
}
inline ::blox::connect::FaultKind FaultInjection::kind() const {
  // @@protoc_insertion_point(field_get:blox.connect.FaultInjection.kind)
  return static_cast< ::blox::connect::FaultKind >(kind_);
}
inline void FaultInjection::set_kind(::blox::connect::FaultKind value) {
  assert(::blox::connect::FaultKind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.FaultInjection.kind)
}

// optional uint32 seconds = 2;
inline bool FaultInjection::has_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaultInjection::set_has_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaultInjection::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaultInjection::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 FaultInjection::seconds() const {
  // @@protoc_insertion_point(field_get:blox.connect.FaultInjection.seconds)
  return seconds_;
}
inline void FaultInjection::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:blox.connect.FaultInjection.seconds)
}

// -------------------------------------------------------------------

// InputBinding

// required string name = 1;
inline bool InputBinding::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputBinding::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputBinding::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputBinding::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InputBinding::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.InputBinding.name)
  return *name_;
}
inline void InputBinding::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.InputBinding.name)
}
inline void InputBinding::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.InputBinding.name)
}
inline void InputBinding::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.InputBinding.name)
}
inline ::std::string* InputBinding::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.InputBinding.name)
  return name_;
}
inline ::std::string* InputBinding::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InputBinding::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.InputBinding.name)
}

// required .blox.connect.Relation relation = 2;
inline bool InputBinding::has_relation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputBinding::set_has_relation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputBinding::clear_has_relation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputBinding::clear_relation() {
  if (relation_ != NULL) relation_->::blox::connect::Relation::Clear();
  clear_has_relation();
}
inline const ::blox::connect::Relation& InputBinding::relation() const {
  // @@protoc_insertion_point(field_get:blox.connect.InputBinding.relation)
  return relation_ != NULL ? *relation_ : *default_instance_->relation_;
}
inline ::blox::connect::Relation* InputBinding::mutable_relation() {
  set_has_relation();
  if (relation_ == NULL) relation_ = new ::blox::connect::Relation;
  // @@protoc_insertion_point(field_mutable:blox.connect.InputBinding.relation)
  return relation_;
}
inline ::blox::connect::Relation* InputBinding::release_relation() {
  clear_has_relation();
  ::blox::connect::Relation* temp = relation_;
  relation_ = NULL;
  return temp;
}
inline void InputBinding::set_allocated_relation(::blox::connect::Relation* relation) {
  delete relation_;
  relation_ = relation;
  if (relation) {
    set_has_relation();
  } else {
    clear_has_relation();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.InputBinding.relation)
}

// -------------------------------------------------------------------

// Relation

// optional string name = 1;
inline bool Relation::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Relation::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Relation::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Relation::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Relation::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.Relation.name)
  return *name_;
}
inline void Relation::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.Relation.name)
}
inline void Relation::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.Relation.name)
}
inline void Relation::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.Relation.name)
}
inline ::std::string* Relation::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.Relation.name)
  return name_;
}
inline ::std::string* Relation::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Relation::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Relation.name)
}

// repeated .blox.connect.Column column = 2;
inline int Relation::column_size() const {
  return column_.size();
}
inline void Relation::clear_column() {
  column_.Clear();
}
inline const ::blox::connect::Column& Relation::column(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Relation.column)
  return column_.Get(index);
}
inline ::blox::connect::Column* Relation::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.Relation.column)
  return column_.Mutable(index);
}
inline ::blox::connect::Column* Relation::add_column() {
  // @@protoc_insertion_point(field_add:blox.connect.Relation.column)
  return column_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::connect::Column >&
Relation::column() const {
  // @@protoc_insertion_point(field_list:blox.connect.Relation.column)
  return column_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::connect::Column >*
Relation::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Relation.column)
  return &column_;
}

// -------------------------------------------------------------------

// Column

// optional .blox.connect.EntityColumn entity_column = 1;
inline bool Column::has_entity_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Column::set_has_entity_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Column::clear_has_entity_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Column::clear_entity_column() {
  if (entity_column_ != NULL) entity_column_->::blox::connect::EntityColumn::Clear();
  clear_has_entity_column();
}
inline const ::blox::connect::EntityColumn& Column::entity_column() const {
  // @@protoc_insertion_point(field_get:blox.connect.Column.entity_column)
  return entity_column_ != NULL ? *entity_column_ : *default_instance_->entity_column_;
}
inline ::blox::connect::EntityColumn* Column::mutable_entity_column() {
  set_has_entity_column();
  if (entity_column_ == NULL) entity_column_ = new ::blox::connect::EntityColumn;
  // @@protoc_insertion_point(field_mutable:blox.connect.Column.entity_column)
  return entity_column_;
}
inline ::blox::connect::EntityColumn* Column::release_entity_column() {
  clear_has_entity_column();
  ::blox::connect::EntityColumn* temp = entity_column_;
  entity_column_ = NULL;
  return temp;
}
inline void Column::set_allocated_entity_column(::blox::connect::EntityColumn* entity_column) {
  delete entity_column_;
  entity_column_ = entity_column;
  if (entity_column) {
    set_has_entity_column();
  } else {
    clear_has_entity_column();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Column.entity_column)
}

// optional .blox.connect.BoolColumn bool_column = 2;
inline bool Column::has_bool_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Column::set_has_bool_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Column::clear_has_bool_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Column::clear_bool_column() {
  if (bool_column_ != NULL) bool_column_->::blox::connect::BoolColumn::Clear();
  clear_has_bool_column();
}
inline const ::blox::connect::BoolColumn& Column::bool_column() const {
  // @@protoc_insertion_point(field_get:blox.connect.Column.bool_column)
  return bool_column_ != NULL ? *bool_column_ : *default_instance_->bool_column_;
}
inline ::blox::connect::BoolColumn* Column::mutable_bool_column() {
  set_has_bool_column();
  if (bool_column_ == NULL) bool_column_ = new ::blox::connect::BoolColumn;
  // @@protoc_insertion_point(field_mutable:blox.connect.Column.bool_column)
  return bool_column_;
}
inline ::blox::connect::BoolColumn* Column::release_bool_column() {
  clear_has_bool_column();
  ::blox::connect::BoolColumn* temp = bool_column_;
  bool_column_ = NULL;
  return temp;
}
inline void Column::set_allocated_bool_column(::blox::connect::BoolColumn* bool_column) {
  delete bool_column_;
  bool_column_ = bool_column;
  if (bool_column) {
    set_has_bool_column();
  } else {
    clear_has_bool_column();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Column.bool_column)
}

// optional .blox.connect.Int64Column int64_column = 4;
inline bool Column::has_int64_column() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Column::set_has_int64_column() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Column::clear_has_int64_column() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Column::clear_int64_column() {
  if (int64_column_ != NULL) int64_column_->::blox::connect::Int64Column::Clear();
  clear_has_int64_column();
}
inline const ::blox::connect::Int64Column& Column::int64_column() const {
  // @@protoc_insertion_point(field_get:blox.connect.Column.int64_column)
  return int64_column_ != NULL ? *int64_column_ : *default_instance_->int64_column_;
}
inline ::blox::connect::Int64Column* Column::mutable_int64_column() {
  set_has_int64_column();
  if (int64_column_ == NULL) int64_column_ = new ::blox::connect::Int64Column;
  // @@protoc_insertion_point(field_mutable:blox.connect.Column.int64_column)
  return int64_column_;
}
inline ::blox::connect::Int64Column* Column::release_int64_column() {
  clear_has_int64_column();
  ::blox::connect::Int64Column* temp = int64_column_;
  int64_column_ = NULL;
  return temp;
}
inline void Column::set_allocated_int64_column(::blox::connect::Int64Column* int64_column) {
  delete int64_column_;
  int64_column_ = int64_column;
  if (int64_column) {
    set_has_int64_column();
  } else {
    clear_has_int64_column();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Column.int64_column)
}

// optional .blox.connect.UInt64Column uint64_column = 6;
inline bool Column::has_uint64_column() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Column::set_has_uint64_column() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Column::clear_has_uint64_column() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Column::clear_uint64_column() {
  if (uint64_column_ != NULL) uint64_column_->::blox::connect::UInt64Column::Clear();
  clear_has_uint64_column();
}
inline const ::blox::connect::UInt64Column& Column::uint64_column() const {
  // @@protoc_insertion_point(field_get:blox.connect.Column.uint64_column)
  return uint64_column_ != NULL ? *uint64_column_ : *default_instance_->uint64_column_;
}
inline ::blox::connect::UInt64Column* Column::mutable_uint64_column() {
  set_has_uint64_column();
  if (uint64_column_ == NULL) uint64_column_ = new ::blox::connect::UInt64Column;
  // @@protoc_insertion_point(field_mutable:blox.connect.Column.uint64_column)
  return uint64_column_;
}
inline ::blox::connect::UInt64Column* Column::release_uint64_column() {
  clear_has_uint64_column();
  ::blox::connect::UInt64Column* temp = uint64_column_;
  uint64_column_ = NULL;
  return temp;
}
inline void Column::set_allocated_uint64_column(::blox::connect::UInt64Column* uint64_column) {
  delete uint64_column_;
  uint64_column_ = uint64_column;
  if (uint64_column) {
    set_has_uint64_column();
  } else {
    clear_has_uint64_column();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Column.uint64_column)
}

// optional .blox.connect.Float64Column float64_column = 8;
inline bool Column::has_float64_column() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Column::set_has_float64_column() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Column::clear_has_float64_column() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Column::clear_float64_column() {
  if (float64_column_ != NULL) float64_column_->::blox::connect::Float64Column::Clear();
  clear_has_float64_column();
}
inline const ::blox::connect::Float64Column& Column::float64_column() const {
  // @@protoc_insertion_point(field_get:blox.connect.Column.float64_column)
  return float64_column_ != NULL ? *float64_column_ : *default_instance_->float64_column_;
}
inline ::blox::connect::Float64Column* Column::mutable_float64_column() {
  set_has_float64_column();
  if (float64_column_ == NULL) float64_column_ = new ::blox::connect::Float64Column;
  // @@protoc_insertion_point(field_mutable:blox.connect.Column.float64_column)
  return float64_column_;
}
inline ::blox::connect::Float64Column* Column::release_float64_column() {
  clear_has_float64_column();
  ::blox::connect::Float64Column* temp = float64_column_;
  float64_column_ = NULL;
  return temp;
}
inline void Column::set_allocated_float64_column(::blox::connect::Float64Column* float64_column) {
  delete float64_column_;
  float64_column_ = float64_column;
  if (float64_column) {
    set_has_float64_column();
  } else {
    clear_has_float64_column();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Column.float64_column)
}

// optional .blox.connect.StringColumn string_column = 9;
inline bool Column::has_string_column() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Column::set_has_string_column() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Column::clear_has_string_column() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Column::clear_string_column() {
  if (string_column_ != NULL) string_column_->::blox::connect::StringColumn::Clear();
  clear_has_string_column();
}
inline const ::blox::connect::StringColumn& Column::string_column() const {
  // @@protoc_insertion_point(field_get:blox.connect.Column.string_column)
  return string_column_ != NULL ? *string_column_ : *default_instance_->string_column_;
}
inline ::blox::connect::StringColumn* Column::mutable_string_column() {
  set_has_string_column();
  if (string_column_ == NULL) string_column_ = new ::blox::connect::StringColumn;
  // @@protoc_insertion_point(field_mutable:blox.connect.Column.string_column)
  return string_column_;
}
inline ::blox::connect::StringColumn* Column::release_string_column() {
  clear_has_string_column();
  ::blox::connect::StringColumn* temp = string_column_;
  string_column_ = NULL;
  return temp;
}
inline void Column::set_allocated_string_column(::blox::connect::StringColumn* string_column) {
  delete string_column_;
  string_column_ = string_column;
  if (string_column) {
    set_has_string_column();
  } else {
    clear_has_string_column();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Column.string_column)
}

// optional .blox.connect.DateTimeColumn datetime_column = 10;
inline bool Column::has_datetime_column() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Column::set_has_datetime_column() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Column::clear_has_datetime_column() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Column::clear_datetime_column() {
  if (datetime_column_ != NULL) datetime_column_->::blox::connect::DateTimeColumn::Clear();
  clear_has_datetime_column();
}
inline const ::blox::connect::DateTimeColumn& Column::datetime_column() const {
  // @@protoc_insertion_point(field_get:blox.connect.Column.datetime_column)
  return datetime_column_ != NULL ? *datetime_column_ : *default_instance_->datetime_column_;
}
inline ::blox::connect::DateTimeColumn* Column::mutable_datetime_column() {
  set_has_datetime_column();
  if (datetime_column_ == NULL) datetime_column_ = new ::blox::connect::DateTimeColumn;
  // @@protoc_insertion_point(field_mutable:blox.connect.Column.datetime_column)
  return datetime_column_;
}
inline ::blox::connect::DateTimeColumn* Column::release_datetime_column() {
  clear_has_datetime_column();
  ::blox::connect::DateTimeColumn* temp = datetime_column_;
  datetime_column_ = NULL;
  return temp;
}
inline void Column::set_allocated_datetime_column(::blox::connect::DateTimeColumn* datetime_column) {
  delete datetime_column_;
  datetime_column_ = datetime_column;
  if (datetime_column) {
    set_has_datetime_column();
  } else {
    clear_has_datetime_column();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Column.datetime_column)
}

// optional .blox.connect.Decimal128Column decimal128_column = 14;
inline bool Column::has_decimal128_column() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Column::set_has_decimal128_column() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Column::clear_has_decimal128_column() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Column::clear_decimal128_column() {
  if (decimal128_column_ != NULL) decimal128_column_->::blox::connect::Decimal128Column::Clear();
  clear_has_decimal128_column();
}
inline const ::blox::connect::Decimal128Column& Column::decimal128_column() const {
  // @@protoc_insertion_point(field_get:blox.connect.Column.decimal128_column)
  return decimal128_column_ != NULL ? *decimal128_column_ : *default_instance_->decimal128_column_;
}
inline ::blox::connect::Decimal128Column* Column::mutable_decimal128_column() {
  set_has_decimal128_column();
  if (decimal128_column_ == NULL) decimal128_column_ = new ::blox::connect::Decimal128Column;
  // @@protoc_insertion_point(field_mutable:blox.connect.Column.decimal128_column)
  return decimal128_column_;
}
inline ::blox::connect::Decimal128Column* Column::release_decimal128_column() {
  clear_has_decimal128_column();
  ::blox::connect::Decimal128Column* temp = decimal128_column_;
  decimal128_column_ = NULL;
  return temp;
}
inline void Column::set_allocated_decimal128_column(::blox::connect::Decimal128Column* decimal128_column) {
  delete decimal128_column_;
  decimal128_column_ = decimal128_column;
  if (decimal128_column) {
    set_has_decimal128_column();
  } else {
    clear_has_decimal128_column();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Column.decimal128_column)
}

// optional .blox.connect.Int128Column int128_column = 15;
inline bool Column::has_int128_column() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Column::set_has_int128_column() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Column::clear_has_int128_column() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Column::clear_int128_column() {
  if (int128_column_ != NULL) int128_column_->::blox::connect::Int128Column::Clear();
  clear_has_int128_column();
}
inline const ::blox::connect::Int128Column& Column::int128_column() const {
  // @@protoc_insertion_point(field_get:blox.connect.Column.int128_column)
  return int128_column_ != NULL ? *int128_column_ : *default_instance_->int128_column_;
}
inline ::blox::connect::Int128Column* Column::mutable_int128_column() {
  set_has_int128_column();
  if (int128_column_ == NULL) int128_column_ = new ::blox::connect::Int128Column;
  // @@protoc_insertion_point(field_mutable:blox.connect.Column.int128_column)
  return int128_column_;
}
inline ::blox::connect::Int128Column* Column::release_int128_column() {
  clear_has_int128_column();
  ::blox::connect::Int128Column* temp = int128_column_;
  int128_column_ = NULL;
  return temp;
}
inline void Column::set_allocated_int128_column(::blox::connect::Int128Column* int128_column) {
  delete int128_column_;
  int128_column_ = int128_column;
  if (int128_column) {
    set_has_int128_column();
  } else {
    clear_has_int128_column();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.Column.int128_column)
}

// -------------------------------------------------------------------

// BoolColumn

// repeated bool values = 1 [packed = true];
inline int BoolColumn::values_size() const {
  return values_.size();
}
inline void BoolColumn::clear_values() {
  values_.Clear();
}
inline bool BoolColumn::values(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.BoolColumn.values)
  return values_.Get(index);
}
inline void BoolColumn::set_values(int index, bool value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.BoolColumn.values)
}
inline void BoolColumn::add_values(bool value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.BoolColumn.values)
}
inline const ::google::protobuf::RepeatedField< bool >&
BoolColumn::values() const {
  // @@protoc_insertion_point(field_list:blox.connect.BoolColumn.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< bool >*
BoolColumn::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.BoolColumn.values)
  return &values_;
}

// -------------------------------------------------------------------

// Int64Column

// repeated int64 values = 1 [packed = true];
inline int Int64Column::values_size() const {
  return values_.size();
}
inline void Int64Column::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int64 Int64Column::values(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Int64Column.values)
  return values_.Get(index);
}
inline void Int64Column::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.Int64Column.values)
}
inline void Int64Column::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.Int64Column.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Column::values() const {
  // @@protoc_insertion_point(field_list:blox.connect.Int64Column.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Column::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Int64Column.values)
  return &values_;
}

// -------------------------------------------------------------------

// UInt64Column

// repeated uint64 values = 1 [packed = true];
inline int UInt64Column::values_size() const {
  return values_.size();
}
inline void UInt64Column::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint64 UInt64Column::values(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.UInt64Column.values)
  return values_.Get(index);
}
inline void UInt64Column::set_values(int index, ::google::protobuf::uint64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.UInt64Column.values)
}
inline void UInt64Column::add_values(::google::protobuf::uint64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.UInt64Column.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UInt64Column::values() const {
  // @@protoc_insertion_point(field_list:blox.connect.UInt64Column.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UInt64Column::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.UInt64Column.values)
  return &values_;
}

// -------------------------------------------------------------------

// Float64Column

// repeated double values = 1 [packed = true];
inline int Float64Column::values_size() const {
  return values_.size();
}
inline void Float64Column::clear_values() {
  values_.Clear();
}
inline double Float64Column::values(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Float64Column.values)
  return values_.Get(index);
}
inline void Float64Column::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.Float64Column.values)
}
inline void Float64Column::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.Float64Column.values)
}
inline const ::google::protobuf::RepeatedField< double >&
Float64Column::values() const {
  // @@protoc_insertion_point(field_list:blox.connect.Float64Column.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
Float64Column::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Float64Column.values)
  return &values_;
}

// -------------------------------------------------------------------

// DateTimeColumn

// repeated int64 values = 1 [packed = true];
inline int DateTimeColumn::values_size() const {
  return values_.size();
}
inline void DateTimeColumn::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int64 DateTimeColumn::values(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.DateTimeColumn.values)
  return values_.Get(index);
}
inline void DateTimeColumn::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.DateTimeColumn.values)
}
inline void DateTimeColumn::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.DateTimeColumn.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
DateTimeColumn::values() const {
  // @@protoc_insertion_point(field_list:blox.connect.DateTimeColumn.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
DateTimeColumn::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.DateTimeColumn.values)
  return &values_;
}

// -------------------------------------------------------------------

// StringColumn

// repeated string values = 1;
inline int StringColumn::values_size() const {
  return values_.size();
}
inline void StringColumn::clear_values() {
  values_.Clear();
}
inline const ::std::string& StringColumn::values(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.StringColumn.values)
  return values_.Get(index);
}
inline ::std::string* StringColumn::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:blox.connect.StringColumn.values)
  return values_.Mutable(index);
}
inline void StringColumn::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.connect.StringColumn.values)
  values_.Mutable(index)->assign(value);
}
inline void StringColumn::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.StringColumn.values)
}
inline void StringColumn::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.StringColumn.values)
}
inline ::std::string* StringColumn::add_values() {
  return values_.Add();
}
inline void StringColumn::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.connect.StringColumn.values)
}
inline void StringColumn::add_values(const char* value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.connect.StringColumn.values)
}
inline void StringColumn::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.connect.StringColumn.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringColumn::values() const {
  // @@protoc_insertion_point(field_list:blox.connect.StringColumn.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringColumn::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.StringColumn.values)
  return &values_;
}

// -------------------------------------------------------------------

// Decimal128Column

// repeated bool negative = 1 [packed = true];
inline int Decimal128Column::negative_size() const {
  return negative_.size();
}
inline void Decimal128Column::clear_negative() {
  negative_.Clear();
}
inline bool Decimal128Column::negative(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Decimal128Column.negative)
  return negative_.Get(index);
}
inline void Decimal128Column::set_negative(int index, bool value) {
  negative_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.Decimal128Column.negative)
}
inline void Decimal128Column::add_negative(bool value) {
  negative_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.Decimal128Column.negative)
}
inline const ::google::protobuf::RepeatedField< bool >&
Decimal128Column::negative() const {
  // @@protoc_insertion_point(field_list:blox.connect.Decimal128Column.negative)
  return negative_;
}
inline ::google::protobuf::RepeatedField< bool >*
Decimal128Column::mutable_negative() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Decimal128Column.negative)
  return &negative_;
}

// repeated uint64 integral_digits = 2 [packed = true];
inline int Decimal128Column::integral_digits_size() const {
  return integral_digits_.size();
}
inline void Decimal128Column::clear_integral_digits() {
  integral_digits_.Clear();
}
inline ::google::protobuf::uint64 Decimal128Column::integral_digits(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Decimal128Column.integral_digits)
  return integral_digits_.Get(index);
}
inline void Decimal128Column::set_integral_digits(int index, ::google::protobuf::uint64 value) {
  integral_digits_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.Decimal128Column.integral_digits)
}
inline void Decimal128Column::add_integral_digits(::google::protobuf::uint64 value) {
  integral_digits_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.Decimal128Column.integral_digits)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Decimal128Column::integral_digits() const {
  // @@protoc_insertion_point(field_list:blox.connect.Decimal128Column.integral_digits)
  return integral_digits_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Decimal128Column::mutable_integral_digits() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Decimal128Column.integral_digits)
  return &integral_digits_;
}

// repeated uint64 fraction_digits = 3 [packed = true];
inline int Decimal128Column::fraction_digits_size() const {
  return fraction_digits_.size();
}
inline void Decimal128Column::clear_fraction_digits() {
  fraction_digits_.Clear();
}
inline ::google::protobuf::uint64 Decimal128Column::fraction_digits(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Decimal128Column.fraction_digits)
  return fraction_digits_.Get(index);
}
inline void Decimal128Column::set_fraction_digits(int index, ::google::protobuf::uint64 value) {
  fraction_digits_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.Decimal128Column.fraction_digits)
}
inline void Decimal128Column::add_fraction_digits(::google::protobuf::uint64 value) {
  fraction_digits_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.Decimal128Column.fraction_digits)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Decimal128Column::fraction_digits() const {
  // @@protoc_insertion_point(field_list:blox.connect.Decimal128Column.fraction_digits)
  return fraction_digits_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Decimal128Column::mutable_fraction_digits() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Decimal128Column.fraction_digits)
  return &fraction_digits_;
}

// -------------------------------------------------------------------

// Int128Column

// repeated uint64 high = 1 [packed = true];
inline int Int128Column::high_size() const {
  return high_.size();
}
inline void Int128Column::clear_high() {
  high_.Clear();
}
inline ::google::protobuf::uint64 Int128Column::high(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Int128Column.high)
  return high_.Get(index);
}
inline void Int128Column::set_high(int index, ::google::protobuf::uint64 value) {
  high_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.Int128Column.high)
}
inline void Int128Column::add_high(::google::protobuf::uint64 value) {
  high_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.Int128Column.high)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Int128Column::high() const {
  // @@protoc_insertion_point(field_list:blox.connect.Int128Column.high)
  return high_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Int128Column::mutable_high() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Int128Column.high)
  return &high_;
}

// repeated uint64 low = 2 [packed = true];
inline int Int128Column::low_size() const {
  return low_.size();
}
inline void Int128Column::clear_low() {
  low_.Clear();
}
inline ::google::protobuf::uint64 Int128Column::low(int index) const {
  // @@protoc_insertion_point(field_get:blox.connect.Int128Column.low)
  return low_.Get(index);
}
inline void Int128Column::set_low(int index, ::google::protobuf::uint64 value) {
  low_.Set(index, value);
  // @@protoc_insertion_point(field_set:blox.connect.Int128Column.low)
}
inline void Int128Column::add_low(::google::protobuf::uint64 value) {
  low_.Add(value);
  // @@protoc_insertion_point(field_add:blox.connect.Int128Column.low)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Int128Column::low() const {
  // @@protoc_insertion_point(field_list:blox.connect.Int128Column.low)
  return low_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Int128Column::mutable_low() {
  // @@protoc_insertion_point(field_mutable_list:blox.connect.Int128Column.low)
  return &low_;
}

// -------------------------------------------------------------------

// EntityColumn

// optional string name = 1;
inline bool EntityColumn::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityColumn::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityColumn::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityColumn::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EntityColumn::name() const {
  // @@protoc_insertion_point(field_get:blox.connect.EntityColumn.name)
  return *name_;
}
inline void EntityColumn::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.EntityColumn.name)
}
inline void EntityColumn::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.EntityColumn.name)
}
inline void EntityColumn::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.EntityColumn.name)
}
inline ::std::string* EntityColumn::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.EntityColumn.name)
  return name_;
}
inline ::std::string* EntityColumn::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EntityColumn::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.EntityColumn.name)
}

// optional .blox.connect.Column index_values = 2;
inline bool EntityColumn::has_index_values() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityColumn::set_has_index_values() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityColumn::clear_has_index_values() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityColumn::clear_index_values() {
  if (index_values_ != NULL) index_values_->::blox::connect::Column::Clear();
  clear_has_index_values();
}
inline const ::blox::connect::Column& EntityColumn::index_values() const {
  // @@protoc_insertion_point(field_get:blox.connect.EntityColumn.index_values)
  return index_values_ != NULL ? *index_values_ : *default_instance_->index_values_;
}
inline ::blox::connect::Column* EntityColumn::mutable_index_values() {
  set_has_index_values();
  if (index_values_ == NULL) index_values_ = new ::blox::connect::Column;
  // @@protoc_insertion_point(field_mutable:blox.connect.EntityColumn.index_values)
  return index_values_;
}
inline ::blox::connect::Column* EntityColumn::release_index_values() {
  clear_has_index_values();
  ::blox::connect::Column* temp = index_values_;
  index_values_ = NULL;
  return temp;
}
inline void EntityColumn::set_allocated_index_values(::blox::connect::Column* index_values) {
  delete index_values_;
  index_values_ = index_values;
  if (index_values) {
    set_has_index_values();
  } else {
    clear_has_index_values();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.EntityColumn.index_values)
}

// optional .blox.connect.Column refmode_values = 3;
inline bool EntityColumn::has_refmode_values() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntityColumn::set_has_refmode_values() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntityColumn::clear_has_refmode_values() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntityColumn::clear_refmode_values() {
  if (refmode_values_ != NULL) refmode_values_->::blox::connect::Column::Clear();
  clear_has_refmode_values();
}
inline const ::blox::connect::Column& EntityColumn::refmode_values() const {
  // @@protoc_insertion_point(field_get:blox.connect.EntityColumn.refmode_values)
  return refmode_values_ != NULL ? *refmode_values_ : *default_instance_->refmode_values_;
}
inline ::blox::connect::Column* EntityColumn::mutable_refmode_values() {
  set_has_refmode_values();
  if (refmode_values_ == NULL) refmode_values_ = new ::blox::connect::Column;
  // @@protoc_insertion_point(field_mutable:blox.connect.EntityColumn.refmode_values)
  return refmode_values_;
}
inline ::blox::connect::Column* EntityColumn::release_refmode_values() {
  clear_has_refmode_values();
  ::blox::connect::Column* temp = refmode_values_;
  refmode_values_ = NULL;
  return temp;
}
inline void EntityColumn::set_allocated_refmode_values(::blox::connect::Column* refmode_values) {
  delete refmode_values_;
  refmode_values_ = refmode_values;
  if (refmode_values) {
    set_has_refmode_values();
  } else {
    clear_has_refmode_values();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.EntityColumn.refmode_values)
}

// -------------------------------------------------------------------

// PredicateName

// optional .blox.connect.LocalPredicateName local_name = 1;
inline bool PredicateName::has_local_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredicateName::set_has_local_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredicateName::clear_has_local_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredicateName::clear_local_name() {
  if (local_name_ != NULL) local_name_->::blox::connect::LocalPredicateName::Clear();
  clear_has_local_name();
}
inline const ::blox::connect::LocalPredicateName& PredicateName::local_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.PredicateName.local_name)
  return local_name_ != NULL ? *local_name_ : *default_instance_->local_name_;
}
inline ::blox::connect::LocalPredicateName* PredicateName::mutable_local_name() {
  set_has_local_name();
  if (local_name_ == NULL) local_name_ = new ::blox::connect::LocalPredicateName;
  // @@protoc_insertion_point(field_mutable:blox.connect.PredicateName.local_name)
  return local_name_;
}
inline ::blox::connect::LocalPredicateName* PredicateName::release_local_name() {
  clear_has_local_name();
  ::blox::connect::LocalPredicateName* temp = local_name_;
  local_name_ = NULL;
  return temp;
}
inline void PredicateName::set_allocated_local_name(::blox::connect::LocalPredicateName* local_name) {
  delete local_name_;
  local_name_ = local_name;
  if (local_name) {
    set_has_local_name();
  } else {
    clear_has_local_name();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.PredicateName.local_name)
}

// optional .blox.connect.GlobalPredicateName global_name = 2;
inline bool PredicateName::has_global_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredicateName::set_has_global_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredicateName::clear_has_global_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PredicateName::clear_global_name() {
  if (global_name_ != NULL) global_name_->::blox::connect::GlobalPredicateName::Clear();
  clear_has_global_name();
}
inline const ::blox::connect::GlobalPredicateName& PredicateName::global_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.PredicateName.global_name)
  return global_name_ != NULL ? *global_name_ : *default_instance_->global_name_;
}
inline ::blox::connect::GlobalPredicateName* PredicateName::mutable_global_name() {
  set_has_global_name();
  if (global_name_ == NULL) global_name_ = new ::blox::connect::GlobalPredicateName;
  // @@protoc_insertion_point(field_mutable:blox.connect.PredicateName.global_name)
  return global_name_;
}
inline ::blox::connect::GlobalPredicateName* PredicateName::release_global_name() {
  clear_has_global_name();
  ::blox::connect::GlobalPredicateName* temp = global_name_;
  global_name_ = NULL;
  return temp;
}
inline void PredicateName::set_allocated_global_name(::blox::connect::GlobalPredicateName* global_name) {
  delete global_name_;
  global_name_ = global_name;
  if (global_name) {
    set_has_global_name();
  } else {
    clear_has_global_name();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.PredicateName.global_name)
}

// -------------------------------------------------------------------

// LocalPredicateName

// required string local_name = 1;
inline bool LocalPredicateName::has_local_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalPredicateName::set_has_local_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalPredicateName::clear_has_local_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalPredicateName::clear_local_name() {
  if (local_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_->clear();
  }
  clear_has_local_name();
}
inline const ::std::string& LocalPredicateName::local_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.LocalPredicateName.local_name)
  return *local_name_;
}
inline void LocalPredicateName::set_local_name(const ::std::string& value) {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_ = new ::std::string;
  }
  local_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.LocalPredicateName.local_name)
}
inline void LocalPredicateName::set_local_name(const char* value) {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_ = new ::std::string;
  }
  local_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.LocalPredicateName.local_name)
}
inline void LocalPredicateName::set_local_name(const char* value, size_t size) {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_ = new ::std::string;
  }
  local_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.LocalPredicateName.local_name)
}
inline ::std::string* LocalPredicateName::mutable_local_name() {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.LocalPredicateName.local_name)
  return local_name_;
}
inline ::std::string* LocalPredicateName::release_local_name() {
  clear_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = local_name_;
    local_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LocalPredicateName::set_allocated_local_name(::std::string* local_name) {
  if (local_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete local_name_;
  }
  if (local_name) {
    set_has_local_name();
    local_name_ = local_name;
  } else {
    clear_has_local_name();
    local_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.LocalPredicateName.local_name)
}

// required string block_name = 2;
inline bool LocalPredicateName::has_block_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalPredicateName::set_has_block_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalPredicateName::clear_has_block_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalPredicateName::clear_block_name() {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_->clear();
  }
  clear_has_block_name();
}
inline const ::std::string& LocalPredicateName::block_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.LocalPredicateName.block_name)
  return *block_name_;
}
inline void LocalPredicateName::set_block_name(const ::std::string& value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.LocalPredicateName.block_name)
}
inline void LocalPredicateName::set_block_name(const char* value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.LocalPredicateName.block_name)
}
inline void LocalPredicateName::set_block_name(const char* value, size_t size) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.LocalPredicateName.block_name)
}
inline ::std::string* LocalPredicateName::mutable_block_name() {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.LocalPredicateName.block_name)
  return block_name_;
}
inline ::std::string* LocalPredicateName::release_block_name() {
  clear_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = block_name_;
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LocalPredicateName::set_allocated_block_name(::std::string* block_name) {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete block_name_;
  }
  if (block_name) {
    set_has_block_name();
    block_name_ = block_name;
  } else {
    clear_has_block_name();
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.LocalPredicateName.block_name)
}

// -------------------------------------------------------------------

// GlobalPredicateName

// required string qualified_name = 1;
inline bool GlobalPredicateName::has_qualified_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalPredicateName::set_has_qualified_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalPredicateName::clear_has_qualified_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalPredicateName::clear_qualified_name() {
  if (qualified_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_->clear();
  }
  clear_has_qualified_name();
}
inline const ::std::string& GlobalPredicateName::qualified_name() const {
  // @@protoc_insertion_point(field_get:blox.connect.GlobalPredicateName.qualified_name)
  return *qualified_name_;
}
inline void GlobalPredicateName::set_qualified_name(const ::std::string& value) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.connect.GlobalPredicateName.qualified_name)
}
inline void GlobalPredicateName::set_qualified_name(const char* value) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.connect.GlobalPredicateName.qualified_name)
}
inline void GlobalPredicateName::set_qualified_name(const char* value, size_t size) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.connect.GlobalPredicateName.qualified_name)
}
inline ::std::string* GlobalPredicateName::mutable_qualified_name() {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.connect.GlobalPredicateName.qualified_name)
  return qualified_name_;
}
inline ::std::string* GlobalPredicateName::release_qualified_name() {
  clear_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = qualified_name_;
    qualified_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GlobalPredicateName::set_allocated_qualified_name(::std::string* qualified_name) {
  if (qualified_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete qualified_name_;
  }
  if (qualified_name) {
    set_has_qualified_name();
    qualified_name_ = qualified_name;
  } else {
    clear_has_qualified_name();
    qualified_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.connect.GlobalPredicateName.qualified_name)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace connect
}  // namespace blox

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::blox::connect::FaultKind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::connect::FaultKind>() {
  return ::blox::connect::FaultKind_descriptor();
}
template <> struct is_proto_enum< ::blox::connect::Language> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::connect::Language>() {
  return ::blox::connect::Language_descriptor();
}
template <> struct is_proto_enum< ::blox::connect::DeltaModifier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::connect::DeltaModifier>() {
  return ::blox::connect::DeltaModifier_descriptor();
}
template <> struct is_proto_enum< ::blox::connect::EntityMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::connect::EntityMode>() {
  return ::blox::connect::EntityMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_blox_2fconnect_2fBloxCommand_2eproto__INCLUDED
