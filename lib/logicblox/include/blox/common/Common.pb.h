// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: blox/common/Common.proto

#ifndef PROTOBUF_blox_2fcommon_2fCommon_2eproto__INCLUDED
#define PROTOBUF_blox_2fcommon_2fCommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace blox {
namespace common {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

class CompilationProblems;
class Problem;
class Position;
class PredicateInfo;
class PredicatePopcount;
class Constant;
class BoolConstant;
class IntConstant;
class UnsignedIntConstant;
class FloatConstant;
class DecimalConstant;
class Int128Constant;
class StringConstant;
class DateTimeConstant;
class Type;
class PrimitiveType;
class UnaryPredicateType;

enum Constant_Kind {
  Constant_Kind_BOOL = 0,
  Constant_Kind_INT = 1,
  Constant_Kind_FLOAT = 2,
  Constant_Kind_STRING = 3,
  Constant_Kind_DATETIME = 4,
  Constant_Kind_UINT = 5,
  Constant_Kind_DECIMAL = 6,
  Constant_Kind_INT128 = 7
};
bool Constant_Kind_IsValid(int value);
const Constant_Kind Constant_Kind_Kind_MIN = Constant_Kind_BOOL;
const Constant_Kind Constant_Kind_Kind_MAX = Constant_Kind_INT128;
const int Constant_Kind_Kind_ARRAYSIZE = Constant_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Constant_Kind_descriptor();
inline const ::std::string& Constant_Kind_Name(Constant_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Constant_Kind_descriptor(), value);
}
inline bool Constant_Kind_Parse(
    const ::std::string& name, Constant_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Constant_Kind>(
    Constant_Kind_descriptor(), name, value);
}
enum Type_Kind {
  Type_Kind_PRIMITIVE = 0,
  Type_Kind_UNARY = 1
};
bool Type_Kind_IsValid(int value);
const Type_Kind Type_Kind_Kind_MIN = Type_Kind_PRIMITIVE;
const Type_Kind Type_Kind_Kind_MAX = Type_Kind_UNARY;
const int Type_Kind_Kind_ARRAYSIZE = Type_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_Kind_descriptor();
inline const ::std::string& Type_Kind_Name(Type_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_Kind_descriptor(), value);
}
inline bool Type_Kind_Parse(
    const ::std::string& name, Type_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type_Kind>(
    Type_Kind_descriptor(), name, value);
}
enum PrimitiveType_Kind {
  PrimitiveType_Kind_BOOL = 0,
  PrimitiveType_Kind_DECIMAL = 1,
  PrimitiveType_Kind_SHAPE = 2,
  PrimitiveType_Kind_IMAGE = 3,
  PrimitiveType_Kind_BLOB = 4,
  PrimitiveType_Kind_DATETIME = 5,
  PrimitiveType_Kind_INT = 6,
  PrimitiveType_Kind_UINT = 7,
  PrimitiveType_Kind_FLOAT = 8,
  PrimitiveType_Kind_STRING = 9,
  PrimitiveType_Kind_INT128 = 10
};
bool PrimitiveType_Kind_IsValid(int value);
const PrimitiveType_Kind PrimitiveType_Kind_Kind_MIN = PrimitiveType_Kind_BOOL;
const PrimitiveType_Kind PrimitiveType_Kind_Kind_MAX = PrimitiveType_Kind_INT128;
const int PrimitiveType_Kind_Kind_ARRAYSIZE = PrimitiveType_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* PrimitiveType_Kind_descriptor();
inline const ::std::string& PrimitiveType_Kind_Name(PrimitiveType_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    PrimitiveType_Kind_descriptor(), value);
}
inline bool PrimitiveType_Kind_Parse(
    const ::std::string& name, PrimitiveType_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrimitiveType_Kind>(
    PrimitiveType_Kind_descriptor(), name, value);
}
enum Severity {
  SEV_ERROR = 0,
  SEV_WARNING = 1,
  SEV_NONE = 2
};
bool Severity_IsValid(int value);
const Severity Severity_MIN = SEV_ERROR;
const Severity Severity_MAX = SEV_NONE;
const int Severity_ARRAYSIZE = Severity_MAX + 1;

const ::google::protobuf::EnumDescriptor* Severity_descriptor();
inline const ::std::string& Severity_Name(Severity value) {
  return ::google::protobuf::internal::NameOfEnum(
    Severity_descriptor(), value);
}
inline bool Severity_Parse(
    const ::std::string& name, Severity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Severity>(
    Severity_descriptor(), name, value);
}
enum Lifetime {
  TRANSACTION = 1,
  DATABASE = 2,
  SESSION = 3
};
bool Lifetime_IsValid(int value);
const Lifetime Lifetime_MIN = TRANSACTION;
const Lifetime Lifetime_MAX = SESSION;
const int Lifetime_ARRAYSIZE = Lifetime_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lifetime_descriptor();
inline const ::std::string& Lifetime_Name(Lifetime value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lifetime_descriptor(), value);
}
inline bool Lifetime_Parse(
    const ::std::string& name, Lifetime* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lifetime>(
    Lifetime_descriptor(), name, value);
}
enum DerivationType {
  NOT_DERIVED = 0,
  EXTENSIONAL = 1,
  DERIVED = 2,
  DERIVED_AND_STORED = 3,
  INTEGRITY_CONSTRAINT = 4
};
bool DerivationType_IsValid(int value);
const DerivationType DerivationType_MIN = NOT_DERIVED;
const DerivationType DerivationType_MAX = INTEGRITY_CONSTRAINT;
const int DerivationType_ARRAYSIZE = DerivationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DerivationType_descriptor();
inline const ::std::string& DerivationType_Name(DerivationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DerivationType_descriptor(), value);
}
inline bool DerivationType_Parse(
    const ::std::string& name, DerivationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DerivationType>(
    DerivationType_descriptor(), name, value);
}
enum LogicSort {
  ACTIVE = 1,
  INACTIVE = 2,
  EXECUTE = 3,
  INACTIVE_AFTER_FIXPOINT = 4,
  EXECUTE_AFTER_FIXPOINT = 5
};
bool LogicSort_IsValid(int value);
const LogicSort LogicSort_MIN = ACTIVE;
const LogicSort LogicSort_MAX = EXECUTE_AFTER_FIXPOINT;
const int LogicSort_ARRAYSIZE = LogicSort_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogicSort_descriptor();
inline const ::std::string& LogicSort_Name(LogicSort value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogicSort_descriptor(), value);
}
inline bool LogicSort_Parse(
    const ::std::string& name, LogicSort* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogicSort>(
    LogicSort_descriptor(), name, value);
}
// ===================================================================

class CompilationProblems : public ::google::protobuf::Message {
 public:
  CompilationProblems();
  virtual ~CompilationProblems();

  CompilationProblems(const CompilationProblems& from);

  inline CompilationProblems& operator=(const CompilationProblems& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CompilationProblems& default_instance();

  void Swap(CompilationProblems* other);

  // implements Message ----------------------------------------------

  CompilationProblems* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompilationProblems& from);
  void MergeFrom(const CompilationProblems& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blox.common.protocol.Problem error = 1;
  inline int error_size() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::blox::common::protocol::Problem& error(int index) const;
  inline ::blox::common::protocol::Problem* mutable_error(int index);
  inline ::blox::common::protocol::Problem* add_error();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >&
      error() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >*
      mutable_error();

  // repeated .blox.common.protocol.Problem warning = 2;
  inline int warning_size() const;
  inline void clear_warning();
  static const int kWarningFieldNumber = 2;
  inline const ::blox::common::protocol::Problem& warning(int index) const;
  inline ::blox::common::protocol::Problem* mutable_warning(int index);
  inline ::blox::common::protocol::Problem* add_warning();
  inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >&
      warning() const;
  inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >*
      mutable_warning();

  // @@protoc_insertion_point(class_scope:blox.common.protocol.CompilationProblems)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem > error_;
  ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem > warning_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static CompilationProblems* default_instance_;
};
// -------------------------------------------------------------------

class Problem : public ::google::protobuf::Message {
 public:
  Problem();
  virtual ~Problem();

  Problem(const Problem& from);

  inline Problem& operator=(const Problem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Problem& default_instance();

  void Swap(Problem* other);

  // implements Message ----------------------------------------------

  Problem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Problem& from);
  void MergeFrom(const Problem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // required .blox.common.protocol.Position position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  inline void set_allocated_position(::blox::common::protocol::Position* position);

  // required .blox.common.protocol.Severity severity_code = 5;
  inline bool has_severity_code() const;
  inline void clear_severity_code();
  static const int kSeverityCodeFieldNumber = 5;
  inline ::blox::common::protocol::Severity severity_code() const;
  inline void set_severity_code(::blox::common::protocol::Severity value);

  // optional string quote = 7;
  inline bool has_quote() const;
  inline void clear_quote();
  static const int kQuoteFieldNumber = 7;
  inline const ::std::string& quote() const;
  inline void set_quote(const ::std::string& value);
  inline void set_quote(const char* value);
  inline void set_quote(const char* value, size_t size);
  inline ::std::string* mutable_quote();
  inline ::std::string* release_quote();
  inline void set_allocated_quote(::std::string* quote);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.Problem)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_severity_code();
  inline void clear_has_severity_code();
  inline void set_has_quote();
  inline void clear_has_quote();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* code_;
  ::std::string* msg_;
  ::blox::common::protocol::Position* position_;
  ::std::string* quote_;
  int severity_code_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static Problem* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 start_line = 1;
  inline bool has_start_line() const;
  inline void clear_start_line();
  static const int kStartLineFieldNumber = 1;
  inline ::google::protobuf::int64 start_line() const;
  inline void set_start_line(::google::protobuf::int64 value);

  // required int64 start_column = 2;
  inline bool has_start_column() const;
  inline void clear_start_column();
  static const int kStartColumnFieldNumber = 2;
  inline ::google::protobuf::int64 start_column() const;
  inline void set_start_column(::google::protobuf::int64 value);

  // optional int64 end_line = 3;
  inline bool has_end_line() const;
  inline void clear_end_line();
  static const int kEndLineFieldNumber = 3;
  inline ::google::protobuf::int64 end_line() const;
  inline void set_end_line(::google::protobuf::int64 value);

  // optional int64 end_column = 4;
  inline bool has_end_column() const;
  inline void clear_end_column();
  static const int kEndColumnFieldNumber = 4;
  inline ::google::protobuf::int64 end_column() const;
  inline void set_end_column(::google::protobuf::int64 value);

  // optional int64 start_offset = 5;
  inline bool has_start_offset() const;
  inline void clear_start_offset();
  static const int kStartOffsetFieldNumber = 5;
  inline ::google::protobuf::int64 start_offset() const;
  inline void set_start_offset(::google::protobuf::int64 value);

  // optional int64 end_offset = 6;
  inline bool has_end_offset() const;
  inline void clear_end_offset();
  static const int kEndOffsetFieldNumber = 6;
  inline ::google::protobuf::int64 end_offset() const;
  inline void set_end_offset(::google::protobuf::int64 value);

  // required string block_name = 7;
  inline bool has_block_name() const;
  inline void clear_block_name();
  static const int kBlockNameFieldNumber = 7;
  inline const ::std::string& block_name() const;
  inline void set_block_name(const ::std::string& value);
  inline void set_block_name(const char* value);
  inline void set_block_name(const char* value, size_t size);
  inline ::std::string* mutable_block_name();
  inline ::std::string* release_block_name();
  inline void set_allocated_block_name(::std::string* block_name);

  // optional string file_name = 8;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 8;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.Position)
 private:
  inline void set_has_start_line();
  inline void clear_has_start_line();
  inline void set_has_start_column();
  inline void clear_has_start_column();
  inline void set_has_end_line();
  inline void clear_has_end_line();
  inline void set_has_end_column();
  inline void clear_has_end_column();
  inline void set_has_start_offset();
  inline void clear_has_start_offset();
  inline void set_has_end_offset();
  inline void clear_has_end_offset();
  inline void set_has_block_name();
  inline void clear_has_block_name();
  inline void set_has_file_name();
  inline void clear_has_file_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 start_line_;
  ::google::protobuf::int64 start_column_;
  ::google::protobuf::int64 end_line_;
  ::google::protobuf::int64 end_column_;
  ::google::protobuf::int64 start_offset_;
  ::google::protobuf::int64 end_offset_;
  ::std::string* block_name_;
  ::std::string* file_name_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class PredicateInfo : public ::google::protobuf::Message {
 public:
  PredicateInfo();
  virtual ~PredicateInfo();

  PredicateInfo(const PredicateInfo& from);

  inline PredicateInfo& operator=(const PredicateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredicateInfo& default_instance();

  void Swap(PredicateInfo* other);

  // implements Message ----------------------------------------------

  PredicateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PredicateInfo& from);
  void MergeFrom(const PredicateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string qualified_name = 2;
  inline bool has_qualified_name() const;
  inline void clear_qualified_name();
  static const int kQualifiedNameFieldNumber = 2;
  inline const ::std::string& qualified_name() const;
  inline void set_qualified_name(const ::std::string& value);
  inline void set_qualified_name(const char* value);
  inline void set_qualified_name(const char* value, size_t size);
  inline ::std::string* mutable_qualified_name();
  inline ::std::string* release_qualified_name();
  inline void set_allocated_qualified_name(::std::string* qualified_name);

  // required int64 arity = 3;
  inline bool has_arity() const;
  inline void clear_arity();
  static const int kArityFieldNumber = 3;
  inline ::google::protobuf::int64 arity() const;
  inline void set_arity(::google::protobuf::int64 value);

  // required int64 key_arity = 4;
  inline bool has_key_arity() const;
  inline void clear_key_arity();
  static const int kKeyArityFieldNumber = 4;
  inline ::google::protobuf::int64 key_arity() const;
  inline void set_key_arity(::google::protobuf::int64 value);

  // required int64 value_arity = 5;
  inline bool has_value_arity() const;
  inline void clear_value_arity();
  static const int kValueArityFieldNumber = 5;
  inline ::google::protobuf::int64 value_arity() const;
  inline void set_value_arity(::google::protobuf::int64 value);

  // repeated string key_argument = 6;
  inline int key_argument_size() const;
  inline void clear_key_argument();
  static const int kKeyArgumentFieldNumber = 6;
  inline const ::std::string& key_argument(int index) const;
  inline ::std::string* mutable_key_argument(int index);
  inline void set_key_argument(int index, const ::std::string& value);
  inline void set_key_argument(int index, const char* value);
  inline void set_key_argument(int index, const char* value, size_t size);
  inline ::std::string* add_key_argument();
  inline void add_key_argument(const ::std::string& value);
  inline void add_key_argument(const char* value);
  inline void add_key_argument(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key_argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key_argument();

  // repeated string value_argument = 7;
  inline int value_argument_size() const;
  inline void clear_value_argument();
  static const int kValueArgumentFieldNumber = 7;
  inline const ::std::string& value_argument(int index) const;
  inline ::std::string* mutable_value_argument(int index);
  inline void set_value_argument(int index, const ::std::string& value);
  inline void set_value_argument(int index, const char* value);
  inline void set_value_argument(int index, const char* value, size_t size);
  inline ::std::string* add_value_argument();
  inline void add_value_argument(const ::std::string& value);
  inline void add_value_argument(const char* value);
  inline void add_value_argument(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value_argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value_argument();

  // required bool is_entity = 8 [default = false];
  inline bool has_is_entity() const;
  inline void clear_is_entity();
  static const int kIsEntityFieldNumber = 8;
  inline bool is_entity() const;
  inline void set_is_entity(bool value);

  // required bool is_ref_mode = 9 [default = false];
  inline bool has_is_ref_mode() const;
  inline void clear_is_ref_mode();
  static const int kIsRefModeFieldNumber = 9;
  inline bool is_ref_mode() const;
  inline void set_is_ref_mode(bool value);

  // required bool is_one_to_one = 10 [default = false];
  inline bool has_is_one_to_one() const;
  inline void clear_is_one_to_one();
  static const int kIsOneToOneFieldNumber = 10;
  inline bool is_one_to_one() const;
  inline void set_is_one_to_one(bool value);

  // required bool is_ordered = 11 [default = false];
  inline bool has_is_ordered() const;
  inline void clear_is_ordered();
  static const int kIsOrderedFieldNumber = 11;
  inline bool is_ordered() const;
  inline void set_is_ordered(bool value);

  // required bool has_default_value = 12 [default = false];
  inline bool has_has_default_value() const;
  inline void clear_has_default_value();
  static const int kHasDefaultValueFieldNumber = 12;
  inline bool has_default_value() const;
  inline void set_has_default_value(bool value);

  // required bool is_subtype = 14 [default = false];
  inline bool has_is_subtype() const;
  inline void clear_is_subtype();
  static const int kIsSubtypeFieldNumber = 14;
  inline bool is_subtype() const;
  inline void set_is_subtype(bool value);

  // optional string supertype = 15;
  inline bool has_supertype() const;
  inline void clear_supertype();
  static const int kSupertypeFieldNumber = 15;
  inline const ::std::string& supertype() const;
  inline void set_supertype(const ::std::string& value);
  inline void set_supertype(const char* value);
  inline void set_supertype(const char* value, size_t size);
  inline ::std::string* mutable_supertype();
  inline ::std::string* release_supertype();
  inline void set_allocated_supertype(::std::string* supertype);

  // optional string toptype = 42;
  inline bool has_toptype() const;
  inline void clear_toptype();
  static const int kToptypeFieldNumber = 42;
  inline const ::std::string& toptype() const;
  inline void set_toptype(const ::std::string& value);
  inline void set_toptype(const char* value);
  inline void set_toptype(const char* value, size_t size);
  inline ::std::string* mutable_toptype();
  inline ::std::string* release_toptype();
  inline void set_allocated_toptype(::std::string* toptype);

  // required bool has_ref_mode = 16 [default = false];
  inline bool has_has_ref_mode() const;
  inline void clear_has_ref_mode();
  static const int kHasRefModeFieldNumber = 16;
  inline bool has_ref_mode() const;
  inline void set_has_ref_mode(bool value);

  // optional string ref_mode_name = 17;
  inline bool has_ref_mode_name() const;
  inline void clear_ref_mode_name();
  static const int kRefModeNameFieldNumber = 17;
  inline const ::std::string& ref_mode_name() const;
  inline void set_ref_mode_name(const ::std::string& value);
  inline void set_ref_mode_name(const char* value);
  inline void set_ref_mode_name(const char* value, size_t size);
  inline ::std::string* mutable_ref_mode_name();
  inline ::std::string* release_ref_mode_name();
  inline void set_allocated_ref_mode_name(::std::string* ref_mode_name);

  // required bool is_meta_predicate = 18 [default = false];
  inline bool has_is_meta_predicate() const;
  inline void clear_is_meta_predicate();
  static const int kIsMetaPredicateFieldNumber = 18;
  inline bool is_meta_predicate() const;
  inline void set_is_meta_predicate(bool value);

  // required bool is_pulse_predicate = 19 [default = false];
  inline bool has_is_pulse_predicate() const;
  inline void clear_is_pulse_predicate();
  static const int kIsPulsePredicateFieldNumber = 19;
  inline bool is_pulse_predicate() const;
  inline void set_is_pulse_predicate(bool value);

  // required bool is_calculated = 20 [default = false];
  inline bool has_is_calculated() const;
  inline void clear_is_calculated();
  static const int kIsCalculatedFieldNumber = 20;
  inline bool is_calculated() const;
  inline void set_is_calculated(bool value);

  // required .blox.common.protocol.DerivationType derivation_type = 22;
  inline bool has_derivation_type() const;
  inline void clear_derivation_type();
  static const int kDerivationTypeFieldNumber = 22;
  inline ::blox::common::protocol::DerivationType derivation_type() const;
  inline void set_derivation_type(::blox::common::protocol::DerivationType value);

  // optional bool is_built_in = 28 [default = false];
  inline bool has_is_built_in() const;
  inline void clear_is_built_in();
  static const int kIsBuiltInFieldNumber = 28;
  inline bool is_built_in() const;
  inline void set_is_built_in(bool value);

  // required .blox.common.protocol.Lifetime lifetime = 30;
  inline bool has_lifetime() const;
  inline void clear_lifetime();
  static const int kLifetimeFieldNumber = 30;
  inline ::blox::common::protocol::Lifetime lifetime() const;
  inline void set_lifetime(::blox::common::protocol::Lifetime value);

  // required bool is_auto_numbered = 31;
  inline bool has_is_auto_numbered() const;
  inline void clear_is_auto_numbered();
  static const int kIsAutoNumberedFieldNumber = 31;
  inline bool is_auto_numbered() const;
  inline void set_is_auto_numbered(bool value);

  // optional .blox.common.protocol.Constant actual_default_value = 32;
  inline bool has_actual_default_value() const;
  inline void clear_actual_default_value();
  static const int kActualDefaultValueFieldNumber = 32;
  inline const ::blox::common::protocol::Constant& actual_default_value() const;
  inline ::blox::common::protocol::Constant* mutable_actual_default_value();
  inline ::blox::common::protocol::Constant* release_actual_default_value();
  inline void set_allocated_actual_default_value(::blox::common::protocol::Constant* actual_default_value);

  // optional string file_path = 33;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 33;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // optional string file_mode = 45;
  inline bool has_file_mode() const;
  inline void clear_file_mode();
  static const int kFileModeFieldNumber = 45;
  inline const ::std::string& file_mode() const;
  inline void set_file_mode(const ::std::string& value);
  inline void set_file_mode(const char* value);
  inline void set_file_mode(const char* value, size_t size);
  inline ::std::string* mutable_file_mode();
  inline ::std::string* release_file_mode();
  inline void set_allocated_file_mode(::std::string* file_mode);

  // optional string delimiter = 34;
  inline bool has_delimiter() const;
  inline void clear_delimiter();
  static const int kDelimiterFieldNumber = 34;
  inline const ::std::string& delimiter() const;
  inline void set_delimiter(const ::std::string& value);
  inline void set_delimiter(const char* value);
  inline void set_delimiter(const char* value, size_t size);
  inline ::std::string* mutable_delimiter();
  inline ::std::string* release_delimiter();
  inline void set_allocated_delimiter(::std::string* delimiter);

  // optional bool has_column_names = 35;
  inline bool has_has_column_names() const;
  inline void clear_has_column_names();
  static const int kHasColumnNamesFieldNumber = 35;
  inline bool has_column_names() const;
  inline void set_has_column_names(bool value);

  // optional string delim_column_names = 36;
  inline bool has_delim_column_names() const;
  inline void clear_delim_column_names();
  static const int kDelimColumnNamesFieldNumber = 36;
  inline const ::std::string& delim_column_names() const;
  inline void set_delim_column_names(const ::std::string& value);
  inline void set_delim_column_names(const char* value);
  inline void set_delim_column_names(const char* value, size_t size);
  inline ::std::string* mutable_delim_column_names();
  inline ::std::string* release_delim_column_names();
  inline void set_allocated_delim_column_names(::std::string* delim_column_names);

  // optional bool is_sealed = 37 [default = false];
  inline bool has_is_sealed() const;
  inline void clear_is_sealed();
  static const int kIsSealedFieldNumber = 37;
  inline bool is_sealed() const;
  inline void set_is_sealed(bool value);

  // optional string local_name = 38;
  inline bool has_local_name() const;
  inline void clear_local_name();
  static const int kLocalNameFieldNumber = 38;
  inline const ::std::string& local_name() const;
  inline void set_local_name(const ::std::string& value);
  inline void set_local_name(const char* value);
  inline void set_local_name(const char* value, size_t size);
  inline ::std::string* mutable_local_name();
  inline ::std::string* release_local_name();
  inline void set_allocated_local_name(::std::string* local_name);

  // optional string definition_block = 44;
  inline bool has_definition_block() const;
  inline void clear_definition_block();
  static const int kDefinitionBlockFieldNumber = 44;
  inline const ::std::string& definition_block() const;
  inline void set_definition_block(const ::std::string& value);
  inline void set_definition_block(const char* value);
  inline void set_definition_block(const char* value, size_t size);
  inline ::std::string* mutable_definition_block();
  inline ::std::string* release_definition_block();
  inline void set_allocated_definition_block(::std::string* definition_block);

  // optional string display_name = 39;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 39;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // optional bool is_synthetic = 41;
  inline bool has_is_synthetic() const;
  inline void clear_is_synthetic();
  static const int kIsSyntheticFieldNumber = 41;
  inline bool is_synthetic() const;
  inline void set_is_synthetic(bool value);

  // optional bool is_constructor = 43;
  inline bool has_is_constructor() const;
  inline void clear_is_constructor();
  static const int kIsConstructorFieldNumber = 43;
  inline bool is_constructor() const;
  inline void set_is_constructor(bool value);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.PredicateInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_qualified_name();
  inline void clear_has_qualified_name();
  inline void set_has_arity();
  inline void clear_has_arity();
  inline void set_has_key_arity();
  inline void clear_has_key_arity();
  inline void set_has_value_arity();
  inline void clear_has_value_arity();
  inline void set_has_is_entity();
  inline void clear_has_is_entity();
  inline void set_has_is_ref_mode();
  inline void clear_has_is_ref_mode();
  inline void set_has_is_one_to_one();
  inline void clear_has_is_one_to_one();
  inline void set_has_is_ordered();
  inline void clear_has_is_ordered();
  inline void set_has_has_default_value();
  inline void clear_has_has_default_value();
  inline void set_has_is_subtype();
  inline void clear_has_is_subtype();
  inline void set_has_supertype();
  inline void clear_has_supertype();
  inline void set_has_toptype();
  inline void clear_has_toptype();
  inline void set_has_has_ref_mode();
  inline void clear_has_has_ref_mode();
  inline void set_has_ref_mode_name();
  inline void clear_has_ref_mode_name();
  inline void set_has_is_meta_predicate();
  inline void clear_has_is_meta_predicate();
  inline void set_has_is_pulse_predicate();
  inline void clear_has_is_pulse_predicate();
  inline void set_has_is_calculated();
  inline void clear_has_is_calculated();
  inline void set_has_derivation_type();
  inline void clear_has_derivation_type();
  inline void set_has_is_built_in();
  inline void clear_has_is_built_in();
  inline void set_has_lifetime();
  inline void clear_has_lifetime();
  inline void set_has_is_auto_numbered();
  inline void clear_has_is_auto_numbered();
  inline void set_has_actual_default_value();
  inline void clear_has_actual_default_value();
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_file_mode();
  inline void clear_has_file_mode();
  inline void set_has_delimiter();
  inline void clear_has_delimiter();
  inline void set_has_has_column_names();
  inline void clear_has_has_column_names();
  inline void set_has_delim_column_names();
  inline void clear_has_delim_column_names();
  inline void set_has_is_sealed();
  inline void clear_has_is_sealed();
  inline void set_has_local_name();
  inline void clear_has_local_name();
  inline void set_has_definition_block();
  inline void clear_has_definition_block();
  inline void set_has_display_name();
  inline void clear_has_display_name();
  inline void set_has_is_synthetic();
  inline void clear_has_is_synthetic();
  inline void set_has_is_constructor();
  inline void clear_has_is_constructor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::std::string* name_;
  ::std::string* qualified_name_;
  ::google::protobuf::int64 arity_;
  ::google::protobuf::int64 key_arity_;
  ::google::protobuf::int64 value_arity_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_argument_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_argument_;
  bool is_entity_;
  bool is_ref_mode_;
  bool is_one_to_one_;
  bool is_ordered_;
  bool has_default_value_;
  bool is_subtype_;
  bool has_ref_mode_;
  bool is_meta_predicate_;
  ::std::string* supertype_;
  ::std::string* toptype_;
  ::std::string* ref_mode_name_;
  int derivation_type_;
  bool is_pulse_predicate_;
  bool is_calculated_;
  bool is_built_in_;
  bool is_auto_numbered_;
  ::blox::common::protocol::Constant* actual_default_value_;
  ::std::string* file_path_;
  ::std::string* file_mode_;
  ::std::string* delimiter_;
  ::std::string* delim_column_names_;
  int lifetime_;
  bool has_column_names_;
  bool is_sealed_;
  bool is_synthetic_;
  bool is_constructor_;
  ::std::string* local_name_;
  ::std::string* definition_block_;
  ::std::string* display_name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static PredicateInfo* default_instance_;
};
// -------------------------------------------------------------------

class PredicatePopcount : public ::google::protobuf::Message {
 public:
  PredicatePopcount();
  virtual ~PredicatePopcount();

  PredicatePopcount(const PredicatePopcount& from);

  inline PredicatePopcount& operator=(const PredicatePopcount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredicatePopcount& default_instance();

  void Swap(PredicatePopcount* other);

  // implements Message ----------------------------------------------

  PredicatePopcount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PredicatePopcount& from);
  void MergeFrom(const PredicatePopcount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string qualified_name = 1;
  inline bool has_qualified_name() const;
  inline void clear_qualified_name();
  static const int kQualifiedNameFieldNumber = 1;
  inline const ::std::string& qualified_name() const;
  inline void set_qualified_name(const ::std::string& value);
  inline void set_qualified_name(const char* value);
  inline void set_qualified_name(const char* value, size_t size);
  inline ::std::string* mutable_qualified_name();
  inline ::std::string* release_qualified_name();
  inline void set_allocated_qualified_name(::std::string* qualified_name);

  // optional int64 popcount = 2 [default = -1];
  inline bool has_popcount() const;
  inline void clear_popcount();
  static const int kPopcountFieldNumber = 2;
  inline ::google::protobuf::int64 popcount() const;
  inline void set_popcount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.PredicatePopcount)
 private:
  inline void set_has_qualified_name();
  inline void clear_has_qualified_name();
  inline void set_has_popcount();
  inline void clear_has_popcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* qualified_name_;
  ::google::protobuf::int64 popcount_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static PredicatePopcount* default_instance_;
};
// -------------------------------------------------------------------

class Constant : public ::google::protobuf::Message {
 public:
  Constant();
  virtual ~Constant();

  Constant(const Constant& from);

  inline Constant& operator=(const Constant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Constant& default_instance();

  void Swap(Constant* other);

  // implements Message ----------------------------------------------

  Constant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Constant& from);
  void MergeFrom(const Constant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Constant_Kind Kind;
  static const Kind BOOL = Constant_Kind_BOOL;
  static const Kind INT = Constant_Kind_INT;
  static const Kind FLOAT = Constant_Kind_FLOAT;
  static const Kind STRING = Constant_Kind_STRING;
  static const Kind DATETIME = Constant_Kind_DATETIME;
  static const Kind UINT = Constant_Kind_UINT;
  static const Kind DECIMAL = Constant_Kind_DECIMAL;
  static const Kind INT128 = Constant_Kind_INT128;
  static inline bool Kind_IsValid(int value) {
    return Constant_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    Constant_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    Constant_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    Constant_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return Constant_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return Constant_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return Constant_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .blox.common.protocol.Constant.Kind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::blox::common::protocol::Constant_Kind kind() const;
  inline void set_kind(::blox::common::protocol::Constant_Kind value);

  // optional .blox.common.protocol.BoolConstant bool_constant = 2;
  inline bool has_bool_constant() const;
  inline void clear_bool_constant();
  static const int kBoolConstantFieldNumber = 2;
  inline const ::blox::common::protocol::BoolConstant& bool_constant() const;
  inline ::blox::common::protocol::BoolConstant* mutable_bool_constant();
  inline ::blox::common::protocol::BoolConstant* release_bool_constant();
  inline void set_allocated_bool_constant(::blox::common::protocol::BoolConstant* bool_constant);

  // optional .blox.common.protocol.IntConstant int_constant = 3;
  inline bool has_int_constant() const;
  inline void clear_int_constant();
  static const int kIntConstantFieldNumber = 3;
  inline const ::blox::common::protocol::IntConstant& int_constant() const;
  inline ::blox::common::protocol::IntConstant* mutable_int_constant();
  inline ::blox::common::protocol::IntConstant* release_int_constant();
  inline void set_allocated_int_constant(::blox::common::protocol::IntConstant* int_constant);

  // optional .blox.common.protocol.FloatConstant float_constant = 4;
  inline bool has_float_constant() const;
  inline void clear_float_constant();
  static const int kFloatConstantFieldNumber = 4;
  inline const ::blox::common::protocol::FloatConstant& float_constant() const;
  inline ::blox::common::protocol::FloatConstant* mutable_float_constant();
  inline ::blox::common::protocol::FloatConstant* release_float_constant();
  inline void set_allocated_float_constant(::blox::common::protocol::FloatConstant* float_constant);

  // optional .blox.common.protocol.StringConstant string_constant = 5;
  inline bool has_string_constant() const;
  inline void clear_string_constant();
  static const int kStringConstantFieldNumber = 5;
  inline const ::blox::common::protocol::StringConstant& string_constant() const;
  inline ::blox::common::protocol::StringConstant* mutable_string_constant();
  inline ::blox::common::protocol::StringConstant* release_string_constant();
  inline void set_allocated_string_constant(::blox::common::protocol::StringConstant* string_constant);

  // optional .blox.common.protocol.DateTimeConstant date_time_constant = 6;
  inline bool has_date_time_constant() const;
  inline void clear_date_time_constant();
  static const int kDateTimeConstantFieldNumber = 6;
  inline const ::blox::common::protocol::DateTimeConstant& date_time_constant() const;
  inline ::blox::common::protocol::DateTimeConstant* mutable_date_time_constant();
  inline ::blox::common::protocol::DateTimeConstant* release_date_time_constant();
  inline void set_allocated_date_time_constant(::blox::common::protocol::DateTimeConstant* date_time_constant);

  // optional .blox.common.protocol.UnsignedIntConstant uint_constant = 7;
  inline bool has_uint_constant() const;
  inline void clear_uint_constant();
  static const int kUintConstantFieldNumber = 7;
  inline const ::blox::common::protocol::UnsignedIntConstant& uint_constant() const;
  inline ::blox::common::protocol::UnsignedIntConstant* mutable_uint_constant();
  inline ::blox::common::protocol::UnsignedIntConstant* release_uint_constant();
  inline void set_allocated_uint_constant(::blox::common::protocol::UnsignedIntConstant* uint_constant);

  // optional .blox.common.protocol.DecimalConstant decimal_constant = 8;
  inline bool has_decimal_constant() const;
  inline void clear_decimal_constant();
  static const int kDecimalConstantFieldNumber = 8;
  inline const ::blox::common::protocol::DecimalConstant& decimal_constant() const;
  inline ::blox::common::protocol::DecimalConstant* mutable_decimal_constant();
  inline ::blox::common::protocol::DecimalConstant* release_decimal_constant();
  inline void set_allocated_decimal_constant(::blox::common::protocol::DecimalConstant* decimal_constant);

  // optional .blox.common.protocol.Int128Constant int128_constant = 9;
  inline bool has_int128_constant() const;
  inline void clear_int128_constant();
  static const int kInt128ConstantFieldNumber = 9;
  inline const ::blox::common::protocol::Int128Constant& int128_constant() const;
  inline ::blox::common::protocol::Int128Constant* mutable_int128_constant();
  inline ::blox::common::protocol::Int128Constant* release_int128_constant();
  inline void set_allocated_int128_constant(::blox::common::protocol::Int128Constant* int128_constant);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.Constant)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_bool_constant();
  inline void clear_has_bool_constant();
  inline void set_has_int_constant();
  inline void clear_has_int_constant();
  inline void set_has_float_constant();
  inline void clear_has_float_constant();
  inline void set_has_string_constant();
  inline void clear_has_string_constant();
  inline void set_has_date_time_constant();
  inline void clear_has_date_time_constant();
  inline void set_has_uint_constant();
  inline void clear_has_uint_constant();
  inline void set_has_decimal_constant();
  inline void clear_has_decimal_constant();
  inline void set_has_int128_constant();
  inline void clear_has_int128_constant();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::common::protocol::BoolConstant* bool_constant_;
  ::blox::common::protocol::IntConstant* int_constant_;
  ::blox::common::protocol::FloatConstant* float_constant_;
  ::blox::common::protocol::StringConstant* string_constant_;
  ::blox::common::protocol::DateTimeConstant* date_time_constant_;
  ::blox::common::protocol::UnsignedIntConstant* uint_constant_;
  ::blox::common::protocol::DecimalConstant* decimal_constant_;
  ::blox::common::protocol::Int128Constant* int128_constant_;
  int kind_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static Constant* default_instance_;
};
// -------------------------------------------------------------------

class BoolConstant : public ::google::protobuf::Message {
 public:
  BoolConstant();
  virtual ~BoolConstant();

  BoolConstant(const BoolConstant& from);

  inline BoolConstant& operator=(const BoolConstant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoolConstant& default_instance();

  void Swap(BoolConstant* other);

  // implements Message ----------------------------------------------

  BoolConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoolConstant& from);
  void MergeFrom(const BoolConstant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline bool value() const;
  inline void set_value(bool value);

  // optional .blox.common.protocol.Position position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  inline void set_allocated_position(::blox::common::protocol::Position* position);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.BoolConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::common::protocol::Position* position_;
  bool value_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static BoolConstant* default_instance_;
};
// -------------------------------------------------------------------

class IntConstant : public ::google::protobuf::Message {
 public:
  IntConstant();
  virtual ~IntConstant();

  IntConstant(const IntConstant& from);

  inline IntConstant& operator=(const IntConstant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntConstant& default_instance();

  void Swap(IntConstant* other);

  // implements Message ----------------------------------------------

  IntConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntConstant& from);
  void MergeFrom(const IntConstant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // required .blox.common.protocol.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::blox::common::protocol::Type& type() const;
  inline ::blox::common::protocol::Type* mutable_type();
  inline ::blox::common::protocol::Type* release_type();
  inline void set_allocated_type(::blox::common::protocol::Type* type);

  // optional .blox.common.protocol.Position position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  inline void set_allocated_position(::blox::common::protocol::Position* position);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.IntConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 value_;
  ::blox::common::protocol::Type* type_;
  ::blox::common::protocol::Position* position_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static IntConstant* default_instance_;
};
// -------------------------------------------------------------------

class UnsignedIntConstant : public ::google::protobuf::Message {
 public:
  UnsignedIntConstant();
  virtual ~UnsignedIntConstant();

  UnsignedIntConstant(const UnsignedIntConstant& from);

  inline UnsignedIntConstant& operator=(const UnsignedIntConstant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnsignedIntConstant& default_instance();

  void Swap(UnsignedIntConstant* other);

  // implements Message ----------------------------------------------

  UnsignedIntConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnsignedIntConstant& from);
  void MergeFrom(const UnsignedIntConstant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // required .blox.common.protocol.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::blox::common::protocol::Type& type() const;
  inline ::blox::common::protocol::Type* mutable_type();
  inline ::blox::common::protocol::Type* release_type();
  inline void set_allocated_type(::blox::common::protocol::Type* type);

  // optional .blox.common.protocol.Position position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  inline void set_allocated_position(::blox::common::protocol::Position* position);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.UnsignedIntConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 value_;
  ::blox::common::protocol::Type* type_;
  ::blox::common::protocol::Position* position_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static UnsignedIntConstant* default_instance_;
};
// -------------------------------------------------------------------

class FloatConstant : public ::google::protobuf::Message {
 public:
  FloatConstant();
  virtual ~FloatConstant();

  FloatConstant(const FloatConstant& from);

  inline FloatConstant& operator=(const FloatConstant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatConstant& default_instance();

  void Swap(FloatConstant* other);

  // implements Message ----------------------------------------------

  FloatConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloatConstant& from);
  void MergeFrom(const FloatConstant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // required .blox.common.protocol.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::blox::common::protocol::Type& type() const;
  inline ::blox::common::protocol::Type* mutable_type();
  inline ::blox::common::protocol::Type* release_type();
  inline void set_allocated_type(::blox::common::protocol::Type* type);

  // optional .blox.common.protocol.Position position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  inline void set_allocated_position(::blox::common::protocol::Position* position);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.FloatConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::blox::common::protocol::Type* type_;
  ::blox::common::protocol::Position* position_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static FloatConstant* default_instance_;
};
// -------------------------------------------------------------------

class DecimalConstant : public ::google::protobuf::Message {
 public:
  DecimalConstant();
  virtual ~DecimalConstant();

  DecimalConstant(const DecimalConstant& from);

  inline DecimalConstant& operator=(const DecimalConstant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecimalConstant& default_instance();

  void Swap(DecimalConstant* other);

  // implements Message ----------------------------------------------

  DecimalConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecimalConstant& from);
  void MergeFrom(const DecimalConstant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // required .blox.common.protocol.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::blox::common::protocol::Type& type() const;
  inline ::blox::common::protocol::Type* mutable_type();
  inline ::blox::common::protocol::Type* release_type();
  inline void set_allocated_type(::blox::common::protocol::Type* type);

  // optional .blox.common.protocol.Position position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  inline void set_allocated_position(::blox::common::protocol::Position* position);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.DecimalConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::blox::common::protocol::Type* type_;
  ::blox::common::protocol::Position* position_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static DecimalConstant* default_instance_;
};
// -------------------------------------------------------------------

class Int128Constant : public ::google::protobuf::Message {
 public:
  Int128Constant();
  virtual ~Int128Constant();

  Int128Constant(const Int128Constant& from);

  inline Int128Constant& operator=(const Int128Constant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Int128Constant& default_instance();

  void Swap(Int128Constant* other);

  // implements Message ----------------------------------------------

  Int128Constant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Int128Constant& from);
  void MergeFrom(const Int128Constant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // required .blox.common.protocol.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::blox::common::protocol::Type& type() const;
  inline ::blox::common::protocol::Type* mutable_type();
  inline ::blox::common::protocol::Type* release_type();
  inline void set_allocated_type(::blox::common::protocol::Type* type);

  // optional .blox.common.protocol.Position position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  inline void set_allocated_position(::blox::common::protocol::Position* position);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.Int128Constant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::blox::common::protocol::Type* type_;
  ::blox::common::protocol::Position* position_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static Int128Constant* default_instance_;
};
// -------------------------------------------------------------------

class StringConstant : public ::google::protobuf::Message {
 public:
  StringConstant();
  virtual ~StringConstant();

  StringConstant(const StringConstant& from);

  inline StringConstant& operator=(const StringConstant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringConstant& default_instance();

  void Swap(StringConstant* other);

  // implements Message ----------------------------------------------

  StringConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringConstant& from);
  void MergeFrom(const StringConstant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional .blox.common.protocol.Position position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  inline void set_allocated_position(::blox::common::protocol::Position* position);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.StringConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::blox::common::protocol::Position* position_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static StringConstant* default_instance_;
};
// -------------------------------------------------------------------

class DateTimeConstant : public ::google::protobuf::Message {
 public:
  DateTimeConstant();
  virtual ~DateTimeConstant();

  DateTimeConstant(const DateTimeConstant& from);

  inline DateTimeConstant& operator=(const DateTimeConstant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DateTimeConstant& default_instance();

  void Swap(DateTimeConstant* other);

  // implements Message ----------------------------------------------

  DateTimeConstant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DateTimeConstant& from);
  void MergeFrom(const DateTimeConstant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // optional .blox.common.protocol.Position position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::blox::common::protocol::Position& position() const;
  inline ::blox::common::protocol::Position* mutable_position();
  inline ::blox::common::protocol::Position* release_position();
  inline void set_allocated_position(::blox::common::protocol::Position* position);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.DateTimeConstant)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 value_;
  ::blox::common::protocol::Position* position_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static DateTimeConstant* default_instance_;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::Message {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Type& default_instance();

  void Swap(Type* other);

  // implements Message ----------------------------------------------

  Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Type_Kind Kind;
  static const Kind PRIMITIVE = Type_Kind_PRIMITIVE;
  static const Kind UNARY = Type_Kind_UNARY;
  static inline bool Kind_IsValid(int value) {
    return Type_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    Type_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    Type_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    Type_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return Type_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return Type_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return Type_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .blox.common.protocol.Type.Kind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::blox::common::protocol::Type_Kind kind() const;
  inline void set_kind(::blox::common::protocol::Type_Kind value);

  // optional .blox.common.protocol.PrimitiveType primitive = 2;
  inline bool has_primitive() const;
  inline void clear_primitive();
  static const int kPrimitiveFieldNumber = 2;
  inline const ::blox::common::protocol::PrimitiveType& primitive() const;
  inline ::blox::common::protocol::PrimitiveType* mutable_primitive();
  inline ::blox::common::protocol::PrimitiveType* release_primitive();
  inline void set_allocated_primitive(::blox::common::protocol::PrimitiveType* primitive);

  // optional .blox.common.protocol.UnaryPredicateType unary = 3;
  inline bool has_unary() const;
  inline void clear_unary();
  static const int kUnaryFieldNumber = 3;
  inline const ::blox::common::protocol::UnaryPredicateType& unary() const;
  inline ::blox::common::protocol::UnaryPredicateType* mutable_unary();
  inline ::blox::common::protocol::UnaryPredicateType* release_unary();
  inline void set_allocated_unary(::blox::common::protocol::UnaryPredicateType* unary);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.Type)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_primitive();
  inline void clear_has_primitive();
  inline void set_has_unary();
  inline void clear_has_unary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::blox::common::protocol::PrimitiveType* primitive_;
  ::blox::common::protocol::UnaryPredicateType* unary_;
  int kind_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static Type* default_instance_;
};
// -------------------------------------------------------------------

class PrimitiveType : public ::google::protobuf::Message {
 public:
  PrimitiveType();
  virtual ~PrimitiveType();

  PrimitiveType(const PrimitiveType& from);

  inline PrimitiveType& operator=(const PrimitiveType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrimitiveType& default_instance();

  void Swap(PrimitiveType* other);

  // implements Message ----------------------------------------------

  PrimitiveType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrimitiveType& from);
  void MergeFrom(const PrimitiveType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PrimitiveType_Kind Kind;
  static const Kind BOOL = PrimitiveType_Kind_BOOL;
  static const Kind DECIMAL = PrimitiveType_Kind_DECIMAL;
  static const Kind SHAPE = PrimitiveType_Kind_SHAPE;
  static const Kind IMAGE = PrimitiveType_Kind_IMAGE;
  static const Kind BLOB = PrimitiveType_Kind_BLOB;
  static const Kind DATETIME = PrimitiveType_Kind_DATETIME;
  static const Kind INT = PrimitiveType_Kind_INT;
  static const Kind UINT = PrimitiveType_Kind_UINT;
  static const Kind FLOAT = PrimitiveType_Kind_FLOAT;
  static const Kind STRING = PrimitiveType_Kind_STRING;
  static const Kind INT128 = PrimitiveType_Kind_INT128;
  static inline bool Kind_IsValid(int value) {
    return PrimitiveType_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    PrimitiveType_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    PrimitiveType_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    PrimitiveType_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return PrimitiveType_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return PrimitiveType_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return PrimitiveType_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .blox.common.protocol.PrimitiveType.Kind kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::blox::common::protocol::PrimitiveType_Kind kind() const;
  inline void set_kind(::blox::common::protocol::PrimitiveType_Kind value);

  // optional int64 capacity = 2;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 2;
  inline ::google::protobuf::int64 capacity() const;
  inline void set_capacity(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.PrimitiveType)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_capacity();
  inline void clear_has_capacity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 capacity_;
  int kind_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static PrimitiveType* default_instance_;
};
// -------------------------------------------------------------------

class UnaryPredicateType : public ::google::protobuf::Message {
 public:
  UnaryPredicateType();
  virtual ~UnaryPredicateType();

  UnaryPredicateType(const UnaryPredicateType& from);

  inline UnaryPredicateType& operator=(const UnaryPredicateType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnaryPredicateType& default_instance();

  void Swap(UnaryPredicateType* other);

  // implements Message ----------------------------------------------

  UnaryPredicateType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnaryPredicateType& from);
  void MergeFrom(const UnaryPredicateType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:blox.common.protocol.UnaryPredicateType)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_AssignDesc_blox_2fcommon_2fCommon_2eproto();
  friend void protobuf_ShutdownFile_blox_2fcommon_2fCommon_2eproto();

  void InitAsDefaultInstance();
  static UnaryPredicateType* default_instance_;
};
// ===================================================================


// ===================================================================

// CompilationProblems

// repeated .blox.common.protocol.Problem error = 1;
inline int CompilationProblems::error_size() const {
  return error_.size();
}
inline void CompilationProblems::clear_error() {
  error_.Clear();
}
inline const ::blox::common::protocol::Problem& CompilationProblems::error(int index) const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.CompilationProblems.error)
  return error_.Get(index);
}
inline ::blox::common::protocol::Problem* CompilationProblems::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.CompilationProblems.error)
  return error_.Mutable(index);
}
inline ::blox::common::protocol::Problem* CompilationProblems::add_error() {
  // @@protoc_insertion_point(field_add:blox.common.protocol.CompilationProblems.error)
  return error_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >&
CompilationProblems::error() const {
  // @@protoc_insertion_point(field_list:blox.common.protocol.CompilationProblems.error)
  return error_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >*
CompilationProblems::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:blox.common.protocol.CompilationProblems.error)
  return &error_;
}

// repeated .blox.common.protocol.Problem warning = 2;
inline int CompilationProblems::warning_size() const {
  return warning_.size();
}
inline void CompilationProblems::clear_warning() {
  warning_.Clear();
}
inline const ::blox::common::protocol::Problem& CompilationProblems::warning(int index) const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.CompilationProblems.warning)
  return warning_.Get(index);
}
inline ::blox::common::protocol::Problem* CompilationProblems::mutable_warning(int index) {
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.CompilationProblems.warning)
  return warning_.Mutable(index);
}
inline ::blox::common::protocol::Problem* CompilationProblems::add_warning() {
  // @@protoc_insertion_point(field_add:blox.common.protocol.CompilationProblems.warning)
  return warning_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >&
CompilationProblems::warning() const {
  // @@protoc_insertion_point(field_list:blox.common.protocol.CompilationProblems.warning)
  return warning_;
}
inline ::google::protobuf::RepeatedPtrField< ::blox::common::protocol::Problem >*
CompilationProblems::mutable_warning() {
  // @@protoc_insertion_point(field_mutable_list:blox.common.protocol.CompilationProblems.warning)
  return &warning_;
}

// -------------------------------------------------------------------

// Problem

// optional string code = 1;
inline bool Problem::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Problem::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Problem::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Problem::clear_code() {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& Problem::code() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Problem.code)
  return *code_;
}
inline void Problem::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.Problem.code)
}
inline void Problem::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.Problem.code)
}
inline void Problem::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.Problem.code)
}
inline ::std::string* Problem::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Problem.code)
  return code_;
}
inline ::std::string* Problem::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Problem::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Problem.code)
}

// required string msg = 2;
inline bool Problem::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Problem::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Problem::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Problem::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& Problem::msg() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Problem.msg)
  return *msg_;
}
inline void Problem::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.Problem.msg)
}
inline void Problem::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.Problem.msg)
}
inline void Problem::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.Problem.msg)
}
inline ::std::string* Problem::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Problem.msg)
  return msg_;
}
inline ::std::string* Problem::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Problem::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Problem.msg)
}

// required .blox.common.protocol.Position position = 4;
inline bool Problem::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Problem::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Problem::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Problem::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& Problem::position() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Problem.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* Problem::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Problem.position)
  return position_;
}
inline ::blox::common::protocol::Position* Problem::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Problem::set_allocated_position(::blox::common::protocol::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Problem.position)
}

// required .blox.common.protocol.Severity severity_code = 5;
inline bool Problem::has_severity_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Problem::set_has_severity_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Problem::clear_has_severity_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Problem::clear_severity_code() {
  severity_code_ = 0;
  clear_has_severity_code();
}
inline ::blox::common::protocol::Severity Problem::severity_code() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Problem.severity_code)
  return static_cast< ::blox::common::protocol::Severity >(severity_code_);
}
inline void Problem::set_severity_code(::blox::common::protocol::Severity value) {
  assert(::blox::common::protocol::Severity_IsValid(value));
  set_has_severity_code();
  severity_code_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.Problem.severity_code)
}

// optional string quote = 7;
inline bool Problem::has_quote() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Problem::set_has_quote() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Problem::clear_has_quote() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Problem::clear_quote() {
  if (quote_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quote_->clear();
  }
  clear_has_quote();
}
inline const ::std::string& Problem::quote() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Problem.quote)
  return *quote_;
}
inline void Problem::set_quote(const ::std::string& value) {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quote_ = new ::std::string;
  }
  quote_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.Problem.quote)
}
inline void Problem::set_quote(const char* value) {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quote_ = new ::std::string;
  }
  quote_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.Problem.quote)
}
inline void Problem::set_quote(const char* value, size_t size) {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quote_ = new ::std::string;
  }
  quote_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.Problem.quote)
}
inline ::std::string* Problem::mutable_quote() {
  set_has_quote();
  if (quote_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quote_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Problem.quote)
  return quote_;
}
inline ::std::string* Problem::release_quote() {
  clear_has_quote();
  if (quote_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = quote_;
    quote_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Problem::set_allocated_quote(::std::string* quote) {
  if (quote_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete quote_;
  }
  if (quote) {
    set_has_quote();
    quote_ = quote;
  } else {
    clear_has_quote();
    quote_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Problem.quote)
}

// -------------------------------------------------------------------

// Position

// required int64 start_line = 1;
inline bool Position::has_start_line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_start_line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_start_line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_start_line() {
  start_line_ = GOOGLE_LONGLONG(0);
  clear_has_start_line();
}
inline ::google::protobuf::int64 Position::start_line() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Position.start_line)
  return start_line_;
}
inline void Position::set_start_line(::google::protobuf::int64 value) {
  set_has_start_line();
  start_line_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.Position.start_line)
}

// required int64 start_column = 2;
inline bool Position::has_start_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_start_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_start_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_start_column() {
  start_column_ = GOOGLE_LONGLONG(0);
  clear_has_start_column();
}
inline ::google::protobuf::int64 Position::start_column() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Position.start_column)
  return start_column_;
}
inline void Position::set_start_column(::google::protobuf::int64 value) {
  set_has_start_column();
  start_column_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.Position.start_column)
}

// optional int64 end_line = 3;
inline bool Position::has_end_line() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_end_line() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_end_line() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_end_line() {
  end_line_ = GOOGLE_LONGLONG(0);
  clear_has_end_line();
}
inline ::google::protobuf::int64 Position::end_line() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Position.end_line)
  return end_line_;
}
inline void Position::set_end_line(::google::protobuf::int64 value) {
  set_has_end_line();
  end_line_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.Position.end_line)
}

// optional int64 end_column = 4;
inline bool Position::has_end_column() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Position::set_has_end_column() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Position::clear_has_end_column() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Position::clear_end_column() {
  end_column_ = GOOGLE_LONGLONG(0);
  clear_has_end_column();
}
inline ::google::protobuf::int64 Position::end_column() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Position.end_column)
  return end_column_;
}
inline void Position::set_end_column(::google::protobuf::int64 value) {
  set_has_end_column();
  end_column_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.Position.end_column)
}

// optional int64 start_offset = 5;
inline bool Position::has_start_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Position::set_has_start_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Position::clear_has_start_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Position::clear_start_offset() {
  start_offset_ = GOOGLE_LONGLONG(0);
  clear_has_start_offset();
}
inline ::google::protobuf::int64 Position::start_offset() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Position.start_offset)
  return start_offset_;
}
inline void Position::set_start_offset(::google::protobuf::int64 value) {
  set_has_start_offset();
  start_offset_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.Position.start_offset)
}

// optional int64 end_offset = 6;
inline bool Position::has_end_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Position::set_has_end_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Position::clear_has_end_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Position::clear_end_offset() {
  end_offset_ = GOOGLE_LONGLONG(0);
  clear_has_end_offset();
}
inline ::google::protobuf::int64 Position::end_offset() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Position.end_offset)
  return end_offset_;
}
inline void Position::set_end_offset(::google::protobuf::int64 value) {
  set_has_end_offset();
  end_offset_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.Position.end_offset)
}

// required string block_name = 7;
inline bool Position::has_block_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Position::set_has_block_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Position::clear_has_block_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Position::clear_block_name() {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_->clear();
  }
  clear_has_block_name();
}
inline const ::std::string& Position::block_name() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Position.block_name)
  return *block_name_;
}
inline void Position::set_block_name(const ::std::string& value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.Position.block_name)
}
inline void Position::set_block_name(const char* value) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.Position.block_name)
}
inline void Position::set_block_name(const char* value, size_t size) {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  block_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.Position.block_name)
}
inline ::std::string* Position::mutable_block_name() {
  set_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    block_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Position.block_name)
  return block_name_;
}
inline ::std::string* Position::release_block_name() {
  clear_has_block_name();
  if (block_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = block_name_;
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Position::set_allocated_block_name(::std::string* block_name) {
  if (block_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete block_name_;
  }
  if (block_name) {
    set_has_block_name();
    block_name_ = block_name;
  } else {
    clear_has_block_name();
    block_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Position.block_name)
}

// optional string file_name = 8;
inline bool Position::has_file_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Position::set_has_file_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Position::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Position::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& Position::file_name() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Position.file_name)
  return *file_name_;
}
inline void Position::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.Position.file_name)
}
inline void Position::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.Position.file_name)
}
inline void Position::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.Position.file_name)
}
inline ::std::string* Position::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Position.file_name)
  return file_name_;
}
inline ::std::string* Position::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Position::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Position.file_name)
}

// -------------------------------------------------------------------

// PredicateInfo

// required string name = 1;
inline bool PredicateInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredicateInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredicateInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredicateInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PredicateInfo::name() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.name)
  return *name_;
}
inline void PredicateInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.name)
}
inline void PredicateInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.name)
}
inline void PredicateInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.name)
}
inline ::std::string* PredicateInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.name)
  return name_;
}
inline ::std::string* PredicateInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.name)
}

// required string qualified_name = 2;
inline bool PredicateInfo::has_qualified_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredicateInfo::set_has_qualified_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredicateInfo::clear_has_qualified_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PredicateInfo::clear_qualified_name() {
  if (qualified_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_->clear();
  }
  clear_has_qualified_name();
}
inline const ::std::string& PredicateInfo::qualified_name() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.qualified_name)
  return *qualified_name_;
}
inline void PredicateInfo::set_qualified_name(const ::std::string& value) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.qualified_name)
}
inline void PredicateInfo::set_qualified_name(const char* value) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.qualified_name)
}
inline void PredicateInfo::set_qualified_name(const char* value, size_t size) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.qualified_name)
}
inline ::std::string* PredicateInfo::mutable_qualified_name() {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.qualified_name)
  return qualified_name_;
}
inline ::std::string* PredicateInfo::release_qualified_name() {
  clear_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = qualified_name_;
    qualified_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_qualified_name(::std::string* qualified_name) {
  if (qualified_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete qualified_name_;
  }
  if (qualified_name) {
    set_has_qualified_name();
    qualified_name_ = qualified_name;
  } else {
    clear_has_qualified_name();
    qualified_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.qualified_name)
}

// required int64 arity = 3;
inline bool PredicateInfo::has_arity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PredicateInfo::set_has_arity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PredicateInfo::clear_has_arity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PredicateInfo::clear_arity() {
  arity_ = GOOGLE_LONGLONG(0);
  clear_has_arity();
}
inline ::google::protobuf::int64 PredicateInfo::arity() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.arity)
  return arity_;
}
inline void PredicateInfo::set_arity(::google::protobuf::int64 value) {
  set_has_arity();
  arity_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.arity)
}

// required int64 key_arity = 4;
inline bool PredicateInfo::has_key_arity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PredicateInfo::set_has_key_arity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PredicateInfo::clear_has_key_arity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PredicateInfo::clear_key_arity() {
  key_arity_ = GOOGLE_LONGLONG(0);
  clear_has_key_arity();
}
inline ::google::protobuf::int64 PredicateInfo::key_arity() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.key_arity)
  return key_arity_;
}
inline void PredicateInfo::set_key_arity(::google::protobuf::int64 value) {
  set_has_key_arity();
  key_arity_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.key_arity)
}

// required int64 value_arity = 5;
inline bool PredicateInfo::has_value_arity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PredicateInfo::set_has_value_arity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PredicateInfo::clear_has_value_arity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PredicateInfo::clear_value_arity() {
  value_arity_ = GOOGLE_LONGLONG(0);
  clear_has_value_arity();
}
inline ::google::protobuf::int64 PredicateInfo::value_arity() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.value_arity)
  return value_arity_;
}
inline void PredicateInfo::set_value_arity(::google::protobuf::int64 value) {
  set_has_value_arity();
  value_arity_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.value_arity)
}

// repeated string key_argument = 6;
inline int PredicateInfo::key_argument_size() const {
  return key_argument_.size();
}
inline void PredicateInfo::clear_key_argument() {
  key_argument_.Clear();
}
inline const ::std::string& PredicateInfo::key_argument(int index) const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.key_argument)
  return key_argument_.Get(index);
}
inline ::std::string* PredicateInfo::mutable_key_argument(int index) {
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.key_argument)
  return key_argument_.Mutable(index);
}
inline void PredicateInfo::set_key_argument(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.key_argument)
  key_argument_.Mutable(index)->assign(value);
}
inline void PredicateInfo::set_key_argument(int index, const char* value) {
  key_argument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.key_argument)
}
inline void PredicateInfo::set_key_argument(int index, const char* value, size_t size) {
  key_argument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.key_argument)
}
inline ::std::string* PredicateInfo::add_key_argument() {
  return key_argument_.Add();
}
inline void PredicateInfo::add_key_argument(const ::std::string& value) {
  key_argument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.common.protocol.PredicateInfo.key_argument)
}
inline void PredicateInfo::add_key_argument(const char* value) {
  key_argument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.common.protocol.PredicateInfo.key_argument)
}
inline void PredicateInfo::add_key_argument(const char* value, size_t size) {
  key_argument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.common.protocol.PredicateInfo.key_argument)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PredicateInfo::key_argument() const {
  // @@protoc_insertion_point(field_list:blox.common.protocol.PredicateInfo.key_argument)
  return key_argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PredicateInfo::mutable_key_argument() {
  // @@protoc_insertion_point(field_mutable_list:blox.common.protocol.PredicateInfo.key_argument)
  return &key_argument_;
}

// repeated string value_argument = 7;
inline int PredicateInfo::value_argument_size() const {
  return value_argument_.size();
}
inline void PredicateInfo::clear_value_argument() {
  value_argument_.Clear();
}
inline const ::std::string& PredicateInfo::value_argument(int index) const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.value_argument)
  return value_argument_.Get(index);
}
inline ::std::string* PredicateInfo::mutable_value_argument(int index) {
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.value_argument)
  return value_argument_.Mutable(index);
}
inline void PredicateInfo::set_value_argument(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.value_argument)
  value_argument_.Mutable(index)->assign(value);
}
inline void PredicateInfo::set_value_argument(int index, const char* value) {
  value_argument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.value_argument)
}
inline void PredicateInfo::set_value_argument(int index, const char* value, size_t size) {
  value_argument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.value_argument)
}
inline ::std::string* PredicateInfo::add_value_argument() {
  return value_argument_.Add();
}
inline void PredicateInfo::add_value_argument(const ::std::string& value) {
  value_argument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:blox.common.protocol.PredicateInfo.value_argument)
}
inline void PredicateInfo::add_value_argument(const char* value) {
  value_argument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:blox.common.protocol.PredicateInfo.value_argument)
}
inline void PredicateInfo::add_value_argument(const char* value, size_t size) {
  value_argument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:blox.common.protocol.PredicateInfo.value_argument)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PredicateInfo::value_argument() const {
  // @@protoc_insertion_point(field_list:blox.common.protocol.PredicateInfo.value_argument)
  return value_argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PredicateInfo::mutable_value_argument() {
  // @@protoc_insertion_point(field_mutable_list:blox.common.protocol.PredicateInfo.value_argument)
  return &value_argument_;
}

// required bool is_entity = 8 [default = false];
inline bool PredicateInfo::has_is_entity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PredicateInfo::set_has_is_entity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PredicateInfo::clear_has_is_entity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PredicateInfo::clear_is_entity() {
  is_entity_ = false;
  clear_has_is_entity();
}
inline bool PredicateInfo::is_entity() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_entity)
  return is_entity_;
}
inline void PredicateInfo::set_is_entity(bool value) {
  set_has_is_entity();
  is_entity_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_entity)
}

// required bool is_ref_mode = 9 [default = false];
inline bool PredicateInfo::has_is_ref_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PredicateInfo::set_has_is_ref_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PredicateInfo::clear_has_is_ref_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PredicateInfo::clear_is_ref_mode() {
  is_ref_mode_ = false;
  clear_has_is_ref_mode();
}
inline bool PredicateInfo::is_ref_mode() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_ref_mode)
  return is_ref_mode_;
}
inline void PredicateInfo::set_is_ref_mode(bool value) {
  set_has_is_ref_mode();
  is_ref_mode_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_ref_mode)
}

// required bool is_one_to_one = 10 [default = false];
inline bool PredicateInfo::has_is_one_to_one() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PredicateInfo::set_has_is_one_to_one() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PredicateInfo::clear_has_is_one_to_one() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PredicateInfo::clear_is_one_to_one() {
  is_one_to_one_ = false;
  clear_has_is_one_to_one();
}
inline bool PredicateInfo::is_one_to_one() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_one_to_one)
  return is_one_to_one_;
}
inline void PredicateInfo::set_is_one_to_one(bool value) {
  set_has_is_one_to_one();
  is_one_to_one_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_one_to_one)
}

// required bool is_ordered = 11 [default = false];
inline bool PredicateInfo::has_is_ordered() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PredicateInfo::set_has_is_ordered() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PredicateInfo::clear_has_is_ordered() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PredicateInfo::clear_is_ordered() {
  is_ordered_ = false;
  clear_has_is_ordered();
}
inline bool PredicateInfo::is_ordered() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_ordered)
  return is_ordered_;
}
inline void PredicateInfo::set_is_ordered(bool value) {
  set_has_is_ordered();
  is_ordered_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_ordered)
}

// required bool has_default_value = 12 [default = false];
inline bool PredicateInfo::has_has_default_value() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PredicateInfo::set_has_has_default_value() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PredicateInfo::clear_has_has_default_value() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PredicateInfo::clear_has_default_value() {
  has_default_value_ = false;
  clear_has_has_default_value();
}
inline bool PredicateInfo::has_default_value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.has_default_value)
  return has_default_value_;
}
inline void PredicateInfo::set_has_default_value(bool value) {
  set_has_has_default_value();
  has_default_value_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.has_default_value)
}

// required bool is_subtype = 14 [default = false];
inline bool PredicateInfo::has_is_subtype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PredicateInfo::set_has_is_subtype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PredicateInfo::clear_has_is_subtype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PredicateInfo::clear_is_subtype() {
  is_subtype_ = false;
  clear_has_is_subtype();
}
inline bool PredicateInfo::is_subtype() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_subtype)
  return is_subtype_;
}
inline void PredicateInfo::set_is_subtype(bool value) {
  set_has_is_subtype();
  is_subtype_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_subtype)
}

// optional string supertype = 15;
inline bool PredicateInfo::has_supertype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PredicateInfo::set_has_supertype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PredicateInfo::clear_has_supertype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PredicateInfo::clear_supertype() {
  if (supertype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supertype_->clear();
  }
  clear_has_supertype();
}
inline const ::std::string& PredicateInfo::supertype() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.supertype)
  return *supertype_;
}
inline void PredicateInfo::set_supertype(const ::std::string& value) {
  set_has_supertype();
  if (supertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supertype_ = new ::std::string;
  }
  supertype_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.supertype)
}
inline void PredicateInfo::set_supertype(const char* value) {
  set_has_supertype();
  if (supertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supertype_ = new ::std::string;
  }
  supertype_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.supertype)
}
inline void PredicateInfo::set_supertype(const char* value, size_t size) {
  set_has_supertype();
  if (supertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supertype_ = new ::std::string;
  }
  supertype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.supertype)
}
inline ::std::string* PredicateInfo::mutable_supertype() {
  set_has_supertype();
  if (supertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supertype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.supertype)
  return supertype_;
}
inline ::std::string* PredicateInfo::release_supertype() {
  clear_has_supertype();
  if (supertype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = supertype_;
    supertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_supertype(::std::string* supertype) {
  if (supertype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete supertype_;
  }
  if (supertype) {
    set_has_supertype();
    supertype_ = supertype;
  } else {
    clear_has_supertype();
    supertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.supertype)
}

// optional string toptype = 42;
inline bool PredicateInfo::has_toptype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PredicateInfo::set_has_toptype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PredicateInfo::clear_has_toptype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PredicateInfo::clear_toptype() {
  if (toptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    toptype_->clear();
  }
  clear_has_toptype();
}
inline const ::std::string& PredicateInfo::toptype() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.toptype)
  return *toptype_;
}
inline void PredicateInfo::set_toptype(const ::std::string& value) {
  set_has_toptype();
  if (toptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    toptype_ = new ::std::string;
  }
  toptype_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.toptype)
}
inline void PredicateInfo::set_toptype(const char* value) {
  set_has_toptype();
  if (toptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    toptype_ = new ::std::string;
  }
  toptype_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.toptype)
}
inline void PredicateInfo::set_toptype(const char* value, size_t size) {
  set_has_toptype();
  if (toptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    toptype_ = new ::std::string;
  }
  toptype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.toptype)
}
inline ::std::string* PredicateInfo::mutable_toptype() {
  set_has_toptype();
  if (toptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    toptype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.toptype)
  return toptype_;
}
inline ::std::string* PredicateInfo::release_toptype() {
  clear_has_toptype();
  if (toptype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = toptype_;
    toptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_toptype(::std::string* toptype) {
  if (toptype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete toptype_;
  }
  if (toptype) {
    set_has_toptype();
    toptype_ = toptype;
  } else {
    clear_has_toptype();
    toptype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.toptype)
}

// required bool has_ref_mode = 16 [default = false];
inline bool PredicateInfo::has_has_ref_mode() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PredicateInfo::set_has_has_ref_mode() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PredicateInfo::clear_has_has_ref_mode() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PredicateInfo::clear_has_ref_mode() {
  has_ref_mode_ = false;
  clear_has_has_ref_mode();
}
inline bool PredicateInfo::has_ref_mode() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.has_ref_mode)
  return has_ref_mode_;
}
inline void PredicateInfo::set_has_ref_mode(bool value) {
  set_has_has_ref_mode();
  has_ref_mode_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.has_ref_mode)
}

// optional string ref_mode_name = 17;
inline bool PredicateInfo::has_ref_mode_name() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PredicateInfo::set_has_ref_mode_name() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PredicateInfo::clear_has_ref_mode_name() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PredicateInfo::clear_ref_mode_name() {
  if (ref_mode_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_mode_name_->clear();
  }
  clear_has_ref_mode_name();
}
inline const ::std::string& PredicateInfo::ref_mode_name() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.ref_mode_name)
  return *ref_mode_name_;
}
inline void PredicateInfo::set_ref_mode_name(const ::std::string& value) {
  set_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_mode_name_ = new ::std::string;
  }
  ref_mode_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.ref_mode_name)
}
inline void PredicateInfo::set_ref_mode_name(const char* value) {
  set_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_mode_name_ = new ::std::string;
  }
  ref_mode_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.ref_mode_name)
}
inline void PredicateInfo::set_ref_mode_name(const char* value, size_t size) {
  set_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_mode_name_ = new ::std::string;
  }
  ref_mode_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.ref_mode_name)
}
inline ::std::string* PredicateInfo::mutable_ref_mode_name() {
  set_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_mode_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.ref_mode_name)
  return ref_mode_name_;
}
inline ::std::string* PredicateInfo::release_ref_mode_name() {
  clear_has_ref_mode_name();
  if (ref_mode_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ref_mode_name_;
    ref_mode_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_ref_mode_name(::std::string* ref_mode_name) {
  if (ref_mode_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ref_mode_name_;
  }
  if (ref_mode_name) {
    set_has_ref_mode_name();
    ref_mode_name_ = ref_mode_name;
  } else {
    clear_has_ref_mode_name();
    ref_mode_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.ref_mode_name)
}

// required bool is_meta_predicate = 18 [default = false];
inline bool PredicateInfo::has_is_meta_predicate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PredicateInfo::set_has_is_meta_predicate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PredicateInfo::clear_has_is_meta_predicate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PredicateInfo::clear_is_meta_predicate() {
  is_meta_predicate_ = false;
  clear_has_is_meta_predicate();
}
inline bool PredicateInfo::is_meta_predicate() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_meta_predicate)
  return is_meta_predicate_;
}
inline void PredicateInfo::set_is_meta_predicate(bool value) {
  set_has_is_meta_predicate();
  is_meta_predicate_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_meta_predicate)
}

// required bool is_pulse_predicate = 19 [default = false];
inline bool PredicateInfo::has_is_pulse_predicate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PredicateInfo::set_has_is_pulse_predicate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PredicateInfo::clear_has_is_pulse_predicate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PredicateInfo::clear_is_pulse_predicate() {
  is_pulse_predicate_ = false;
  clear_has_is_pulse_predicate();
}
inline bool PredicateInfo::is_pulse_predicate() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_pulse_predicate)
  return is_pulse_predicate_;
}
inline void PredicateInfo::set_is_pulse_predicate(bool value) {
  set_has_is_pulse_predicate();
  is_pulse_predicate_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_pulse_predicate)
}

// required bool is_calculated = 20 [default = false];
inline bool PredicateInfo::has_is_calculated() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PredicateInfo::set_has_is_calculated() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PredicateInfo::clear_has_is_calculated() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PredicateInfo::clear_is_calculated() {
  is_calculated_ = false;
  clear_has_is_calculated();
}
inline bool PredicateInfo::is_calculated() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_calculated)
  return is_calculated_;
}
inline void PredicateInfo::set_is_calculated(bool value) {
  set_has_is_calculated();
  is_calculated_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_calculated)
}

// required .blox.common.protocol.DerivationType derivation_type = 22;
inline bool PredicateInfo::has_derivation_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PredicateInfo::set_has_derivation_type() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PredicateInfo::clear_has_derivation_type() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PredicateInfo::clear_derivation_type() {
  derivation_type_ = 0;
  clear_has_derivation_type();
}
inline ::blox::common::protocol::DerivationType PredicateInfo::derivation_type() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.derivation_type)
  return static_cast< ::blox::common::protocol::DerivationType >(derivation_type_);
}
inline void PredicateInfo::set_derivation_type(::blox::common::protocol::DerivationType value) {
  assert(::blox::common::protocol::DerivationType_IsValid(value));
  set_has_derivation_type();
  derivation_type_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.derivation_type)
}

// optional bool is_built_in = 28 [default = false];
inline bool PredicateInfo::has_is_built_in() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PredicateInfo::set_has_is_built_in() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PredicateInfo::clear_has_is_built_in() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PredicateInfo::clear_is_built_in() {
  is_built_in_ = false;
  clear_has_is_built_in();
}
inline bool PredicateInfo::is_built_in() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_built_in)
  return is_built_in_;
}
inline void PredicateInfo::set_is_built_in(bool value) {
  set_has_is_built_in();
  is_built_in_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_built_in)
}

// required .blox.common.protocol.Lifetime lifetime = 30;
inline bool PredicateInfo::has_lifetime() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PredicateInfo::set_has_lifetime() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PredicateInfo::clear_has_lifetime() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PredicateInfo::clear_lifetime() {
  lifetime_ = 1;
  clear_has_lifetime();
}
inline ::blox::common::protocol::Lifetime PredicateInfo::lifetime() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.lifetime)
  return static_cast< ::blox::common::protocol::Lifetime >(lifetime_);
}
inline void PredicateInfo::set_lifetime(::blox::common::protocol::Lifetime value) {
  assert(::blox::common::protocol::Lifetime_IsValid(value));
  set_has_lifetime();
  lifetime_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.lifetime)
}

// required bool is_auto_numbered = 31;
inline bool PredicateInfo::has_is_auto_numbered() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PredicateInfo::set_has_is_auto_numbered() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PredicateInfo::clear_has_is_auto_numbered() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PredicateInfo::clear_is_auto_numbered() {
  is_auto_numbered_ = false;
  clear_has_is_auto_numbered();
}
inline bool PredicateInfo::is_auto_numbered() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_auto_numbered)
  return is_auto_numbered_;
}
inline void PredicateInfo::set_is_auto_numbered(bool value) {
  set_has_is_auto_numbered();
  is_auto_numbered_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_auto_numbered)
}

// optional .blox.common.protocol.Constant actual_default_value = 32;
inline bool PredicateInfo::has_actual_default_value() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PredicateInfo::set_has_actual_default_value() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PredicateInfo::clear_has_actual_default_value() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PredicateInfo::clear_actual_default_value() {
  if (actual_default_value_ != NULL) actual_default_value_->::blox::common::protocol::Constant::Clear();
  clear_has_actual_default_value();
}
inline const ::blox::common::protocol::Constant& PredicateInfo::actual_default_value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.actual_default_value)
  return actual_default_value_ != NULL ? *actual_default_value_ : *default_instance_->actual_default_value_;
}
inline ::blox::common::protocol::Constant* PredicateInfo::mutable_actual_default_value() {
  set_has_actual_default_value();
  if (actual_default_value_ == NULL) actual_default_value_ = new ::blox::common::protocol::Constant;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.actual_default_value)
  return actual_default_value_;
}
inline ::blox::common::protocol::Constant* PredicateInfo::release_actual_default_value() {
  clear_has_actual_default_value();
  ::blox::common::protocol::Constant* temp = actual_default_value_;
  actual_default_value_ = NULL;
  return temp;
}
inline void PredicateInfo::set_allocated_actual_default_value(::blox::common::protocol::Constant* actual_default_value) {
  delete actual_default_value_;
  actual_default_value_ = actual_default_value;
  if (actual_default_value) {
    set_has_actual_default_value();
  } else {
    clear_has_actual_default_value();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.actual_default_value)
}

// optional string file_path = 33;
inline bool PredicateInfo::has_file_path() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PredicateInfo::set_has_file_path() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PredicateInfo::clear_has_file_path() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PredicateInfo::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& PredicateInfo::file_path() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.file_path)
  return *file_path_;
}
inline void PredicateInfo::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.file_path)
}
inline void PredicateInfo::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.file_path)
}
inline void PredicateInfo::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.file_path)
}
inline ::std::string* PredicateInfo::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.file_path)
  return file_path_;
}
inline ::std::string* PredicateInfo::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.file_path)
}

// optional string file_mode = 45;
inline bool PredicateInfo::has_file_mode() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PredicateInfo::set_has_file_mode() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PredicateInfo::clear_has_file_mode() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PredicateInfo::clear_file_mode() {
  if (file_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_mode_->clear();
  }
  clear_has_file_mode();
}
inline const ::std::string& PredicateInfo::file_mode() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.file_mode)
  return *file_mode_;
}
inline void PredicateInfo::set_file_mode(const ::std::string& value) {
  set_has_file_mode();
  if (file_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_mode_ = new ::std::string;
  }
  file_mode_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.file_mode)
}
inline void PredicateInfo::set_file_mode(const char* value) {
  set_has_file_mode();
  if (file_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_mode_ = new ::std::string;
  }
  file_mode_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.file_mode)
}
inline void PredicateInfo::set_file_mode(const char* value, size_t size) {
  set_has_file_mode();
  if (file_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_mode_ = new ::std::string;
  }
  file_mode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.file_mode)
}
inline ::std::string* PredicateInfo::mutable_file_mode() {
  set_has_file_mode();
  if (file_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_mode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.file_mode)
  return file_mode_;
}
inline ::std::string* PredicateInfo::release_file_mode() {
  clear_has_file_mode();
  if (file_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_mode_;
    file_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_file_mode(::std::string* file_mode) {
  if (file_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_mode_;
  }
  if (file_mode) {
    set_has_file_mode();
    file_mode_ = file_mode;
  } else {
    clear_has_file_mode();
    file_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.file_mode)
}

// optional string delimiter = 34;
inline bool PredicateInfo::has_delimiter() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PredicateInfo::set_has_delimiter() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PredicateInfo::clear_has_delimiter() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PredicateInfo::clear_delimiter() {
  if (delimiter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delimiter_->clear();
  }
  clear_has_delimiter();
}
inline const ::std::string& PredicateInfo::delimiter() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.delimiter)
  return *delimiter_;
}
inline void PredicateInfo::set_delimiter(const ::std::string& value) {
  set_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delimiter_ = new ::std::string;
  }
  delimiter_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.delimiter)
}
inline void PredicateInfo::set_delimiter(const char* value) {
  set_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delimiter_ = new ::std::string;
  }
  delimiter_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.delimiter)
}
inline void PredicateInfo::set_delimiter(const char* value, size_t size) {
  set_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delimiter_ = new ::std::string;
  }
  delimiter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.delimiter)
}
inline ::std::string* PredicateInfo::mutable_delimiter() {
  set_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delimiter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.delimiter)
  return delimiter_;
}
inline ::std::string* PredicateInfo::release_delimiter() {
  clear_has_delimiter();
  if (delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = delimiter_;
    delimiter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_delimiter(::std::string* delimiter) {
  if (delimiter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete delimiter_;
  }
  if (delimiter) {
    set_has_delimiter();
    delimiter_ = delimiter;
  } else {
    clear_has_delimiter();
    delimiter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.delimiter)
}

// optional bool has_column_names = 35;
inline bool PredicateInfo::has_has_column_names() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PredicateInfo::set_has_has_column_names() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PredicateInfo::clear_has_has_column_names() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PredicateInfo::clear_has_column_names() {
  has_column_names_ = false;
  clear_has_has_column_names();
}
inline bool PredicateInfo::has_column_names() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.has_column_names)
  return has_column_names_;
}
inline void PredicateInfo::set_has_column_names(bool value) {
  set_has_has_column_names();
  has_column_names_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.has_column_names)
}

// optional string delim_column_names = 36;
inline bool PredicateInfo::has_delim_column_names() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PredicateInfo::set_has_delim_column_names() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PredicateInfo::clear_has_delim_column_names() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PredicateInfo::clear_delim_column_names() {
  if (delim_column_names_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delim_column_names_->clear();
  }
  clear_has_delim_column_names();
}
inline const ::std::string& PredicateInfo::delim_column_names() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.delim_column_names)
  return *delim_column_names_;
}
inline void PredicateInfo::set_delim_column_names(const ::std::string& value) {
  set_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delim_column_names_ = new ::std::string;
  }
  delim_column_names_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.delim_column_names)
}
inline void PredicateInfo::set_delim_column_names(const char* value) {
  set_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delim_column_names_ = new ::std::string;
  }
  delim_column_names_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.delim_column_names)
}
inline void PredicateInfo::set_delim_column_names(const char* value, size_t size) {
  set_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delim_column_names_ = new ::std::string;
  }
  delim_column_names_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.delim_column_names)
}
inline ::std::string* PredicateInfo::mutable_delim_column_names() {
  set_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delim_column_names_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.delim_column_names)
  return delim_column_names_;
}
inline ::std::string* PredicateInfo::release_delim_column_names() {
  clear_has_delim_column_names();
  if (delim_column_names_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = delim_column_names_;
    delim_column_names_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_delim_column_names(::std::string* delim_column_names) {
  if (delim_column_names_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete delim_column_names_;
  }
  if (delim_column_names) {
    set_has_delim_column_names();
    delim_column_names_ = delim_column_names;
  } else {
    clear_has_delim_column_names();
    delim_column_names_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.delim_column_names)
}

// optional bool is_sealed = 37 [default = false];
inline bool PredicateInfo::has_is_sealed() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PredicateInfo::set_has_is_sealed() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PredicateInfo::clear_has_is_sealed() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PredicateInfo::clear_is_sealed() {
  is_sealed_ = false;
  clear_has_is_sealed();
}
inline bool PredicateInfo::is_sealed() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_sealed)
  return is_sealed_;
}
inline void PredicateInfo::set_is_sealed(bool value) {
  set_has_is_sealed();
  is_sealed_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_sealed)
}

// optional string local_name = 38;
inline bool PredicateInfo::has_local_name() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PredicateInfo::set_has_local_name() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PredicateInfo::clear_has_local_name() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PredicateInfo::clear_local_name() {
  if (local_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_->clear();
  }
  clear_has_local_name();
}
inline const ::std::string& PredicateInfo::local_name() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.local_name)
  return *local_name_;
}
inline void PredicateInfo::set_local_name(const ::std::string& value) {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_ = new ::std::string;
  }
  local_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.local_name)
}
inline void PredicateInfo::set_local_name(const char* value) {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_ = new ::std::string;
  }
  local_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.local_name)
}
inline void PredicateInfo::set_local_name(const char* value, size_t size) {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_ = new ::std::string;
  }
  local_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.local_name)
}
inline ::std::string* PredicateInfo::mutable_local_name() {
  set_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    local_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.local_name)
  return local_name_;
}
inline ::std::string* PredicateInfo::release_local_name() {
  clear_has_local_name();
  if (local_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = local_name_;
    local_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_local_name(::std::string* local_name) {
  if (local_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete local_name_;
  }
  if (local_name) {
    set_has_local_name();
    local_name_ = local_name;
  } else {
    clear_has_local_name();
    local_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.local_name)
}

// optional string definition_block = 44;
inline bool PredicateInfo::has_definition_block() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PredicateInfo::set_has_definition_block() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PredicateInfo::clear_has_definition_block() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PredicateInfo::clear_definition_block() {
  if (definition_block_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    definition_block_->clear();
  }
  clear_has_definition_block();
}
inline const ::std::string& PredicateInfo::definition_block() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.definition_block)
  return *definition_block_;
}
inline void PredicateInfo::set_definition_block(const ::std::string& value) {
  set_has_definition_block();
  if (definition_block_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    definition_block_ = new ::std::string;
  }
  definition_block_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.definition_block)
}
inline void PredicateInfo::set_definition_block(const char* value) {
  set_has_definition_block();
  if (definition_block_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    definition_block_ = new ::std::string;
  }
  definition_block_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.definition_block)
}
inline void PredicateInfo::set_definition_block(const char* value, size_t size) {
  set_has_definition_block();
  if (definition_block_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    definition_block_ = new ::std::string;
  }
  definition_block_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.definition_block)
}
inline ::std::string* PredicateInfo::mutable_definition_block() {
  set_has_definition_block();
  if (definition_block_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    definition_block_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.definition_block)
  return definition_block_;
}
inline ::std::string* PredicateInfo::release_definition_block() {
  clear_has_definition_block();
  if (definition_block_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = definition_block_;
    definition_block_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_definition_block(::std::string* definition_block) {
  if (definition_block_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete definition_block_;
  }
  if (definition_block) {
    set_has_definition_block();
    definition_block_ = definition_block;
  } else {
    clear_has_definition_block();
    definition_block_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.definition_block)
}

// optional string display_name = 39;
inline bool PredicateInfo::has_display_name() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PredicateInfo::set_has_display_name() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PredicateInfo::clear_has_display_name() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PredicateInfo::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& PredicateInfo::display_name() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.display_name)
  return *display_name_;
}
inline void PredicateInfo::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.display_name)
}
inline void PredicateInfo::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicateInfo.display_name)
}
inline void PredicateInfo::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicateInfo.display_name)
}
inline ::std::string* PredicateInfo::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicateInfo.display_name)
  return display_name_;
}
inline ::std::string* PredicateInfo::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicateInfo::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicateInfo.display_name)
}

// optional bool is_synthetic = 41;
inline bool PredicateInfo::has_is_synthetic() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PredicateInfo::set_has_is_synthetic() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PredicateInfo::clear_has_is_synthetic() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PredicateInfo::clear_is_synthetic() {
  is_synthetic_ = false;
  clear_has_is_synthetic();
}
inline bool PredicateInfo::is_synthetic() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_synthetic)
  return is_synthetic_;
}
inline void PredicateInfo::set_is_synthetic(bool value) {
  set_has_is_synthetic();
  is_synthetic_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_synthetic)
}

// optional bool is_constructor = 43;
inline bool PredicateInfo::has_is_constructor() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PredicateInfo::set_has_is_constructor() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PredicateInfo::clear_has_is_constructor() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PredicateInfo::clear_is_constructor() {
  is_constructor_ = false;
  clear_has_is_constructor();
}
inline bool PredicateInfo::is_constructor() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicateInfo.is_constructor)
  return is_constructor_;
}
inline void PredicateInfo::set_is_constructor(bool value) {
  set_has_is_constructor();
  is_constructor_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicateInfo.is_constructor)
}

// -------------------------------------------------------------------

// PredicatePopcount

// required string qualified_name = 1;
inline bool PredicatePopcount::has_qualified_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredicatePopcount::set_has_qualified_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredicatePopcount::clear_has_qualified_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredicatePopcount::clear_qualified_name() {
  if (qualified_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_->clear();
  }
  clear_has_qualified_name();
}
inline const ::std::string& PredicatePopcount::qualified_name() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicatePopcount.qualified_name)
  return *qualified_name_;
}
inline void PredicatePopcount::set_qualified_name(const ::std::string& value) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicatePopcount.qualified_name)
}
inline void PredicatePopcount::set_qualified_name(const char* value) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.PredicatePopcount.qualified_name)
}
inline void PredicatePopcount::set_qualified_name(const char* value, size_t size) {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  qualified_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.PredicatePopcount.qualified_name)
}
inline ::std::string* PredicatePopcount::mutable_qualified_name() {
  set_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    qualified_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.PredicatePopcount.qualified_name)
  return qualified_name_;
}
inline ::std::string* PredicatePopcount::release_qualified_name() {
  clear_has_qualified_name();
  if (qualified_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = qualified_name_;
    qualified_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PredicatePopcount::set_allocated_qualified_name(::std::string* qualified_name) {
  if (qualified_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete qualified_name_;
  }
  if (qualified_name) {
    set_has_qualified_name();
    qualified_name_ = qualified_name;
  } else {
    clear_has_qualified_name();
    qualified_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.PredicatePopcount.qualified_name)
}

// optional int64 popcount = 2 [default = -1];
inline bool PredicatePopcount::has_popcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredicatePopcount::set_has_popcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredicatePopcount::clear_has_popcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PredicatePopcount::clear_popcount() {
  popcount_ = GOOGLE_LONGLONG(-1);
  clear_has_popcount();
}
inline ::google::protobuf::int64 PredicatePopcount::popcount() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PredicatePopcount.popcount)
  return popcount_;
}
inline void PredicatePopcount::set_popcount(::google::protobuf::int64 value) {
  set_has_popcount();
  popcount_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PredicatePopcount.popcount)
}

// -------------------------------------------------------------------

// Constant

// required .blox.common.protocol.Constant.Kind kind = 1;
inline bool Constant::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Constant::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Constant::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Constant::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::blox::common::protocol::Constant_Kind Constant::kind() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Constant.kind)
  return static_cast< ::blox::common::protocol::Constant_Kind >(kind_);
}
inline void Constant::set_kind(::blox::common::protocol::Constant_Kind value) {
  assert(::blox::common::protocol::Constant_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.Constant.kind)
}

// optional .blox.common.protocol.BoolConstant bool_constant = 2;
inline bool Constant::has_bool_constant() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Constant::set_has_bool_constant() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Constant::clear_has_bool_constant() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Constant::clear_bool_constant() {
  if (bool_constant_ != NULL) bool_constant_->::blox::common::protocol::BoolConstant::Clear();
  clear_has_bool_constant();
}
inline const ::blox::common::protocol::BoolConstant& Constant::bool_constant() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Constant.bool_constant)
  return bool_constant_ != NULL ? *bool_constant_ : *default_instance_->bool_constant_;
}
inline ::blox::common::protocol::BoolConstant* Constant::mutable_bool_constant() {
  set_has_bool_constant();
  if (bool_constant_ == NULL) bool_constant_ = new ::blox::common::protocol::BoolConstant;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Constant.bool_constant)
  return bool_constant_;
}
inline ::blox::common::protocol::BoolConstant* Constant::release_bool_constant() {
  clear_has_bool_constant();
  ::blox::common::protocol::BoolConstant* temp = bool_constant_;
  bool_constant_ = NULL;
  return temp;
}
inline void Constant::set_allocated_bool_constant(::blox::common::protocol::BoolConstant* bool_constant) {
  delete bool_constant_;
  bool_constant_ = bool_constant;
  if (bool_constant) {
    set_has_bool_constant();
  } else {
    clear_has_bool_constant();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Constant.bool_constant)
}

// optional .blox.common.protocol.IntConstant int_constant = 3;
inline bool Constant::has_int_constant() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Constant::set_has_int_constant() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Constant::clear_has_int_constant() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Constant::clear_int_constant() {
  if (int_constant_ != NULL) int_constant_->::blox::common::protocol::IntConstant::Clear();
  clear_has_int_constant();
}
inline const ::blox::common::protocol::IntConstant& Constant::int_constant() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Constant.int_constant)
  return int_constant_ != NULL ? *int_constant_ : *default_instance_->int_constant_;
}
inline ::blox::common::protocol::IntConstant* Constant::mutable_int_constant() {
  set_has_int_constant();
  if (int_constant_ == NULL) int_constant_ = new ::blox::common::protocol::IntConstant;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Constant.int_constant)
  return int_constant_;
}
inline ::blox::common::protocol::IntConstant* Constant::release_int_constant() {
  clear_has_int_constant();
  ::blox::common::protocol::IntConstant* temp = int_constant_;
  int_constant_ = NULL;
  return temp;
}
inline void Constant::set_allocated_int_constant(::blox::common::protocol::IntConstant* int_constant) {
  delete int_constant_;
  int_constant_ = int_constant;
  if (int_constant) {
    set_has_int_constant();
  } else {
    clear_has_int_constant();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Constant.int_constant)
}

// optional .blox.common.protocol.FloatConstant float_constant = 4;
inline bool Constant::has_float_constant() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Constant::set_has_float_constant() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Constant::clear_has_float_constant() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Constant::clear_float_constant() {
  if (float_constant_ != NULL) float_constant_->::blox::common::protocol::FloatConstant::Clear();
  clear_has_float_constant();
}
inline const ::blox::common::protocol::FloatConstant& Constant::float_constant() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Constant.float_constant)
  return float_constant_ != NULL ? *float_constant_ : *default_instance_->float_constant_;
}
inline ::blox::common::protocol::FloatConstant* Constant::mutable_float_constant() {
  set_has_float_constant();
  if (float_constant_ == NULL) float_constant_ = new ::blox::common::protocol::FloatConstant;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Constant.float_constant)
  return float_constant_;
}
inline ::blox::common::protocol::FloatConstant* Constant::release_float_constant() {
  clear_has_float_constant();
  ::blox::common::protocol::FloatConstant* temp = float_constant_;
  float_constant_ = NULL;
  return temp;
}
inline void Constant::set_allocated_float_constant(::blox::common::protocol::FloatConstant* float_constant) {
  delete float_constant_;
  float_constant_ = float_constant;
  if (float_constant) {
    set_has_float_constant();
  } else {
    clear_has_float_constant();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Constant.float_constant)
}

// optional .blox.common.protocol.StringConstant string_constant = 5;
inline bool Constant::has_string_constant() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Constant::set_has_string_constant() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Constant::clear_has_string_constant() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Constant::clear_string_constant() {
  if (string_constant_ != NULL) string_constant_->::blox::common::protocol::StringConstant::Clear();
  clear_has_string_constant();
}
inline const ::blox::common::protocol::StringConstant& Constant::string_constant() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Constant.string_constant)
  return string_constant_ != NULL ? *string_constant_ : *default_instance_->string_constant_;
}
inline ::blox::common::protocol::StringConstant* Constant::mutable_string_constant() {
  set_has_string_constant();
  if (string_constant_ == NULL) string_constant_ = new ::blox::common::protocol::StringConstant;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Constant.string_constant)
  return string_constant_;
}
inline ::blox::common::protocol::StringConstant* Constant::release_string_constant() {
  clear_has_string_constant();
  ::blox::common::protocol::StringConstant* temp = string_constant_;
  string_constant_ = NULL;
  return temp;
}
inline void Constant::set_allocated_string_constant(::blox::common::protocol::StringConstant* string_constant) {
  delete string_constant_;
  string_constant_ = string_constant;
  if (string_constant) {
    set_has_string_constant();
  } else {
    clear_has_string_constant();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Constant.string_constant)
}

// optional .blox.common.protocol.DateTimeConstant date_time_constant = 6;
inline bool Constant::has_date_time_constant() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Constant::set_has_date_time_constant() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Constant::clear_has_date_time_constant() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Constant::clear_date_time_constant() {
  if (date_time_constant_ != NULL) date_time_constant_->::blox::common::protocol::DateTimeConstant::Clear();
  clear_has_date_time_constant();
}
inline const ::blox::common::protocol::DateTimeConstant& Constant::date_time_constant() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Constant.date_time_constant)
  return date_time_constant_ != NULL ? *date_time_constant_ : *default_instance_->date_time_constant_;
}
inline ::blox::common::protocol::DateTimeConstant* Constant::mutable_date_time_constant() {
  set_has_date_time_constant();
  if (date_time_constant_ == NULL) date_time_constant_ = new ::blox::common::protocol::DateTimeConstant;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Constant.date_time_constant)
  return date_time_constant_;
}
inline ::blox::common::protocol::DateTimeConstant* Constant::release_date_time_constant() {
  clear_has_date_time_constant();
  ::blox::common::protocol::DateTimeConstant* temp = date_time_constant_;
  date_time_constant_ = NULL;
  return temp;
}
inline void Constant::set_allocated_date_time_constant(::blox::common::protocol::DateTimeConstant* date_time_constant) {
  delete date_time_constant_;
  date_time_constant_ = date_time_constant;
  if (date_time_constant) {
    set_has_date_time_constant();
  } else {
    clear_has_date_time_constant();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Constant.date_time_constant)
}

// optional .blox.common.protocol.UnsignedIntConstant uint_constant = 7;
inline bool Constant::has_uint_constant() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Constant::set_has_uint_constant() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Constant::clear_has_uint_constant() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Constant::clear_uint_constant() {
  if (uint_constant_ != NULL) uint_constant_->::blox::common::protocol::UnsignedIntConstant::Clear();
  clear_has_uint_constant();
}
inline const ::blox::common::protocol::UnsignedIntConstant& Constant::uint_constant() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Constant.uint_constant)
  return uint_constant_ != NULL ? *uint_constant_ : *default_instance_->uint_constant_;
}
inline ::blox::common::protocol::UnsignedIntConstant* Constant::mutable_uint_constant() {
  set_has_uint_constant();
  if (uint_constant_ == NULL) uint_constant_ = new ::blox::common::protocol::UnsignedIntConstant;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Constant.uint_constant)
  return uint_constant_;
}
inline ::blox::common::protocol::UnsignedIntConstant* Constant::release_uint_constant() {
  clear_has_uint_constant();
  ::blox::common::protocol::UnsignedIntConstant* temp = uint_constant_;
  uint_constant_ = NULL;
  return temp;
}
inline void Constant::set_allocated_uint_constant(::blox::common::protocol::UnsignedIntConstant* uint_constant) {
  delete uint_constant_;
  uint_constant_ = uint_constant;
  if (uint_constant) {
    set_has_uint_constant();
  } else {
    clear_has_uint_constant();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Constant.uint_constant)
}

// optional .blox.common.protocol.DecimalConstant decimal_constant = 8;
inline bool Constant::has_decimal_constant() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Constant::set_has_decimal_constant() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Constant::clear_has_decimal_constant() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Constant::clear_decimal_constant() {
  if (decimal_constant_ != NULL) decimal_constant_->::blox::common::protocol::DecimalConstant::Clear();
  clear_has_decimal_constant();
}
inline const ::blox::common::protocol::DecimalConstant& Constant::decimal_constant() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Constant.decimal_constant)
  return decimal_constant_ != NULL ? *decimal_constant_ : *default_instance_->decimal_constant_;
}
inline ::blox::common::protocol::DecimalConstant* Constant::mutable_decimal_constant() {
  set_has_decimal_constant();
  if (decimal_constant_ == NULL) decimal_constant_ = new ::blox::common::protocol::DecimalConstant;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Constant.decimal_constant)
  return decimal_constant_;
}
inline ::blox::common::protocol::DecimalConstant* Constant::release_decimal_constant() {
  clear_has_decimal_constant();
  ::blox::common::protocol::DecimalConstant* temp = decimal_constant_;
  decimal_constant_ = NULL;
  return temp;
}
inline void Constant::set_allocated_decimal_constant(::blox::common::protocol::DecimalConstant* decimal_constant) {
  delete decimal_constant_;
  decimal_constant_ = decimal_constant;
  if (decimal_constant) {
    set_has_decimal_constant();
  } else {
    clear_has_decimal_constant();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Constant.decimal_constant)
}

// optional .blox.common.protocol.Int128Constant int128_constant = 9;
inline bool Constant::has_int128_constant() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Constant::set_has_int128_constant() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Constant::clear_has_int128_constant() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Constant::clear_int128_constant() {
  if (int128_constant_ != NULL) int128_constant_->::blox::common::protocol::Int128Constant::Clear();
  clear_has_int128_constant();
}
inline const ::blox::common::protocol::Int128Constant& Constant::int128_constant() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Constant.int128_constant)
  return int128_constant_ != NULL ? *int128_constant_ : *default_instance_->int128_constant_;
}
inline ::blox::common::protocol::Int128Constant* Constant::mutable_int128_constant() {
  set_has_int128_constant();
  if (int128_constant_ == NULL) int128_constant_ = new ::blox::common::protocol::Int128Constant;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Constant.int128_constant)
  return int128_constant_;
}
inline ::blox::common::protocol::Int128Constant* Constant::release_int128_constant() {
  clear_has_int128_constant();
  ::blox::common::protocol::Int128Constant* temp = int128_constant_;
  int128_constant_ = NULL;
  return temp;
}
inline void Constant::set_allocated_int128_constant(::blox::common::protocol::Int128Constant* int128_constant) {
  delete int128_constant_;
  int128_constant_ = int128_constant;
  if (int128_constant) {
    set_has_int128_constant();
  } else {
    clear_has_int128_constant();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Constant.int128_constant)
}

// -------------------------------------------------------------------

// BoolConstant

// required bool value = 1;
inline bool BoolConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoolConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoolConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoolConstant::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool BoolConstant::value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.BoolConstant.value)
  return value_;
}
inline void BoolConstant::set_value(bool value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.BoolConstant.value)
}

// optional .blox.common.protocol.Position position = 2;
inline bool BoolConstant::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoolConstant::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoolConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoolConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& BoolConstant::position() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.BoolConstant.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* BoolConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.BoolConstant.position)
  return position_;
}
inline ::blox::common::protocol::Position* BoolConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void BoolConstant::set_allocated_position(::blox::common::protocol::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.BoolConstant.position)
}

// -------------------------------------------------------------------

// IntConstant

// required int64 value = 1;
inline bool IntConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntConstant::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 IntConstant::value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.IntConstant.value)
  return value_;
}
inline void IntConstant::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.IntConstant.value)
}

// required .blox.common.protocol.Type type = 2;
inline bool IntConstant::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntConstant::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntConstant::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntConstant::clear_type() {
  if (type_ != NULL) type_->::blox::common::protocol::Type::Clear();
  clear_has_type();
}
inline const ::blox::common::protocol::Type& IntConstant::type() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.IntConstant.type)
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::blox::common::protocol::Type* IntConstant::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::blox::common::protocol::Type;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.IntConstant.type)
  return type_;
}
inline ::blox::common::protocol::Type* IntConstant::release_type() {
  clear_has_type();
  ::blox::common::protocol::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline void IntConstant::set_allocated_type(::blox::common::protocol::Type* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.IntConstant.type)
}

// optional .blox.common.protocol.Position position = 3;
inline bool IntConstant::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IntConstant::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IntConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IntConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& IntConstant::position() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.IntConstant.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* IntConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.IntConstant.position)
  return position_;
}
inline ::blox::common::protocol::Position* IntConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void IntConstant::set_allocated_position(::blox::common::protocol::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.IntConstant.position)
}

// -------------------------------------------------------------------

// UnsignedIntConstant

// required int64 value = 1;
inline bool UnsignedIntConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnsignedIntConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnsignedIntConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnsignedIntConstant::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 UnsignedIntConstant::value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.UnsignedIntConstant.value)
  return value_;
}
inline void UnsignedIntConstant::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.UnsignedIntConstant.value)
}

// required .blox.common.protocol.Type type = 2;
inline bool UnsignedIntConstant::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnsignedIntConstant::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnsignedIntConstant::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnsignedIntConstant::clear_type() {
  if (type_ != NULL) type_->::blox::common::protocol::Type::Clear();
  clear_has_type();
}
inline const ::blox::common::protocol::Type& UnsignedIntConstant::type() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.UnsignedIntConstant.type)
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::blox::common::protocol::Type* UnsignedIntConstant::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::blox::common::protocol::Type;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.UnsignedIntConstant.type)
  return type_;
}
inline ::blox::common::protocol::Type* UnsignedIntConstant::release_type() {
  clear_has_type();
  ::blox::common::protocol::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline void UnsignedIntConstant::set_allocated_type(::blox::common::protocol::Type* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.UnsignedIntConstant.type)
}

// optional .blox.common.protocol.Position position = 3;
inline bool UnsignedIntConstant::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnsignedIntConstant::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnsignedIntConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnsignedIntConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& UnsignedIntConstant::position() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.UnsignedIntConstant.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* UnsignedIntConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.UnsignedIntConstant.position)
  return position_;
}
inline ::blox::common::protocol::Position* UnsignedIntConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void UnsignedIntConstant::set_allocated_position(::blox::common::protocol::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.UnsignedIntConstant.position)
}

// -------------------------------------------------------------------

// FloatConstant

// required string value = 1;
inline bool FloatConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloatConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloatConstant::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& FloatConstant::value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.FloatConstant.value)
  return *value_;
}
inline void FloatConstant::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.FloatConstant.value)
}
inline void FloatConstant::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.FloatConstant.value)
}
inline void FloatConstant::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.FloatConstant.value)
}
inline ::std::string* FloatConstant::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.FloatConstant.value)
  return value_;
}
inline ::std::string* FloatConstant::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FloatConstant::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.FloatConstant.value)
}

// required .blox.common.protocol.Type type = 2;
inline bool FloatConstant::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloatConstant::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloatConstant::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloatConstant::clear_type() {
  if (type_ != NULL) type_->::blox::common::protocol::Type::Clear();
  clear_has_type();
}
inline const ::blox::common::protocol::Type& FloatConstant::type() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.FloatConstant.type)
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::blox::common::protocol::Type* FloatConstant::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::blox::common::protocol::Type;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.FloatConstant.type)
  return type_;
}
inline ::blox::common::protocol::Type* FloatConstant::release_type() {
  clear_has_type();
  ::blox::common::protocol::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline void FloatConstant::set_allocated_type(::blox::common::protocol::Type* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.FloatConstant.type)
}

// optional .blox.common.protocol.Position position = 3;
inline bool FloatConstant::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FloatConstant::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FloatConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FloatConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& FloatConstant::position() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.FloatConstant.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* FloatConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.FloatConstant.position)
  return position_;
}
inline ::blox::common::protocol::Position* FloatConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void FloatConstant::set_allocated_position(::blox::common::protocol::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.FloatConstant.position)
}

// -------------------------------------------------------------------

// DecimalConstant

// required string value = 1;
inline bool DecimalConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecimalConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecimalConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecimalConstant::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& DecimalConstant::value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.DecimalConstant.value)
  return *value_;
}
inline void DecimalConstant::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.DecimalConstant.value)
}
inline void DecimalConstant::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.DecimalConstant.value)
}
inline void DecimalConstant::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.DecimalConstant.value)
}
inline ::std::string* DecimalConstant::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.DecimalConstant.value)
  return value_;
}
inline ::std::string* DecimalConstant::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DecimalConstant::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.DecimalConstant.value)
}

// required .blox.common.protocol.Type type = 2;
inline bool DecimalConstant::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecimalConstant::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecimalConstant::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecimalConstant::clear_type() {
  if (type_ != NULL) type_->::blox::common::protocol::Type::Clear();
  clear_has_type();
}
inline const ::blox::common::protocol::Type& DecimalConstant::type() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.DecimalConstant.type)
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::blox::common::protocol::Type* DecimalConstant::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::blox::common::protocol::Type;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.DecimalConstant.type)
  return type_;
}
inline ::blox::common::protocol::Type* DecimalConstant::release_type() {
  clear_has_type();
  ::blox::common::protocol::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline void DecimalConstant::set_allocated_type(::blox::common::protocol::Type* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.DecimalConstant.type)
}

// optional .blox.common.protocol.Position position = 3;
inline bool DecimalConstant::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecimalConstant::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DecimalConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DecimalConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& DecimalConstant::position() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.DecimalConstant.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* DecimalConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.DecimalConstant.position)
  return position_;
}
inline ::blox::common::protocol::Position* DecimalConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void DecimalConstant::set_allocated_position(::blox::common::protocol::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.DecimalConstant.position)
}

// -------------------------------------------------------------------

// Int128Constant

// required string value = 1;
inline bool Int128Constant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Int128Constant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Int128Constant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Int128Constant::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Int128Constant::value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Int128Constant.value)
  return *value_;
}
inline void Int128Constant::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.Int128Constant.value)
}
inline void Int128Constant::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.Int128Constant.value)
}
inline void Int128Constant::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.Int128Constant.value)
}
inline ::std::string* Int128Constant::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Int128Constant.value)
  return value_;
}
inline ::std::string* Int128Constant::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Int128Constant::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Int128Constant.value)
}

// required .blox.common.protocol.Type type = 2;
inline bool Int128Constant::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Int128Constant::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Int128Constant::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Int128Constant::clear_type() {
  if (type_ != NULL) type_->::blox::common::protocol::Type::Clear();
  clear_has_type();
}
inline const ::blox::common::protocol::Type& Int128Constant::type() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Int128Constant.type)
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::blox::common::protocol::Type* Int128Constant::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::blox::common::protocol::Type;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Int128Constant.type)
  return type_;
}
inline ::blox::common::protocol::Type* Int128Constant::release_type() {
  clear_has_type();
  ::blox::common::protocol::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline void Int128Constant::set_allocated_type(::blox::common::protocol::Type* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Int128Constant.type)
}

// optional .blox.common.protocol.Position position = 3;
inline bool Int128Constant::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Int128Constant::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Int128Constant::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Int128Constant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& Int128Constant::position() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Int128Constant.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* Int128Constant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Int128Constant.position)
  return position_;
}
inline ::blox::common::protocol::Position* Int128Constant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Int128Constant::set_allocated_position(::blox::common::protocol::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Int128Constant.position)
}

// -------------------------------------------------------------------

// StringConstant

// required string value = 1;
inline bool StringConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringConstant::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& StringConstant::value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.StringConstant.value)
  return *value_;
}
inline void StringConstant::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.StringConstant.value)
}
inline void StringConstant::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.StringConstant.value)
}
inline void StringConstant::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.StringConstant.value)
}
inline ::std::string* StringConstant::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.StringConstant.value)
  return value_;
}
inline ::std::string* StringConstant::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StringConstant::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.StringConstant.value)
}

// optional .blox.common.protocol.Position position = 2;
inline bool StringConstant::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringConstant::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& StringConstant::position() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.StringConstant.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* StringConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.StringConstant.position)
  return position_;
}
inline ::blox::common::protocol::Position* StringConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void StringConstant::set_allocated_position(::blox::common::protocol::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.StringConstant.position)
}

// -------------------------------------------------------------------

// DateTimeConstant

// optional int64 value = 1;
inline bool DateTimeConstant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DateTimeConstant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DateTimeConstant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DateTimeConstant::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 DateTimeConstant::value() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.DateTimeConstant.value)
  return value_;
}
inline void DateTimeConstant::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.DateTimeConstant.value)
}

// optional .blox.common.protocol.Position position = 2;
inline bool DateTimeConstant::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DateTimeConstant::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DateTimeConstant::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DateTimeConstant::clear_position() {
  if (position_ != NULL) position_->::blox::common::protocol::Position::Clear();
  clear_has_position();
}
inline const ::blox::common::protocol::Position& DateTimeConstant::position() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.DateTimeConstant.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::blox::common::protocol::Position* DateTimeConstant::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::blox::common::protocol::Position;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.DateTimeConstant.position)
  return position_;
}
inline ::blox::common::protocol::Position* DateTimeConstant::release_position() {
  clear_has_position();
  ::blox::common::protocol::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void DateTimeConstant::set_allocated_position(::blox::common::protocol::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.DateTimeConstant.position)
}

// -------------------------------------------------------------------

// Type

// required .blox.common.protocol.Type.Kind kind = 1;
inline bool Type::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Type::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Type::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Type::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::blox::common::protocol::Type_Kind Type::kind() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Type.kind)
  return static_cast< ::blox::common::protocol::Type_Kind >(kind_);
}
inline void Type::set_kind(::blox::common::protocol::Type_Kind value) {
  assert(::blox::common::protocol::Type_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.Type.kind)
}

// optional .blox.common.protocol.PrimitiveType primitive = 2;
inline bool Type::has_primitive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Type::set_has_primitive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Type::clear_has_primitive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Type::clear_primitive() {
  if (primitive_ != NULL) primitive_->::blox::common::protocol::PrimitiveType::Clear();
  clear_has_primitive();
}
inline const ::blox::common::protocol::PrimitiveType& Type::primitive() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Type.primitive)
  return primitive_ != NULL ? *primitive_ : *default_instance_->primitive_;
}
inline ::blox::common::protocol::PrimitiveType* Type::mutable_primitive() {
  set_has_primitive();
  if (primitive_ == NULL) primitive_ = new ::blox::common::protocol::PrimitiveType;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Type.primitive)
  return primitive_;
}
inline ::blox::common::protocol::PrimitiveType* Type::release_primitive() {
  clear_has_primitive();
  ::blox::common::protocol::PrimitiveType* temp = primitive_;
  primitive_ = NULL;
  return temp;
}
inline void Type::set_allocated_primitive(::blox::common::protocol::PrimitiveType* primitive) {
  delete primitive_;
  primitive_ = primitive;
  if (primitive) {
    set_has_primitive();
  } else {
    clear_has_primitive();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Type.primitive)
}

// optional .blox.common.protocol.UnaryPredicateType unary = 3;
inline bool Type::has_unary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Type::set_has_unary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Type::clear_has_unary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Type::clear_unary() {
  if (unary_ != NULL) unary_->::blox::common::protocol::UnaryPredicateType::Clear();
  clear_has_unary();
}
inline const ::blox::common::protocol::UnaryPredicateType& Type::unary() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.Type.unary)
  return unary_ != NULL ? *unary_ : *default_instance_->unary_;
}
inline ::blox::common::protocol::UnaryPredicateType* Type::mutable_unary() {
  set_has_unary();
  if (unary_ == NULL) unary_ = new ::blox::common::protocol::UnaryPredicateType;
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.Type.unary)
  return unary_;
}
inline ::blox::common::protocol::UnaryPredicateType* Type::release_unary() {
  clear_has_unary();
  ::blox::common::protocol::UnaryPredicateType* temp = unary_;
  unary_ = NULL;
  return temp;
}
inline void Type::set_allocated_unary(::blox::common::protocol::UnaryPredicateType* unary) {
  delete unary_;
  unary_ = unary;
  if (unary) {
    set_has_unary();
  } else {
    clear_has_unary();
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.Type.unary)
}

// -------------------------------------------------------------------

// PrimitiveType

// required .blox.common.protocol.PrimitiveType.Kind kind = 1;
inline bool PrimitiveType::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrimitiveType::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrimitiveType::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrimitiveType::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::blox::common::protocol::PrimitiveType_Kind PrimitiveType::kind() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PrimitiveType.kind)
  return static_cast< ::blox::common::protocol::PrimitiveType_Kind >(kind_);
}
inline void PrimitiveType::set_kind(::blox::common::protocol::PrimitiveType_Kind value) {
  assert(::blox::common::protocol::PrimitiveType_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PrimitiveType.kind)
}

// optional int64 capacity = 2;
inline bool PrimitiveType::has_capacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrimitiveType::set_has_capacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrimitiveType::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrimitiveType::clear_capacity() {
  capacity_ = GOOGLE_LONGLONG(0);
  clear_has_capacity();
}
inline ::google::protobuf::int64 PrimitiveType::capacity() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.PrimitiveType.capacity)
  return capacity_;
}
inline void PrimitiveType::set_capacity(::google::protobuf::int64 value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:blox.common.protocol.PrimitiveType.capacity)
}

// -------------------------------------------------------------------

// UnaryPredicateType

// required string name = 1;
inline bool UnaryPredicateType::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnaryPredicateType::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnaryPredicateType::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnaryPredicateType::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UnaryPredicateType::name() const {
  // @@protoc_insertion_point(field_get:blox.common.protocol.UnaryPredicateType.name)
  return *name_;
}
inline void UnaryPredicateType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:blox.common.protocol.UnaryPredicateType.name)
}
inline void UnaryPredicateType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:blox.common.protocol.UnaryPredicateType.name)
}
inline void UnaryPredicateType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:blox.common.protocol.UnaryPredicateType.name)
}
inline ::std::string* UnaryPredicateType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:blox.common.protocol.UnaryPredicateType.name)
  return name_;
}
inline ::std::string* UnaryPredicateType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UnaryPredicateType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:blox.common.protocol.UnaryPredicateType.name)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace common
}  // namespace blox

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::blox::common::protocol::Constant_Kind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::Constant_Kind>() {
  return ::blox::common::protocol::Constant_Kind_descriptor();
}
template <> struct is_proto_enum< ::blox::common::protocol::Type_Kind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::Type_Kind>() {
  return ::blox::common::protocol::Type_Kind_descriptor();
}
template <> struct is_proto_enum< ::blox::common::protocol::PrimitiveType_Kind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::PrimitiveType_Kind>() {
  return ::blox::common::protocol::PrimitiveType_Kind_descriptor();
}
template <> struct is_proto_enum< ::blox::common::protocol::Severity> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::Severity>() {
  return ::blox::common::protocol::Severity_descriptor();
}
template <> struct is_proto_enum< ::blox::common::protocol::Lifetime> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::Lifetime>() {
  return ::blox::common::protocol::Lifetime_descriptor();
}
template <> struct is_proto_enum< ::blox::common::protocol::DerivationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::DerivationType>() {
  return ::blox::common::protocol::DerivationType_descriptor();
}
template <> struct is_proto_enum< ::blox::common::protocol::LogicSort> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blox::common::protocol::LogicSort>() {
  return ::blox::common::protocol::LogicSort_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_blox_2fcommon_2fCommon_2eproto__INCLUDED
